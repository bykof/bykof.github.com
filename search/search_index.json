{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome! On this website you will find lectures about: JavaScript Fundamentals Browser API React BYOT - Build Your Own Tool Or just click in the left upper corner on Lectures Feel free to visit my website: https://bykovski.de","title":"Welcome!"},{"location":"#welcome","text":"On this website you will find lectures about: JavaScript Fundamentals Browser API React BYOT - Build Your Own Tool Or just click in the left upper corner on Lectures Feel free to visit my website: https://bykovski.de","title":"Welcome!"},{"location":"example/","text":"","title":"Example"},{"location":"exercises/javascript-fundamentals/","text":"Startpage Hello and welcome to JavaScript Fundamentals Exercises!","title":"Startpage"},{"location":"exercises/javascript-fundamentals/#startpage","text":"Hello and welcome to JavaScript Fundamentals Exercises!","title":"Startpage"},{"location":"lectures/","text":"Introduction Welcome to my lectures which I collected, wrote, reevaluated and worked on in several years. On the left side you will find several topics of my lectures.","title":"Introduction"},{"location":"lectures/#introduction","text":"Welcome to my lectures which I collected, wrote, reevaluated and worked on in several years. On the left side you will find several topics of my lectures.","title":"Introduction"},{"location":"lectures/browser-api/","text":"Introduction Welcome to my lecture Browser API!","title":"Introduction"},{"location":"lectures/browser-api/#introduction","text":"Welcome to my lecture Browser API!","title":"Introduction"},{"location":"lectures/browser-api/browser-vs-node/","text":"Browser vs. Node The difference between node and browser environment The red blocks are displaying the different environments, where the JavaScript engine (V8, the blue block) can be embedded. On the left side in the image there is the browser environment, which provides a Browser API . On the right side in the image ther is the node (system) environment, which provides a Node API . So V8 is the interpreter that understands all JavaScript Code and just executes it, beside that we also need ways to access the browser or system. Accessing the browser's DOM (document object model) or a specific directory in the system's file-system is not given by \"just\" running V8. Therefore the environments (browser, node) attach specific APIs to your JavaScript environment. Browser API The Browser API is able to deliver functionality to run specific tasks in the browser, like showing an alert box, fetching and modifying a DOM-element or sending a HTTP-request. The most important Browser API object is: window All properties and methods of the Window object are exposed to the global environment. const element = window.document.getElementById(\"main\"); // is the same as const element2 = document.getElementById(\"main\"); There are also more APIs: Web APIs Node API The Node API is able to deliver functionality to run specific tasks on the system, like reading a file in a directory, get system information, creating a TCP-socket. There is no \"global object\", which holds all important functionality. There are a lot of different objects like crypto , child_process or timers .","title":"Browser vs. Node"},{"location":"lectures/browser-api/browser-vs-node/#browser-vs-node","text":"The difference between node and browser environment The red blocks are displaying the different environments, where the JavaScript engine (V8, the blue block) can be embedded. On the left side in the image there is the browser environment, which provides a Browser API . On the right side in the image ther is the node (system) environment, which provides a Node API . So V8 is the interpreter that understands all JavaScript Code and just executes it, beside that we also need ways to access the browser or system. Accessing the browser's DOM (document object model) or a specific directory in the system's file-system is not given by \"just\" running V8. Therefore the environments (browser, node) attach specific APIs to your JavaScript environment.","title":"Browser vs. Node"},{"location":"lectures/browser-api/browser-vs-node/#browser-api","text":"The Browser API is able to deliver functionality to run specific tasks in the browser, like showing an alert box, fetching and modifying a DOM-element or sending a HTTP-request. The most important Browser API object is: window All properties and methods of the Window object are exposed to the global environment. const element = window.document.getElementById(\"main\"); // is the same as const element2 = document.getElementById(\"main\"); There are also more APIs: Web APIs","title":"Browser API"},{"location":"lectures/browser-api/browser-vs-node/#node-api","text":"The Node API is able to deliver functionality to run specific tasks on the system, like reading a file in a directory, get system information, creating a TCP-socket. There is no \"global object\", which holds all important functionality. There are a lot of different objects like crypto , child_process or timers .","title":"Node API"},{"location":"lectures/browser-api/dom/","text":"DOM (Document Object Model) The Javascript DOM (Document Object Model) is an interface that allows developers to manipulate the content, structure and style of a website. Document Object Model The DOM document is the owner of all other objects in your webpage. That means if you want to access any object on your webpage you always have to start with the document. It also contains many important properties and methods that enable us to access and modify our website. The document is attached to the window object. Therefore you could use both: window.document; // or document; <document> Finding elements To find an element there are functions starting with getElementBy... : index.html : <p id=\"title\">This is my title</p> <p class=\"text\">A text</p> <p class=\"text\">Another text</p> index.js : const title = document.getElementById(\"title\"); const texts = document.getElementsByClassName(\"text\"); const pElements = document.getElementsByTagName(\"p\"); Queryselector With a queryselector it's possible to retrieve the elements via CSS-selectors index.html : <p id=\"title\">This is my title</p> <p class=\"text\">A text</p> <p class=\"text\">Another text</p> index.js : const title = document.querySelector(\"#title\"); const texts = document.querySelectorAll(\".text\"); const pElements = document.querySelectorAll(\"p\");","title":"DOM (Document Object Model)"},{"location":"lectures/browser-api/dom/#dom-document-object-model","text":"The Javascript DOM (Document Object Model) is an interface that allows developers to manipulate the content, structure and style of a website. Document Object Model The DOM document is the owner of all other objects in your webpage. That means if you want to access any object on your webpage you always have to start with the document. It also contains many important properties and methods that enable us to access and modify our website. The document is attached to the window object. Therefore you could use both: window.document; // or document;","title":"DOM (Document Object Model)"},{"location":"lectures/browser-api/dom/#document","text":"","title":"&lt;document&gt;"},{"location":"lectures/browser-api/dom/#finding-elements","text":"To find an element there are functions starting with getElementBy... : index.html : <p id=\"title\">This is my title</p> <p class=\"text\">A text</p> <p class=\"text\">Another text</p> index.js : const title = document.getElementById(\"title\"); const texts = document.getElementsByClassName(\"text\"); const pElements = document.getElementsByTagName(\"p\");","title":"Finding elements"},{"location":"lectures/browser-api/dom/#queryselector","text":"With a queryselector it's possible to retrieve the elements via CSS-selectors index.html : <p id=\"title\">This is my title</p> <p class=\"text\">A text</p> <p class=\"text\">Another text</p> index.js : const title = document.querySelector(\"#title\"); const texts = document.querySelectorAll(\".text\"); const pElements = document.querySelectorAll(\"p\");","title":"Queryselector"},{"location":"lectures/browser-api/element/","text":"Element When retrieving an element from the document you will get an object which is an instance of HTMLElement . HTMLElement HTMLElement inherits from Element . Element inherits from Node . Node inherits from EventTarget . Which means that you are able to use all the functionality and properties provided by HTMLElement , Element , Node and EventTarget . Manipulation HTMLElements are directly bound to the DOM, which means that if you manipulate the HTMLElement this will reflect instantly in the DOM. Instant bind of HTMLElement to the DOM Code: const element = document.getElementById(\"title\"); element.innerText = \"123\"; Note that you cannot manipulate Read only fields like: offsetLeft , dataset and many more... Creation Surely there is the possibility to create a HTMLElement. Creating an element means to create it in the document first and then append it to an element you like. const divElement = document.createElement(\"div\"); After creation you can append it to an element: const h1Element = document.createElement(\"h1\"); h1Element.innerText = \"Hello World!\"; document.body.append(h1Element); Events Because deep in the inheritance, the HTMLElement inherits from an EventTarget, you can use addEventListener to attach an event listener to an element. For example: const element = document.getElementById(\"title\"); element.addEventListener(\"click\", (event) => { console.log(`${event} was clicked!`); }); Here are all events: Link","title":"Element"},{"location":"lectures/browser-api/element/#element","text":"When retrieving an element from the document you will get an object which is an instance of HTMLElement . HTMLElement HTMLElement inherits from Element . Element inherits from Node . Node inherits from EventTarget . Which means that you are able to use all the functionality and properties provided by HTMLElement , Element , Node and EventTarget .","title":"Element"},{"location":"lectures/browser-api/element/#manipulation","text":"HTMLElements are directly bound to the DOM, which means that if you manipulate the HTMLElement this will reflect instantly in the DOM. Instant bind of HTMLElement to the DOM Code: const element = document.getElementById(\"title\"); element.innerText = \"123\"; Note that you cannot manipulate Read only fields like: offsetLeft , dataset and many more...","title":"Manipulation"},{"location":"lectures/browser-api/element/#creation","text":"Surely there is the possibility to create a HTMLElement. Creating an element means to create it in the document first and then append it to an element you like. const divElement = document.createElement(\"div\"); After creation you can append it to an element: const h1Element = document.createElement(\"h1\"); h1Element.innerText = \"Hello World!\"; document.body.append(h1Element);","title":"Creation"},{"location":"lectures/browser-api/element/#events","text":"Because deep in the inheritance, the HTMLElement inherits from an EventTarget, you can use addEventListener to attach an event listener to an element. For example: const element = document.getElementById(\"title\"); element.addEventListener(\"click\", (event) => { console.log(`${event} was clicked!`); }); Here are all events: Link","title":"Events"},{"location":"lectures/browser-api/fetch/","text":"Fetch Fetch is a new approach to send HTTP requests to servers. Fetch uses a promise-based approach. fetch(\"http://echo.jsontest.com/key/value/one/two\") .then((response) => { return response.json(); }) .then((json) => { console.log(json); }); Surely you can use the promise-based approach with async/await : const receiveOneTwo = async () => { try { const response = await fetch(\"http://echo.jsontest.com/key/value/one/two\"); const json = await response.json(); console.log(json); } catch (error) { console.error(error); } }; receiveOneTwo().catch(console.error);","title":"Fetch"},{"location":"lectures/browser-api/fetch/#fetch","text":"Fetch is a new approach to send HTTP requests to servers. Fetch uses a promise-based approach. fetch(\"http://echo.jsontest.com/key/value/one/two\") .then((response) => { return response.json(); }) .then((json) => { console.log(json); }); Surely you can use the promise-based approach with async/await : const receiveOneTwo = async () => { try { const response = await fetch(\"http://echo.jsontest.com/key/value/one/two\"); const json = await response.json(); console.log(json); } catch (error) { console.error(error); } }; receiveOneTwo().catch(console.error);","title":"Fetch"},{"location":"lectures/browser-api/html/","text":"HTML This is a default HTML document. <!DOCTYPE html> <html lang=\"en\"> <head> <title>Sample page</title> <script type=\"text/javascript\" src=\"./index.js\"> </head> <body> <h1>Sample page</h1> <p>This is a <a href=\"demo.html\">simple</a> sample.</p> <!-- this is a comment --> </body> </html> The <!DOCTYPE html> is actually not a HTML-element but it describes the document as a HTML-document for the browser. Then it starts with the most outer element <html>...</html> . It holds the <head></head> and <body></body> elements together. <head> Within the <head> element we define properties of the document \"which we don't see\" (except the title). We also define here links to other documents like JavaScript and CSS files. <body> Within the <body> element we define elements of the documents \"which we will see\".","title":"HTML"},{"location":"lectures/browser-api/html/#html","text":"This is a default HTML document. <!DOCTYPE html> <html lang=\"en\"> <head> <title>Sample page</title> <script type=\"text/javascript\" src=\"./index.js\"> </head> <body> <h1>Sample page</h1> <p>This is a <a href=\"demo.html\">simple</a> sample.</p> <!-- this is a comment --> </body> </html> The <!DOCTYPE html> is actually not a HTML-element but it describes the document as a HTML-document for the browser. Then it starts with the most outer element <html>...</html> . It holds the <head></head> and <body></body> elements together.","title":"HTML"},{"location":"lectures/browser-api/html/#head","text":"Within the <head> element we define properties of the document \"which we don't see\" (except the title). We also define here links to other documents like JavaScript and CSS files.","title":"&lt;head&gt;"},{"location":"lectures/browser-api/html/#body","text":"Within the <body> element we define elements of the documents \"which we will see\".","title":"&lt;body&gt;"},{"location":"lectures/browser-api/web-apis/","text":"Web APIs Web APIs allow to communicate with the Browser via JavaScript and to trigger different functions. Web APIs are exposed as global functions or objects into the current JavaScript environment. window For example there is a window object exposed, which contains all the information about the current window (the current tab): window.console.log(window.innerHeight); window.console.log(window.innerWidth); All attributes and methods of the window object, are exposed to your JavaScript environment automatically. So you could use: window.console.log(\"Test\"); // or simply console.log(\"Test\");","title":"Web APIs"},{"location":"lectures/browser-api/web-apis/#web-apis","text":"Web APIs allow to communicate with the Browser via JavaScript and to trigger different functions. Web APIs are exposed as global functions or objects into the current JavaScript environment.","title":"Web APIs"},{"location":"lectures/browser-api/web-apis/#window","text":"For example there is a window object exposed, which contains all the information about the current window (the current tab): window.console.log(window.innerHeight); window.console.log(window.innerWidth); All attributes and methods of the window object, are exposed to your JavaScript environment automatically. So you could use: window.console.log(\"Test\"); // or simply console.log(\"Test\");","title":"window"},{"location":"lectures/browser-api/xmlhttprequest/","text":"XMLHttpRequest \" XMLHttpRequest (XHR) objects are used to interact with servers. You can retrieve data from a URL without having to do a full page refresh. This enables a Web page to update just part of a page without disrupting what the user is doing. XMLHttpRequest is used heavily in AJAX (Asynchronous JavaScript and XML) programming.\" const request = new XMLHttpRequest(); request.onload = (event) => { const json = request.response; console.log(json); }; request.open(\"GET\", \"http://echo.jsontest.com/key/value/one/two\"); request.responseType = \"json\"; request.send(); XMLHttpRequest uses an event-based approach. When the request is sent with request.send() the browser will send the prepared request and call the onload function of the request after the response was received. Consider that after using the request.send() method the thread won't block! Non blocking request.send","title":"XMLHttpRequest"},{"location":"lectures/browser-api/xmlhttprequest/#xmlhttprequest","text":"\" XMLHttpRequest (XHR) objects are used to interact with servers. You can retrieve data from a URL without having to do a full page refresh. This enables a Web page to update just part of a page without disrupting what the user is doing. XMLHttpRequest is used heavily in AJAX (Asynchronous JavaScript and XML) programming.\" const request = new XMLHttpRequest(); request.onload = (event) => { const json = request.response; console.log(json); }; request.open(\"GET\", \"http://echo.jsontest.com/key/value/one/two\"); request.responseType = \"json\"; request.send(); XMLHttpRequest uses an event-based approach. When the request is sent with request.send() the browser will send the prepared request and call the onload function of the request after the response was received. Consider that after using the request.send() method the thread won't block! Non blocking request.send","title":"XMLHttpRequest"},{"location":"lectures/byot/","text":"Introduction Build Your Own Tool follows the idea, that you build a small tool with the least effort possible. To achieve this solution there is currently a best practice way to do so. Strapi is an open source headless CMS which is build with JavaScript. Next.JS is a React Framework. You can find the whole example as repository on Github","title":"Introduction"},{"location":"lectures/byot/#introduction","text":"Build Your Own Tool follows the idea, that you build a small tool with the least effort possible. To achieve this solution there is currently a best practice way to do so. Strapi is an open source headless CMS which is build with JavaScript. Next.JS is a React Framework. You can find the whole example as repository on Github","title":"Introduction"},{"location":"lectures/byot/add-theme/","text":"Add Theme We add a theme to our application first with: yarn add 98.css and then in the file dashboard/pages/_app.js : import \"../styles/globals.css\"; import \"98.css\"; function MyApp({ Component, pageProps }) { return <Component {...pageProps} />; } export default MyApp;","title":"Add Theme"},{"location":"lectures/byot/add-theme/#add-theme","text":"We add a theme to our application first with: yarn add 98.css and then in the file dashboard/pages/_app.js : import \"../styles/globals.css\"; import \"98.css\"; function MyApp({ Component, pageProps }) { return <Component {...pageProps} />; } export default MyApp;","title":"Add Theme"},{"location":"lectures/byot/api/","text":"API Find Now after we setup the Content-Type and the Roles & Permissions we are able to access the api: http://localhost:1337/events We will get a response like this: [ { id: 1, name: \"TechTalk #46 - BYOT - Build Your Own Tool mit Strapi und Next.js!\", description: \" \"Schnell mal ein Tool bauen\" ist f\u00fcr viele eine gro\u00dfe Herausforderung. Es muss ein Backend mit Datenbankzugriff, REST-Schnittstellen, Benutzerverwaltung und vielen mehr entwickelt werden. Hinzu kommt, dass eine Oberfl\u00e4che f\u00fcr das Eintragen und Anzeigen der Daten implementiert werden muss. Des Weiteren bleibt es meistens nicht bei der Verwaltung und Anzeige der Daten, denn es wird noch dazu ein Gesch\u00e4ftsprozess programmiert. Mit Strapi und Next.JS zeige ich anhand eines Live-Coding-Beispiels, wie ein Event-Verwaltungstool f\u00fcr interne Events eines Unternehmens in unter einer Stunde entwickelt werden kann.\", start: \"2020-10-02T15:00:00.000Z\", end: \"2020-10-02T18:00:00.000Z\", created_by: { id: 1, firstname: \"Test\", lastname: \"test\", username: null }, updated_by: { id: 1, firstname: \"Test\", lastname: \"test\", username: null }, created_at: \"2020-09-21T07:20:05.564Z\", updated_at: \"2020-09-21T07:20:05.573Z\" } ] Find One And we can directly access the event with the id: http://localhost:1337/events/1 Response: { id: 1, name: \"TechTalk #46 - BYOT - Build Your Own Tool mit Strapi und Next.js!\", description: \" \"Schnell mal ein Tool bauen\" ist f\u00fcr viele eine gro\u00dfe Herausforderung. Es muss ein Backend mit Datenbankzugriff, REST-Schnittstellen, Benutzerverwaltung und vielen mehr entwickelt werden. Hinzu kommt, dass eine Oberfl\u00e4che f\u00fcr das Eintragen und Anzeigen der Daten implementiert werden muss. Des Weiteren bleibt es meistens nicht bei der Verwaltung und Anzeige der Daten, denn es wird noch dazu ein Gesch\u00e4ftsprozess programmiert. Mit Strapi und Next.JS zeige ich anhand eines Live-Coding-Beispiels, wie ein Event-Verwaltungstool f\u00fcr interne Events eines Unternehmens in unter einer Stunde entwickelt werden kann.\", start: \"2020-10-02T15:00:00.000Z\", end: \"2020-10-02T18:00:00.000Z\", created_by: { id: 1, firstname: \"Test\", lastname: \"test\", username: null }, updated_by: { id: 1, firstname: \"Test\", lastname: \"test\", username: null }, created_at: \"2020-09-21T07:20:05.564Z\", updated_at: \"2020-09-21T07:20:05.573Z\" }","title":"API"},{"location":"lectures/byot/api/#api","text":"","title":"API"},{"location":"lectures/byot/api/#find","text":"Now after we setup the Content-Type and the Roles & Permissions we are able to access the api: http://localhost:1337/events We will get a response like this: [ { id: 1, name: \"TechTalk #46 - BYOT - Build Your Own Tool mit Strapi und Next.js!\", description: \" \"Schnell mal ein Tool bauen\" ist f\u00fcr viele eine gro\u00dfe Herausforderung. Es muss ein Backend mit Datenbankzugriff, REST-Schnittstellen, Benutzerverwaltung und vielen mehr entwickelt werden. Hinzu kommt, dass eine Oberfl\u00e4che f\u00fcr das Eintragen und Anzeigen der Daten implementiert werden muss. Des Weiteren bleibt es meistens nicht bei der Verwaltung und Anzeige der Daten, denn es wird noch dazu ein Gesch\u00e4ftsprozess programmiert. Mit Strapi und Next.JS zeige ich anhand eines Live-Coding-Beispiels, wie ein Event-Verwaltungstool f\u00fcr interne Events eines Unternehmens in unter einer Stunde entwickelt werden kann.\", start: \"2020-10-02T15:00:00.000Z\", end: \"2020-10-02T18:00:00.000Z\", created_by: { id: 1, firstname: \"Test\", lastname: \"test\", username: null }, updated_by: { id: 1, firstname: \"Test\", lastname: \"test\", username: null }, created_at: \"2020-09-21T07:20:05.564Z\", updated_at: \"2020-09-21T07:20:05.573Z\" } ]","title":"Find"},{"location":"lectures/byot/api/#find-one","text":"And we can directly access the event with the id: http://localhost:1337/events/1 Response: { id: 1, name: \"TechTalk #46 - BYOT - Build Your Own Tool mit Strapi und Next.js!\", description: \" \"Schnell mal ein Tool bauen\" ist f\u00fcr viele eine gro\u00dfe Herausforderung. Es muss ein Backend mit Datenbankzugriff, REST-Schnittstellen, Benutzerverwaltung und vielen mehr entwickelt werden. Hinzu kommt, dass eine Oberfl\u00e4che f\u00fcr das Eintragen und Anzeigen der Daten implementiert werden muss. Des Weiteren bleibt es meistens nicht bei der Verwaltung und Anzeige der Daten, denn es wird noch dazu ein Gesch\u00e4ftsprozess programmiert. Mit Strapi und Next.JS zeige ich anhand eines Live-Coding-Beispiels, wie ein Event-Verwaltungstool f\u00fcr interne Events eines Unternehmens in unter einer Stunde entwickelt werden kann.\", start: \"2020-10-02T15:00:00.000Z\", end: \"2020-10-02T18:00:00.000Z\", created_by: { id: 1, firstname: \"Test\", lastname: \"test\", username: null }, updated_by: { id: 1, firstname: \"Test\", lastname: \"test\", username: null }, created_at: \"2020-09-21T07:20:05.564Z\", updated_at: \"2020-09-21T07:20:05.573Z\" }","title":"Find One"},{"location":"lectures/byot/client/","text":"Client To communicate with the server, we need to implement a client in the dashboard. And to work easier with HTTP requests and responses, we install Axios: yarn add axios Now we implement the client: dashboard/client/index.js import Axios from \"axios\"; export const API_URL = \"http://localhost:1337\"; export const getEvents = async () => { return Axios.get(`${API_URL}/events`); };","title":"Client"},{"location":"lectures/byot/client/#client","text":"To communicate with the server, we need to implement a client in the dashboard. And to work easier with HTTP requests and responses, we install Axios: yarn add axios Now we implement the client: dashboard/client/index.js import Axios from \"axios\"; export const API_URL = \"http://localhost:1337\"; export const getEvents = async () => { return Axios.get(`${API_URL}/events`); };","title":"Client"},{"location":"lectures/byot/content-type/","text":"Content-Type Let's create our first content type. Imagine we want to build a small tool, which helps a company to store their upcoming and past events. First we need to create a \"content type\". You can compare it to a model or database table, which stores your information. Strapi creates and alters your table in the database automatically, so we just have to setup the content type through the UI. Click on the left side on Content-Types Builder and then on Create new collection type : Then we enter the name of the new content type Event for example: We click on Continue and add a new Textfield to the model: After that we enter \"name\" as name for the field and check the Advanded Settings , where we check required field . Now we do that for description (optional Textfield), start (required DateTimefield), end (required DateTimefield). After we created the fields we should see this model. We press Save to let Strapi create the tables in the database. On the left side under Collection Types should appear Events . We click on Events and then on Add New Event : Enter data for a new event and click on Save :","title":"Content-Type"},{"location":"lectures/byot/content-type/#content-type","text":"Let's create our first content type. Imagine we want to build a small tool, which helps a company to store their upcoming and past events. First we need to create a \"content type\". You can compare it to a model or database table, which stores your information. Strapi creates and alters your table in the database automatically, so we just have to setup the content type through the UI. Click on the left side on Content-Types Builder and then on Create new collection type : Then we enter the name of the new content type Event for example: We click on Continue and add a new Textfield to the model: After that we enter \"name\" as name for the field and check the Advanded Settings , where we check required field . Now we do that for description (optional Textfield), start (required DateTimefield), end (required DateTimefield). After we created the fields we should see this model. We press Save to let Strapi create the tables in the database. On the left side under Collection Types should appear Events . We click on Events and then on Add New Event : Enter data for a new event and click on Save :","title":"Content-Type"},{"location":"lectures/byot/implement-the-frontend/","text":"Implement the frontend Event Component First let's create a component to show our events later: dashboard/components/Event.js import React from \"react\"; const windowStyles = { width: 300, marginBottom: 10 }; export const Event = ({ name, description, start, end }) => { const startDate = new Date(start); const endDate = new Date(end); return ( <div className=\"window\" style={windowStyles}> <div className=\"title-bar\"> <div className=\"title-bar-text\">{name}</div> </div> <div className=\"window-body\"> <p>{description}</p> <p style={{ textAlign: \"right\" }}> {startDate.toLocaleString()} - {endDate.toLocaleString()} </p> </div> </div> ); }; export default Event; Add react-query To fetch data properly from the backend server, we will use the library react-query . It is able to fetch, cache, synchronize and update server state. We install it using: yarn add react-query Fetch and display data All preparations are done so far, so let's go and fetch the data from the server and display it by using our created Event component, our implemented client , and the react-query library. dashboard/pages/index.js import Head from \"next/head\"; import { useQuery } from \"react-query\"; import { getEvents } from \"../client\"; import Event from \"../components/Event\"; const mainStyle = { padding: 30, display: \"flex\", alignItems: \"center\", justifyContent: \"space-evenly\", flexWrap: \"wrap\", }; export default function Home() { const { isLoading, isError, data: events, error } = useQuery( \"events\", getEvents ); const loadingBar = isLoading && <div>Loading...</div>; const errorBar = isError && <div>{error.toString()}</div>; return ( <div> <Head> <title>Events Dashboard</title> </Head> <main style={mainStyle}> {loadingBar} {errorBar} {events && events.map((event) => ( <Event key={event.id} name={event.name} description={event.description} start={event.start} end={event.end} /> ))} </main> </div> ); } Result","title":"Implement the frontend"},{"location":"lectures/byot/implement-the-frontend/#implement-the-frontend","text":"","title":"Implement the frontend"},{"location":"lectures/byot/implement-the-frontend/#event-component","text":"First let's create a component to show our events later: dashboard/components/Event.js import React from \"react\"; const windowStyles = { width: 300, marginBottom: 10 }; export const Event = ({ name, description, start, end }) => { const startDate = new Date(start); const endDate = new Date(end); return ( <div className=\"window\" style={windowStyles}> <div className=\"title-bar\"> <div className=\"title-bar-text\">{name}</div> </div> <div className=\"window-body\"> <p>{description}</p> <p style={{ textAlign: \"right\" }}> {startDate.toLocaleString()} - {endDate.toLocaleString()} </p> </div> </div> ); }; export default Event;","title":"Event Component"},{"location":"lectures/byot/implement-the-frontend/#add-react-query","text":"To fetch data properly from the backend server, we will use the library react-query . It is able to fetch, cache, synchronize and update server state. We install it using: yarn add react-query","title":"Add react-query"},{"location":"lectures/byot/implement-the-frontend/#fetch-and-display-data","text":"All preparations are done so far, so let's go and fetch the data from the server and display it by using our created Event component, our implemented client , and the react-query library. dashboard/pages/index.js import Head from \"next/head\"; import { useQuery } from \"react-query\"; import { getEvents } from \"../client\"; import Event from \"../components/Event\"; const mainStyle = { padding: 30, display: \"flex\", alignItems: \"center\", justifyContent: \"space-evenly\", flexWrap: \"wrap\", }; export default function Home() { const { isLoading, isError, data: events, error } = useQuery( \"events\", getEvents ); const loadingBar = isLoading && <div>Loading...</div>; const errorBar = isError && <div>{error.toString()}</div>; return ( <div> <Head> <title>Events Dashboard</title> </Head> <main style={mainStyle}> {loadingBar} {errorBar} {events && events.map((event) => ( <Event key={event.id} name={event.name} description={event.description} start={event.start} end={event.end} /> ))} </main> </div> ); }","title":"Fetch and display data"},{"location":"lectures/byot/implement-the-frontend/#result","text":"","title":"Result"},{"location":"lectures/byot/installation/","text":"Installation To setup the projects you need to install Node.JS . Preferably you need yarn .","title":"Installation"},{"location":"lectures/byot/installation/#installation","text":"To setup the projects you need to install Node.JS . Preferably you need yarn .","title":"Installation"},{"location":"lectures/byot/roles-and-permissions/","text":"Roles & Permissions Before we consume our created content type Event , we need to enable the endpoint find and findOne to public API.","title":"Roles & Permissions"},{"location":"lectures/byot/roles-and-permissions/#roles-permissions","text":"Before we consume our created content type Event , we need to enable the endpoint find and findOne to public API.","title":"Roles &amp; Permissions"},{"location":"lectures/byot/setup-next/","text":"Setup Next.JS Now that we have setup our headless CMS, we can create a frontend to show an event dashboard for our employees. For that we run: npx create-next-app dashboard","title":"Setup Next.JS"},{"location":"lectures/byot/setup-next/#setup-nextjs","text":"Now that we have setup our headless CMS, we can create a frontend to show an event dashboard for our employees. For that we run: npx create-next-app dashboard","title":"Setup Next.JS"},{"location":"lectures/byot/setup/","text":"Setup Strapi Create a new project with: yarn create strapi-app backend --quickstart Now your browser should show up this site:","title":"Setup Strapi"},{"location":"lectures/byot/setup/#setup-strapi","text":"Create a new project with: yarn create strapi-app backend --quickstart Now your browser should show up this site:","title":"Setup Strapi"},{"location":"lectures/javascript-fundamentals/","text":"Introduction Welcome to my lecture JavaScript Fundamentals!","title":"Introduction"},{"location":"lectures/javascript-fundamentals/#introduction","text":"Welcome to my lecture JavaScript Fundamentals!","title":"Introduction"},{"location":"lectures/javascript-fundamentals/assert/","text":"Assert Please consider that the used assert object in the following examples only exists in Node.JS! If you are going to programm JavaScript in the browser, it won't be possible to use assert.equal for example. The Browser API only supports console.assert(condition, msg). So if you want to assert in the browser, you have to do the condition by yourself. For example: const a = 2; const b = 3; const c = 4; console.assert(a !== b, \"a equals b\"); console.assert(a === c / 2, \"a equals c divided by 2\");","title":"Assert"},{"location":"lectures/javascript-fundamentals/assert/#assert","text":"Please consider that the used assert object in the following examples only exists in Node.JS! If you are going to programm JavaScript in the browser, it won't be possible to use assert.equal for example. The Browser API only supports console.assert(condition, msg). So if you want to assert in the browser, you have to do the condition by yourself. For example: const a = 2; const b = 3; const c = 4; console.assert(a !== b, \"a equals b\"); console.assert(a === c / 2, \"a equals c divided by 2\");","title":"Assert"},{"location":"lectures/javascript-fundamentals/asynchronicity/","text":"Asynchronicity If you use JavaScript there are several parts, which help you to get all the necessary APIs and functionality to work: JS Engines and APIs JavaScript Engine is the JavaScript interpreter which runs your code and handles variables, etc. Platform Core is the platform dependent functionality, e.g. to send requests or to read files from local storage JS Standard Library brings all standard functionality, for example for Arrays or Objects Platform API provides platform dependent APIs to execute code which reads files or sends requests. If you execute code, which needs heavy computational time, then this code will block the process. That's because JavaScript is single-thread only . So keep in mind, everything that runs in your JavaScript engine is always in a single thread ! If everything in JavaScript is single-threaded, why then Web UIs doesn't block if they send a request to a server, to wait until they receive the belonging response? The event loop of JavaScript Check this Visualization to see how the event loop works. Callbacks const onInterval = () => { console.log(\"Executed on interval\"); }; setInterval(onInterval, 1000); setInterval(() => { console.log(\"Shorter way\"); }, 1000); const onInterval = () => { console.log(\"Before sleep\"); sleep(1500); console.log(\"After sleep\"); }; const sleep = (milliseconds) => { const start = Date.now(); while (Date.now() - start < milliseconds); }; setInterval(onInterval, 1000); Promises Promises are the default solution to program asynchronous code though there exist 'old' APIs with callback mechanisms. Nevertheless this is not a big deal since we can just wrap callbacks in Promises . The three states of Promises Promises have three different states: Pending - the Promise still waits for a result Fulfilled - the Promise has finished and got a result (no errors) Rejected - the Promise hash finished and got an error (no results) const addAsync = (x, y) => { return new Promise((resolve, reject) => { if (x === undefined || y === undefined) { return reject(new Error(\"Must provide two parameters\")); } else { return resolve(x + y); } }); }; const prom = addAsync(1, 2); prom .then((result) => { console.log(`The result is: ${result}`); }) .catch((error) => { console.error(`There was an error: ${error}`); }) .finally(() => { console.log(\"Runs always, either its an error or a result\"); }); Exceptions in Promises const myError = new Error(\"My error!\"); const promise = new Promise((resolve, reject) => { resolve(123); }); promise .then((result) => { console.log(`Result is ${result} but i will throw an error`); throw myError; }) .catch((error) => { console.error(`Error is: ${error}`); }); Returning in then() const addAsync = (x, y) => { return new Promise((resolve, reject) => { if (x === undefined || y === undefined) { reject(new Error(\"Must provide two parameters\")); } else { resolve(x + y); } }); }; const multAsync = (x, y) => { return new Promise((resolve, reject) => { if (x === undefined || y === undefined) { reject(new Error(\"Must provide two parameters\")); } else { resolve(x * y); } }); }; addAsync(1, 2) .then((result) => { console.log(`Add result is: ${result}`); return multAsync(result, 4); }) .then((result) => { console.log(`Mult result is: ${result}`); }) .catch((error) => { console.error(`There was an error: ${error}`); }); Async Async functions are just a syntactic wrapper for Promises. This means that you can use Promises and async/await interchangeable. But it's better to prefer the async/await syntax since it's more clear and most developers prefer the procedural style. const fetchJsonViaPromises = (url) => { return fetch(url) .then((request) => request.text()) .then((text) => JSON.parse(text)) .catch((error) => { console.error(error); }); }; const fetchJsonAsync = async (url) => { try { const request = await fetch(url); const text = await request.text(); return JSON.parse(text); } catch (error) { console.error(error); } }; Interchangeability const addAsync = async (x, y) => { return x + y; }; addAsync .then((result) => { console.log(`Result is: ${result}`); }) .catch(console.error);","title":"Asynchronicity"},{"location":"lectures/javascript-fundamentals/asynchronicity/#asynchronicity","text":"If you use JavaScript there are several parts, which help you to get all the necessary APIs and functionality to work: JS Engines and APIs JavaScript Engine is the JavaScript interpreter which runs your code and handles variables, etc. Platform Core is the platform dependent functionality, e.g. to send requests or to read files from local storage JS Standard Library brings all standard functionality, for example for Arrays or Objects Platform API provides platform dependent APIs to execute code which reads files or sends requests. If you execute code, which needs heavy computational time, then this code will block the process. That's because JavaScript is single-thread only . So keep in mind, everything that runs in your JavaScript engine is always in a single thread ! If everything in JavaScript is single-threaded, why then Web UIs doesn't block if they send a request to a server, to wait until they receive the belonging response? The event loop of JavaScript Check this Visualization to see how the event loop works.","title":"Asynchronicity"},{"location":"lectures/javascript-fundamentals/asynchronicity/#callbacks","text":"const onInterval = () => { console.log(\"Executed on interval\"); }; setInterval(onInterval, 1000); setInterval(() => { console.log(\"Shorter way\"); }, 1000); const onInterval = () => { console.log(\"Before sleep\"); sleep(1500); console.log(\"After sleep\"); }; const sleep = (milliseconds) => { const start = Date.now(); while (Date.now() - start < milliseconds); }; setInterval(onInterval, 1000);","title":"Callbacks"},{"location":"lectures/javascript-fundamentals/asynchronicity/#promises","text":"Promises are the default solution to program asynchronous code though there exist 'old' APIs with callback mechanisms. Nevertheless this is not a big deal since we can just wrap callbacks in Promises . The three states of Promises Promises have three different states: Pending - the Promise still waits for a result Fulfilled - the Promise has finished and got a result (no errors) Rejected - the Promise hash finished and got an error (no results) const addAsync = (x, y) => { return new Promise((resolve, reject) => { if (x === undefined || y === undefined) { return reject(new Error(\"Must provide two parameters\")); } else { return resolve(x + y); } }); }; const prom = addAsync(1, 2); prom .then((result) => { console.log(`The result is: ${result}`); }) .catch((error) => { console.error(`There was an error: ${error}`); }) .finally(() => { console.log(\"Runs always, either its an error or a result\"); });","title":"Promises"},{"location":"lectures/javascript-fundamentals/asynchronicity/#exceptions-in-promises","text":"const myError = new Error(\"My error!\"); const promise = new Promise((resolve, reject) => { resolve(123); }); promise .then((result) => { console.log(`Result is ${result} but i will throw an error`); throw myError; }) .catch((error) => { console.error(`Error is: ${error}`); });","title":"Exceptions in Promises"},{"location":"lectures/javascript-fundamentals/asynchronicity/#returning-in-then","text":"const addAsync = (x, y) => { return new Promise((resolve, reject) => { if (x === undefined || y === undefined) { reject(new Error(\"Must provide two parameters\")); } else { resolve(x + y); } }); }; const multAsync = (x, y) => { return new Promise((resolve, reject) => { if (x === undefined || y === undefined) { reject(new Error(\"Must provide two parameters\")); } else { resolve(x * y); } }); }; addAsync(1, 2) .then((result) => { console.log(`Add result is: ${result}`); return multAsync(result, 4); }) .then((result) => { console.log(`Mult result is: ${result}`); }) .catch((error) => { console.error(`There was an error: ${error}`); });","title":"Returning in then()"},{"location":"lectures/javascript-fundamentals/asynchronicity/#async","text":"Async functions are just a syntactic wrapper for Promises. This means that you can use Promises and async/await interchangeable. But it's better to prefer the async/await syntax since it's more clear and most developers prefer the procedural style. const fetchJsonViaPromises = (url) => { return fetch(url) .then((request) => request.text()) .then((text) => JSON.parse(text)) .catch((error) => { console.error(error); }); }; const fetchJsonAsync = async (url) => { try { const request = await fetch(url); const text = await request.text(); return JSON.parse(text); } catch (error) { console.error(error); } };","title":"Async"},{"location":"lectures/javascript-fundamentals/asynchronicity/#interchangeability","text":"const addAsync = async (x, y) => { return x + y; }; addAsync .then((result) => { console.log(`Result is: ${result}`); }) .catch(console.error);","title":"Interchangeability"},{"location":"lectures/javascript-fundamentals/classes/","text":"Classes Constructor Functions There is the existence of constructor functions: function Person(name) { this.name = name; this.describe = function () { return \"Person named \" + this.name; }; } assert.equal(typeof Person, \"function\"); const person = new Person(\"Test\"); assert.equal(typeof person, \"object\"); assert.equal(person.name, \"Test\"); assert.equal(person.describe(), \"Person named Test\"); But they are used less frequently because of the implementation of Classes in ES6. So it became more convenient to use classes instead of constructor functions : class Person { constructor(name) { this.name = name; } describe() { return \"Person named \" + this.name; } get upperCaseName() { return this.name.toUpperCase(); } set setUpperCaseName(value) { this.name = value.toUpperCase(); } } const person = new Person(\"Test\"); assert.equal(person.name, \"Test\"); assert.equal(person.describe(), \"Person named Test\"); assert.equal(person.upperCaseName, \"TEST\"); person.setUpperCaseName = \"anotherTest\"; assert.equal(person.name, \"ANOTHERTEST\"); person.name = \"backTest\"; assert.equal(person.name, \"backTest\"); Inheritance class Person { constructor(firstName, lastName) { this.firstName = firstName; this.lastName = lastName; } fullName() { return `${this.firstName} ${this.lastName}`; } } class Employee extends Person { constructor(firstName, lastName, position) { super(firstName, lastName); this.position = position; } } const empl1 = new Employee(\"Test\", \"Testlast\", \"Developer\"); assert.equal(empl1.fullName(), \"Test Testlast\"); Static class Person { constructor(firstName, lastName) { this.firstName = firstName; this.lastName = lastName; } static createDefaultPerson() { return new Person(\"Test\", \"TestPerson\"); } }","title":"Classes"},{"location":"lectures/javascript-fundamentals/classes/#classes","text":"","title":"Classes"},{"location":"lectures/javascript-fundamentals/classes/#constructor-functions","text":"There is the existence of constructor functions: function Person(name) { this.name = name; this.describe = function () { return \"Person named \" + this.name; }; } assert.equal(typeof Person, \"function\"); const person = new Person(\"Test\"); assert.equal(typeof person, \"object\"); assert.equal(person.name, \"Test\"); assert.equal(person.describe(), \"Person named Test\"); But they are used less frequently because of the implementation of Classes in ES6. So it became more convenient to use classes instead of constructor functions : class Person { constructor(name) { this.name = name; } describe() { return \"Person named \" + this.name; } get upperCaseName() { return this.name.toUpperCase(); } set setUpperCaseName(value) { this.name = value.toUpperCase(); } } const person = new Person(\"Test\"); assert.equal(person.name, \"Test\"); assert.equal(person.describe(), \"Person named Test\"); assert.equal(person.upperCaseName, \"TEST\"); person.setUpperCaseName = \"anotherTest\"; assert.equal(person.name, \"ANOTHERTEST\"); person.name = \"backTest\"; assert.equal(person.name, \"backTest\");","title":"Constructor Functions"},{"location":"lectures/javascript-fundamentals/classes/#inheritance","text":"class Person { constructor(firstName, lastName) { this.firstName = firstName; this.lastName = lastName; } fullName() { return `${this.firstName} ${this.lastName}`; } } class Employee extends Person { constructor(firstName, lastName, position) { super(firstName, lastName); this.position = position; } } const empl1 = new Employee(\"Test\", \"Testlast\", \"Developer\"); assert.equal(empl1.fullName(), \"Test Testlast\");","title":"Inheritance"},{"location":"lectures/javascript-fundamentals/classes/#static","text":"class Person { constructor(firstName, lastName) { this.firstName = firstName; this.lastName = lastName; } static createDefaultPerson() { return new Person(\"Test\", \"TestPerson\"); } }","title":"Static"},{"location":"lectures/javascript-fundamentals/complex-values/","text":"Complex Values Arrays const shoppingList = [\"milk\", \"rice\", \"sugar\"]; const values = [\"abc\", 123, [\"dfg\", \"jkl\"]]; assert.equal(shoppingList[0], \"milk\"); assert.equal(shoppingList.length, 3); // Adding an item shopping_list.push(\"potatoes\"); assert.equal(shoppingList.length, 4); // Shrinking the array to a length shopping_list.length = 1; assert.equal(shoppingList, [\"milk\"]); // Remove at 0 index 1 element from array shopping_list.splice(0, 1); All possible functions: Arrays Destructuring const arr = [\"a\", \"b\", \"c\"]; const [a, b, c, d = \"d\"] = arr; assert.equal(a, \"a\"); assert.equal(b, \"b\"); assert.equal(c, \"c\"); assert.equal(d, \"d\"); Spreading const arr = [1, 2, 3]; const copyArr = [...arr]; const anotherCopyArr = [0, ...arr, 4, 5, 6]; assert.equal(arr, arr); assert.notEqual(arr, copyArr); assert.deepEqual(arr, copyArr); copyArr; // [ 1, 2, 3 ] anotherCopyArr; /* [ 0, 1, 2, 3, 4, 5, 6 ] */ Map Filter Reduce Find const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; const mappedArr = arr.map((value) => value + 1); const filteredArr = arr.filter((value) => value % 2 === 0); const reducedArr = arr.reduce((value, total) => total + value, 0); const findArr = arr.find((value) => value === 9); const notFindArr = arr.find((value) => value === 10); assert.deepEqual(mappedArr, [2, 3, 4, 5, 6, 7, 8, 9, 10]); assert.deepEqual(filteredArr, [2, 4, 6, 8]); assert.deepEqual(reducedArr, 45); assert.deepEqual(findArr, 9); assert.deepEqual(notFindArr, undefined); See Anonymous Functions for further information. Objects const person = { firstName: 'Test', lastName: 'Testlast', }; assert.equal(person.firstName, 'Test'); assert.equal(person['firstName'], 'Test'); person.age = 12; assert.equal( person, { firstName: 'Test', lastName: 'Testlast', age: 12 } ) > Uncaught AssertionError assert.deepEqual( person, { firstName: 'Test', lastName: 'Testlast', age: 12 } ) All possible functions: MDN Docs Destructuring const person = { firstName: \"Test\", lastName: \"Testlast\", }; const { firstName, lastName, age = 0 } = person; const { fName, lName } = person; assert.equal(firstName, \"Test\"); assert.equal(lastName, \"Testlast\"); assert.equal(age, 0); assert.equal(fName, undefined); assert.equal(lName, undefined); Spreading const person = { firstName: \"Test\", lastName: \"Testlast\", }; const newPerson = { firstName: \"AnotherTest\", ...person, age: 18, }; assert.deepEqual(newPerson, { firstName: \"Test\", lastName: \"Testlast\", age: 18, }); Object.keys const person = { firstName: 'Test', lastName: 'Testlast', }; assert.equal( Object.keys(person), ['firstName', 'lastName'], ); > Uncaught AssertionError assert.deepEqual( Object.keys(person), ['firstName', 'lastName'], ); Object.values const person = { firstName: \"Test\", lastName: \"Testlast\", }; assert.deepEqual(Object.values(person), [\"Test\", \"Testlast\"]); Methods const person = { firstName: \"Test\", lastName: \"Testlast\", fullName: function () { return `${this.firstName} ${this.lastName}`; }, }; assert.equal(person.fullName(), \"Test Testlast\");","title":"Complex Values"},{"location":"lectures/javascript-fundamentals/complex-values/#complex-values","text":"","title":"Complex Values"},{"location":"lectures/javascript-fundamentals/complex-values/#arrays","text":"const shoppingList = [\"milk\", \"rice\", \"sugar\"]; const values = [\"abc\", 123, [\"dfg\", \"jkl\"]]; assert.equal(shoppingList[0], \"milk\"); assert.equal(shoppingList.length, 3); // Adding an item shopping_list.push(\"potatoes\"); assert.equal(shoppingList.length, 4); // Shrinking the array to a length shopping_list.length = 1; assert.equal(shoppingList, [\"milk\"]); // Remove at 0 index 1 element from array shopping_list.splice(0, 1); All possible functions: Arrays","title":"Arrays"},{"location":"lectures/javascript-fundamentals/complex-values/#destructuring","text":"const arr = [\"a\", \"b\", \"c\"]; const [a, b, c, d = \"d\"] = arr; assert.equal(a, \"a\"); assert.equal(b, \"b\"); assert.equal(c, \"c\"); assert.equal(d, \"d\");","title":"Destructuring"},{"location":"lectures/javascript-fundamentals/complex-values/#spreading","text":"const arr = [1, 2, 3]; const copyArr = [...arr]; const anotherCopyArr = [0, ...arr, 4, 5, 6]; assert.equal(arr, arr); assert.notEqual(arr, copyArr); assert.deepEqual(arr, copyArr); copyArr; // [ 1, 2, 3 ] anotherCopyArr; /* [ 0, 1, 2, 3, 4, 5, 6 ] */","title":"Spreading"},{"location":"lectures/javascript-fundamentals/complex-values/#map-filter-reduce-find","text":"const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; const mappedArr = arr.map((value) => value + 1); const filteredArr = arr.filter((value) => value % 2 === 0); const reducedArr = arr.reduce((value, total) => total + value, 0); const findArr = arr.find((value) => value === 9); const notFindArr = arr.find((value) => value === 10); assert.deepEqual(mappedArr, [2, 3, 4, 5, 6, 7, 8, 9, 10]); assert.deepEqual(filteredArr, [2, 4, 6, 8]); assert.deepEqual(reducedArr, 45); assert.deepEqual(findArr, 9); assert.deepEqual(notFindArr, undefined); See Anonymous Functions for further information.","title":"Map Filter Reduce Find"},{"location":"lectures/javascript-fundamentals/complex-values/#objects","text":"const person = { firstName: 'Test', lastName: 'Testlast', }; assert.equal(person.firstName, 'Test'); assert.equal(person['firstName'], 'Test'); person.age = 12; assert.equal( person, { firstName: 'Test', lastName: 'Testlast', age: 12 } ) > Uncaught AssertionError assert.deepEqual( person, { firstName: 'Test', lastName: 'Testlast', age: 12 } ) All possible functions: MDN Docs","title":"Objects"},{"location":"lectures/javascript-fundamentals/complex-values/#destructuring_1","text":"const person = { firstName: \"Test\", lastName: \"Testlast\", }; const { firstName, lastName, age = 0 } = person; const { fName, lName } = person; assert.equal(firstName, \"Test\"); assert.equal(lastName, \"Testlast\"); assert.equal(age, 0); assert.equal(fName, undefined); assert.equal(lName, undefined);","title":"Destructuring"},{"location":"lectures/javascript-fundamentals/complex-values/#spreading_1","text":"const person = { firstName: \"Test\", lastName: \"Testlast\", }; const newPerson = { firstName: \"AnotherTest\", ...person, age: 18, }; assert.deepEqual(newPerson, { firstName: \"Test\", lastName: \"Testlast\", age: 18, });","title":"Spreading"},{"location":"lectures/javascript-fundamentals/complex-values/#objectkeys","text":"const person = { firstName: 'Test', lastName: 'Testlast', }; assert.equal( Object.keys(person), ['firstName', 'lastName'], ); > Uncaught AssertionError assert.deepEqual( Object.keys(person), ['firstName', 'lastName'], );","title":"Object.keys"},{"location":"lectures/javascript-fundamentals/complex-values/#objectvalues","text":"const person = { firstName: \"Test\", lastName: \"Testlast\", }; assert.deepEqual(Object.values(person), [\"Test\", \"Testlast\"]);","title":"Object.values"},{"location":"lectures/javascript-fundamentals/complex-values/#methods","text":"const person = { firstName: \"Test\", lastName: \"Testlast\", fullName: function () { return `${this.firstName} ${this.lastName}`; }, }; assert.equal(person.fullName(), \"Test Testlast\");","title":"Methods"},{"location":"lectures/javascript-fundamentals/conditions/","text":"Conditions Truthy vs. Falsy values Falsy values are: undefined null Boolean: false Numbers: 0, NaN Bigint: 0n String: \"\" Note All other values are truthy! if-condition const a = 2; const b = 3; if (a === b) { console.log(\"equal\"); } else { console.log(\"not equal\"); } if-in-condition const a = { firstName: \"Test\", lastName: \"Testlast\", }; assert.equal(\"firstName\" in a, true); assert.equal(\"lastName\" in a, true); assert.equal(\"Test\" in a, false); assert.equal(\"NotExistingKey\" in a, false); const b = [\"a\", \"b\", \"c\"]; assert.equal(\"a\" in b, false); assert.equal(\"b\" in b, false); assert.equal(0 in b, true); assert.equal(2 in b, true); assert.equal(3 in b, false); switch-case const STARTED = \"started\"; const FINISHED = \"finished\"; const status = STARTED; switch (status) { case STARTED: console.log(\"Process has started!\"); break; case FINISHED: console.log(\"Process has finished!\"); break; default: console.log(\"Unknown status!\"); } // Process has started!","title":"Conditions"},{"location":"lectures/javascript-fundamentals/conditions/#conditions","text":"","title":"Conditions"},{"location":"lectures/javascript-fundamentals/conditions/#truthy-vs-falsy-values","text":"Falsy values are: undefined null Boolean: false Numbers: 0, NaN Bigint: 0n String: \"\" Note All other values are truthy!","title":"Truthy vs. Falsy values"},{"location":"lectures/javascript-fundamentals/conditions/#if-condition","text":"const a = 2; const b = 3; if (a === b) { console.log(\"equal\"); } else { console.log(\"not equal\"); }","title":"if-condition"},{"location":"lectures/javascript-fundamentals/conditions/#if-in-condition","text":"const a = { firstName: \"Test\", lastName: \"Testlast\", }; assert.equal(\"firstName\" in a, true); assert.equal(\"lastName\" in a, true); assert.equal(\"Test\" in a, false); assert.equal(\"NotExistingKey\" in a, false); const b = [\"a\", \"b\", \"c\"]; assert.equal(\"a\" in b, false); assert.equal(\"b\" in b, false); assert.equal(0 in b, true); assert.equal(2 in b, true); assert.equal(3 in b, false);","title":"if-in-condition"},{"location":"lectures/javascript-fundamentals/conditions/#switch-case","text":"const STARTED = \"started\"; const FINISHED = \"finished\"; const status = STARTED; switch (status) { case STARTED: console.log(\"Process has started!\"); break; case FINISHED: console.log(\"Process has finished!\"); break; default: console.log(\"Unknown status!\"); } // Process has started!","title":"switch-case"},{"location":"lectures/javascript-fundamentals/exceptions/","text":"Exceptions The Error object Any value can be thrown, but it's convenient to throw an Error object: throw new Error(\"Unexpected Error\"); Try... Catch const oddValue = (value) => { if (value % 2 === 0) { throw new Error(`${value} is not odd!`); } }; try { oddValue(3); oddValue(2); } catch (error) { console.error(error); } finally { console.log(\"this will be printed always!\"); } // Error: 2 is not odd!","title":"Exceptions"},{"location":"lectures/javascript-fundamentals/exceptions/#exceptions","text":"","title":"Exceptions"},{"location":"lectures/javascript-fundamentals/exceptions/#the-error-object","text":"Any value can be thrown, but it's convenient to throw an Error object: throw new Error(\"Unexpected Error\");","title":"The Error object"},{"location":"lectures/javascript-fundamentals/exceptions/#try-catch","text":"const oddValue = (value) => { if (value % 2 === 0) { throw new Error(`${value} is not odd!`); } }; try { oddValue(3); oddValue(2); } catch (error) { console.error(error); } finally { console.log(\"this will be printed always!\"); } // Error: 2 is not odd!","title":"Try... Catch"},{"location":"lectures/javascript-fundamentals/functions/","text":"Functions JavaScript has two categories of functions An ordinary function can play several roles: Real function Method Constructor function A specialized function can only play one of those roles \u2013 for example: An arrow function can only be a real function. A method can only be a method. A class can only be a constructor function. Ordinary Functions Parts of Ordinary Functions function add(x, y) { return x + y; } add is the name of the function declaration. add(x, y) is the head of the function declaration. x and y are the parameters. The curly braces ({and}) and everything between them are the body of the function declaration. The return statement explicitly returns value from the function. Different ways to define the same: an ordinary function Three ways of doing (roughly) the same thing: creating an ordinary function. // Function declaration (a statement) function ordinary1(a, b, c) { // \u00b7\u00b7\u00b7 } // const plus anonymous function expression const ordinary2 = function (a, b, c) { // \u00b7\u00b7\u00b7 }; // const plus named function expression const ordinary3 = function myName(a, b, c) { // `myName` is only accessible in here }; Roles of an ordinary function function add(x, y) { return x + y; } This function declaration creates an ordinary function whose name is add . As an ordinary function, add() can play three roles: 1. Real function: invoked via a function call: assert.equal(add(2, 1), 3); 2. Method: stored in property, invoked via a method call: const obj = { addAsMethod: add }; assert.equal(obj.addAsMethod(2, 4), 6); // (A) obj is called the receiver of the method call. It can be accessed via this inside the method. 3. Constructor function/class: invoked via new. const inst = new add(); assert.equal(inst instanceof add, true); Specialized Functions Specialized functions are single-purpose versions of ordinary functions. Each one of them specializes in one single role : Roles of specialized function The purpose of an arrow function is to be a real function: const arrow = () => { return 123; }; assert.equal(arrow(), 123); The purpose of a method is to be a method: const obj = { method() { return \"abc\"; }, }; assert.equal(obj.method(), \"abc\"); The purpose of a class is to be a constructor function: class MyClass { /* \u00b7\u00b7\u00b7 */ } const inst = new MyClass(); Use specialized over ordinary functions function funcDecl(x, y) { return x * y; } const arrowFunc = (x, y) => { return x * y; }; Arrow Functions const f = function (x, y, z) { return 123; }; const f = (x, y, z) => { return 123; }; const f = (x, y, z) => 123; const plusTwo = (x) => x + 2; Arrow Functions are often used as a parameter of callback-functions [1, 2, 3].map((x) => x + 1); What about this 'this'? In ordinary functions 'this' always relates to current function. In specialized functions 'this' always relates to the lexical this which is mostly preferred. const prefixer = { prefix: \"==> \", prefixStringArray(stringArray) { return stringArray.map(function (x) { return this.prefix + x; }); }, }; prefixer.prefixStringArray([\"a\", \"b\", \"c\"])[ (\"undefineda\", \"undefinedb\", \"undefinedc\") ]; const prefixerRight = { prefix: \"==> \", prefixStringArray(stringArray) { return stringArray.map((x) => { return this.prefix + x; }); }, }; prefixerRight.prefixStringArray([\"a\", \"b\", \"c\"])[(\"==> a\", \"==> b\", \"==> c\")];","title":"Functions"},{"location":"lectures/javascript-fundamentals/functions/#functions","text":"JavaScript has two categories of functions An ordinary function can play several roles: Real function Method Constructor function A specialized function can only play one of those roles \u2013 for example: An arrow function can only be a real function. A method can only be a method. A class can only be a constructor function.","title":"Functions"},{"location":"lectures/javascript-fundamentals/functions/#ordinary-functions","text":"","title":"Ordinary Functions"},{"location":"lectures/javascript-fundamentals/functions/#parts-of-ordinary-functions","text":"function add(x, y) { return x + y; } add is the name of the function declaration. add(x, y) is the head of the function declaration. x and y are the parameters. The curly braces ({and}) and everything between them are the body of the function declaration. The return statement explicitly returns value from the function.","title":"Parts of Ordinary Functions"},{"location":"lectures/javascript-fundamentals/functions/#different-ways-to-define-the-same-an-ordinary-function","text":"Three ways of doing (roughly) the same thing: creating an ordinary function. // Function declaration (a statement) function ordinary1(a, b, c) { // \u00b7\u00b7\u00b7 } // const plus anonymous function expression const ordinary2 = function (a, b, c) { // \u00b7\u00b7\u00b7 }; // const plus named function expression const ordinary3 = function myName(a, b, c) { // `myName` is only accessible in here };","title":"Different ways to define the same: an ordinary function"},{"location":"lectures/javascript-fundamentals/functions/#roles-of-an-ordinary-function","text":"function add(x, y) { return x + y; } This function declaration creates an ordinary function whose name is add . As an ordinary function, add() can play three roles:","title":"Roles of an ordinary function"},{"location":"lectures/javascript-fundamentals/functions/#1-real-function-invoked-via-a-function-call","text":"assert.equal(add(2, 1), 3);","title":"1. Real function: invoked via a function call:"},{"location":"lectures/javascript-fundamentals/functions/#2-method-stored-in-property-invoked-via-a-method-call","text":"const obj = { addAsMethod: add }; assert.equal(obj.addAsMethod(2, 4), 6); // (A) obj is called the receiver of the method call. It can be accessed via this inside the method.","title":"2. Method: stored in property, invoked via a method call:"},{"location":"lectures/javascript-fundamentals/functions/#3-constructor-functionclass-invoked-via-new","text":"const inst = new add(); assert.equal(inst instanceof add, true);","title":"3. Constructor function/class: invoked via new."},{"location":"lectures/javascript-fundamentals/functions/#specialized-functions","text":"Specialized functions are single-purpose versions of ordinary functions. Each one of them specializes in one single role :","title":"Specialized Functions"},{"location":"lectures/javascript-fundamentals/functions/#roles-of-specialized-function","text":"","title":"Roles of specialized function"},{"location":"lectures/javascript-fundamentals/functions/#the-purpose-of-an-arrow-function-is-to-be-a-real-function","text":"const arrow = () => { return 123; }; assert.equal(arrow(), 123);","title":"The purpose of an arrow function is to be a real function:"},{"location":"lectures/javascript-fundamentals/functions/#the-purpose-of-a-method-is-to-be-a-method","text":"const obj = { method() { return \"abc\"; }, }; assert.equal(obj.method(), \"abc\");","title":"The purpose of a method is to be a method:"},{"location":"lectures/javascript-fundamentals/functions/#the-purpose-of-a-class-is-to-be-a-constructor-function","text":"class MyClass { /* \u00b7\u00b7\u00b7 */ } const inst = new MyClass();","title":"The purpose of a class is to be a constructor function:"},{"location":"lectures/javascript-fundamentals/functions/#use-specialized-over-ordinary-functions","text":"function funcDecl(x, y) { return x * y; } const arrowFunc = (x, y) => { return x * y; };","title":"Use specialized over ordinary functions"},{"location":"lectures/javascript-fundamentals/functions/#arrow-functions","text":"const f = function (x, y, z) { return 123; }; const f = (x, y, z) => { return 123; }; const f = (x, y, z) => 123; const plusTwo = (x) => x + 2; Arrow Functions are often used as a parameter of callback-functions [1, 2, 3].map((x) => x + 1);","title":"Arrow Functions"},{"location":"lectures/javascript-fundamentals/functions/#what-about-this-this","text":"In ordinary functions 'this' always relates to current function. In specialized functions 'this' always relates to the lexical this which is mostly preferred. const prefixer = { prefix: \"==> \", prefixStringArray(stringArray) { return stringArray.map(function (x) { return this.prefix + x; }); }, }; prefixer.prefixStringArray([\"a\", \"b\", \"c\"])[ (\"undefineda\", \"undefinedb\", \"undefinedc\") ]; const prefixerRight = { prefix: \"==> \", prefixStringArray(stringArray) { return stringArray.map((x) => { return this.prefix + x; }); }, }; prefixerRight.prefixStringArray([\"a\", \"b\", \"c\"])[(\"==> a\", \"==> b\", \"==> c\")];","title":"What about this 'this'?"},{"location":"lectures/javascript-fundamentals/history/","text":"History JavaScript was created in May 1995 in 10 days, by Brendan Eich. Eich worked at Netscape and implemented JavaScript for their web browser, Netscape Navigator. The idea was that major interactive parts of the client-side web were to be implemented in Java. JavaScript was supposed to be a glue language for those parts and to also make HTML slightly more interactive. Given its role of assisting Java, JavaScript had to look like Java. That ruled out existing solutions such as Perl, Python, TCL, and others. Initially, JavaScript\u2019s name changed several times: * Its code name was Mocha. * In the Netscape Navigator 2.0 betas (September 1995), it was called LiveScript. * In Netscape Navigator 2.0 beta 3 (December 1995), it got its final name, JavaScript. ECMAScript Standard (European Computer Manufacturers Association) The language described by these standards is called ECMAScript, not JavaScript. A differ- ent name was chosen because Sun (now Oracle) had a trademark for the latter name. The \u201cECMA\u201d in \u201cECMAScript\u201d comes from the organization that hosts the primary standard. The term JavaScript refers to the language and its implementations. The term ECMAScript refers to the language standard and language versions. Current ECMAScript Version: 11th Edition (ECMAScript 2020)","title":"History"},{"location":"lectures/javascript-fundamentals/history/#history","text":"JavaScript was created in May 1995 in 10 days, by Brendan Eich. Eich worked at Netscape and implemented JavaScript for their web browser, Netscape Navigator. The idea was that major interactive parts of the client-side web were to be implemented in Java. JavaScript was supposed to be a glue language for those parts and to also make HTML slightly more interactive. Given its role of assisting Java, JavaScript had to look like Java. That ruled out existing solutions such as Perl, Python, TCL, and others. Initially, JavaScript\u2019s name changed several times: * Its code name was Mocha. * In the Netscape Navigator 2.0 betas (September 1995), it was called LiveScript. * In Netscape Navigator 2.0 beta 3 (December 1995), it got its final name, JavaScript. ECMAScript Standard (European Computer Manufacturers Association) The language described by these standards is called ECMAScript, not JavaScript. A differ- ent name was chosen because Sun (now Oracle) had a trademark for the latter name. The \u201cECMA\u201d in \u201cECMAScript\u201d comes from the organization that hosts the primary standard. The term JavaScript refers to the language and its implementations. The term ECMAScript refers to the language standard and language versions. Current ECMAScript Version: 11th Edition (ECMAScript 2020)","title":"History"},{"location":"lectures/javascript-fundamentals/loops/","text":"Loops while-loops const arr = [\"a\", \"b\", \"c\"]; while (arr.length > 0) { const elem = arr.shift(); // remove first element console.log(elem); } Endless Loop while (true) { if (Math.random() === 0) break; } for-loops for (let i = 0; i < 3; i++) { console.log(i); } Loop over an array const arr = [\"a\", \"b\", \"c\"]; for (let i = 0; i < arr.length; i++) { console.log(arr[i]); } for-of-loops Use this rather than for-loops because here you define the element as const const iterable = [\"hello\", \"world\"]; for (const elem of iterable) { console.log(elem); } for-in-loops (avoid!) const obj = { a: 1, b: 2 }; for (const key in obj) { console.log(key); } Loop over lists instead const obj = { a: 1, b: 2 }; for (const key of Object.keys(obj)) { console.log(key); }","title":"Loops"},{"location":"lectures/javascript-fundamentals/loops/#loops","text":"","title":"Loops"},{"location":"lectures/javascript-fundamentals/loops/#while-loops","text":"const arr = [\"a\", \"b\", \"c\"]; while (arr.length > 0) { const elem = arr.shift(); // remove first element console.log(elem); }","title":"while-loops"},{"location":"lectures/javascript-fundamentals/loops/#endless-loop","text":"while (true) { if (Math.random() === 0) break; }","title":"Endless Loop"},{"location":"lectures/javascript-fundamentals/loops/#for-loops","text":"for (let i = 0; i < 3; i++) { console.log(i); }","title":"for-loops"},{"location":"lectures/javascript-fundamentals/loops/#loop-over-an-array","text":"const arr = [\"a\", \"b\", \"c\"]; for (let i = 0; i < arr.length; i++) { console.log(arr[i]); }","title":"Loop over an array"},{"location":"lectures/javascript-fundamentals/loops/#for-of-loops","text":"Use this rather than for-loops because here you define the element as const const iterable = [\"hello\", \"world\"]; for (const elem of iterable) { console.log(elem); }","title":"for-of-loops"},{"location":"lectures/javascript-fundamentals/loops/#for-in-loops-avoid","text":"const obj = { a: 1, b: 2 }; for (const key in obj) { console.log(key); }","title":"for-in-loops (avoid!)"},{"location":"lectures/javascript-fundamentals/loops/#loop-over-lists-instead","text":"const obj = { a: 1, b: 2 }; for (const key of Object.keys(obj)) { console.log(key); }","title":"Loop over lists instead"},{"location":"lectures/javascript-fundamentals/primitive-values/","text":"Primitive Values undefined vs. null undefined means \"not initialized\" (e.g. a variable) or \"not existing\" (e.g. a property of an object) null means \"the intentional absence of any object value\" (a quote from the language specification) let myVar; assert.equal(myVar, undefined); function func(x) { return x; } assert.equal(func(), undefined); const obj = {}; assert.equal(obj.unknownProp, undefined); function func() {} assert.equal(func(), undefined); Booleans const a = true; const b = false; const c = Boolean(\"\"); const d = Boolean(123); assert.equal(c, false); assert.equal(d, true); See Truthy vs. Falsy values for further information Numbers All numbers are doubles with 64-bit floating point assert.equal(98, 98.0); Strings const str1 = \"abc\"; const str2 = \"abc\"; assert.equal(str1[0], str2[0]); All possible functions: MDN Docs Template Strings const firstName = \"Test\"; const lastName = \"LastTest\"; const str = `${firstName} ${lastName}`; const str2 = firstName + \" \" + lastName;","title":"Primitive Values"},{"location":"lectures/javascript-fundamentals/primitive-values/#primitive-values","text":"","title":"Primitive Values"},{"location":"lectures/javascript-fundamentals/primitive-values/#undefined-vs-null","text":"undefined means \"not initialized\" (e.g. a variable) or \"not existing\" (e.g. a property of an object) null means \"the intentional absence of any object value\" (a quote from the language specification) let myVar; assert.equal(myVar, undefined); function func(x) { return x; } assert.equal(func(), undefined); const obj = {}; assert.equal(obj.unknownProp, undefined); function func() {} assert.equal(func(), undefined);","title":"undefined vs. null"},{"location":"lectures/javascript-fundamentals/primitive-values/#booleans","text":"const a = true; const b = false; const c = Boolean(\"\"); const d = Boolean(123); assert.equal(c, false); assert.equal(d, true); See Truthy vs. Falsy values for further information","title":"Booleans"},{"location":"lectures/javascript-fundamentals/primitive-values/#numbers","text":"All numbers are doubles with 64-bit floating point assert.equal(98, 98.0);","title":"Numbers"},{"location":"lectures/javascript-fundamentals/primitive-values/#strings","text":"const str1 = \"abc\"; const str2 = \"abc\"; assert.equal(str1[0], str2[0]); All possible functions: MDN Docs","title":"Strings"},{"location":"lectures/javascript-fundamentals/primitive-values/#template-strings","text":"const firstName = \"Test\"; const lastName = \"LastTest\"; const str = `${firstName} ${lastName}`; const str2 = firstName + \" \" + lastName;","title":"Template Strings"},{"location":"lectures/javascript-fundamentals/references/","text":"References For this lecture I used the following book as reference: JavaScript for impatient programmers MDN web docs : cover various web technologies such as CSS, HTML, JavaScript, and more. An excellent reference. Node.js Docs : documenting the Node.js API. Deep JavaScript : Goes deep into JavaScript techniques and methods","title":"References"},{"location":"lectures/javascript-fundamentals/references/#references","text":"For this lecture I used the following book as reference: JavaScript for impatient programmers MDN web docs : cover various web technologies such as CSS, HTML, JavaScript, and more. An excellent reference. Node.js Docs : documenting the Node.js API. Deep JavaScript : Goes deep into JavaScript techniques and methods","title":"References"},{"location":"lectures/javascript-fundamentals/statements-vs-expressions/","text":"Statements vs. Expression Statements Statements perform instructions step by step. let myStr; if (myBool) { myStr = \"Yes\"; } else { myStr = \"No\"; } Expressions Expressions always produce a value. let myStr = myBool ? \"Yes\" : \"No\"; Operators Most operators work with primitive values. Equality Loose Equality (avoid!) \"123\" == 123; // true false == 0; // true Strict Equality false === 0; // false \"123\" === 123; // false Ordering 5 >= 2; // true \"bar\" < \"foo\"; //true Nullish Coalescing Checks if the first value is 'nullish' and uses the second value if so a ?? b; // is the same as a !== undefined && a !== null ? a : b; OR Operator Checks if the first value is 'falsy' and uses the second value if so undefined || \"default\"; // \"default\" null || \"default\"; // \"default\" false || \"default\"; // \"default\" 0 || \"default\"; // \"default\" 0n || \"default\"; // \"default\" \"\" || \"default\"; // \"default\" true || \"default\"; // true \"some text\" || \"default\"; // \"some text\" AND Operator Checks if the first value is 'truthy' and uses the second value if so [1, 2, 3] && 'default' // 'default' {a: 2} && 'default' // 'default' true && 'default' // 'default' 123 && 'default' // 'default' 4n && 'default' // 'default' 'asdf' && 'default' // 'default' false && 'default' // false What is allowed where? The body of a function must be a sequence of statements: function max(x, y) { if (x > y) { return x; } else { return y; } } The arguments of a function call or a method call must be expressions: console.log(\"ab\" + \"cd\", Number(\"123\"));","title":"Statements vs. Expression"},{"location":"lectures/javascript-fundamentals/statements-vs-expressions/#statements-vs-expression","text":"","title":"Statements vs. Expression"},{"location":"lectures/javascript-fundamentals/statements-vs-expressions/#statements","text":"Statements perform instructions step by step. let myStr; if (myBool) { myStr = \"Yes\"; } else { myStr = \"No\"; }","title":"Statements"},{"location":"lectures/javascript-fundamentals/statements-vs-expressions/#expressions","text":"Expressions always produce a value. let myStr = myBool ? \"Yes\" : \"No\";","title":"Expressions"},{"location":"lectures/javascript-fundamentals/statements-vs-expressions/#operators","text":"Most operators work with primitive values.","title":"Operators"},{"location":"lectures/javascript-fundamentals/statements-vs-expressions/#equality","text":"","title":"Equality"},{"location":"lectures/javascript-fundamentals/statements-vs-expressions/#loose-equality-avoid","text":"\"123\" == 123; // true false == 0; // true","title":"Loose Equality (avoid!)"},{"location":"lectures/javascript-fundamentals/statements-vs-expressions/#strict-equality","text":"false === 0; // false \"123\" === 123; // false","title":"Strict Equality"},{"location":"lectures/javascript-fundamentals/statements-vs-expressions/#ordering","text":"5 >= 2; // true \"bar\" < \"foo\"; //true","title":"Ordering"},{"location":"lectures/javascript-fundamentals/statements-vs-expressions/#nullish-coalescing","text":"Checks if the first value is 'nullish' and uses the second value if so a ?? b; // is the same as a !== undefined && a !== null ? a : b;","title":"Nullish Coalescing"},{"location":"lectures/javascript-fundamentals/statements-vs-expressions/#or-operator","text":"Checks if the first value is 'falsy' and uses the second value if so undefined || \"default\"; // \"default\" null || \"default\"; // \"default\" false || \"default\"; // \"default\" 0 || \"default\"; // \"default\" 0n || \"default\"; // \"default\" \"\" || \"default\"; // \"default\" true || \"default\"; // true \"some text\" || \"default\"; // \"some text\"","title":"OR Operator"},{"location":"lectures/javascript-fundamentals/statements-vs-expressions/#and-operator","text":"Checks if the first value is 'truthy' and uses the second value if so [1, 2, 3] && 'default' // 'default' {a: 2} && 'default' // 'default' true && 'default' // 'default' 123 && 'default' // 'default' 4n && 'default' // 'default' 'asdf' && 'default' // 'default' false && 'default' // false","title":"AND Operator"},{"location":"lectures/javascript-fundamentals/statements-vs-expressions/#what-is-allowed-where","text":"The body of a function must be a sequence of statements: function max(x, y) { if (x > y) { return x; } else { return y; } } The arguments of a function call or a method call must be expressions: console.log(\"ab\" + \"cd\", Number(\"123\"));","title":"What is allowed where?"},{"location":"lectures/javascript-fundamentals/tc39/","text":"TC39 (Technical Committee 39) TC39 is the committee that evolves JavaScript. Its members are, strictly speaking, compa- nies: Adobe, Apple, Facebook, Google, Microsoft, Mozilla, Opera, Twitter, and others. That is, companies that are usually fierce competitors are working together for the good of the language. Every two months, TC39 has meetings that member-appointed delegates and invited experts attend. The minutes of those meetings are public in a GitHub repository. TC39 Process TC39 Release Process","title":"TC39 (Technical Committee 39)"},{"location":"lectures/javascript-fundamentals/tc39/#tc39-technical-committee-39","text":"TC39 is the committee that evolves JavaScript. Its members are, strictly speaking, compa- nies: Adobe, Apple, Facebook, Google, Microsoft, Mozilla, Opera, Twitter, and others. That is, companies that are usually fierce competitors are working together for the good of the language. Every two months, TC39 has meetings that member-appointed delegates and invited experts attend. The minutes of those meetings are public in a GitHub repository.","title":"TC39 (Technical Committee 39)"},{"location":"lectures/javascript-fundamentals/tc39/#tc39-process","text":"TC39 Release Process","title":"TC39 Process"},{"location":"lectures/javascript-fundamentals/values/","text":"Values Separaton of values in JavaScript undefined with the only element undefined null with the only element null boolean with the elements false and true number the type of all numbers (e.g., -123, 3.141) bigint the type of all big integers (e.g., -123n) string the type of all strings (e.g., 'abc') symbol the type of all symbols (e.g., Symbol('My Symbol')) object the type of all objects (different from Object, the type of all instances of class Object and its subclasses) Primitive Values vs. Objects Primitive values They are atomic building blocks of data in JavaScript. They are passed by value: when primitive values are assigned to variables or passed to functions, their contents are copied. They are compared by value: when comparing two primitive values, their contents are compared. Objects They are compound pieces of data They are passed by identity: when objects are assigned to variables or passed to functions, their identities (think pointers) are copied. They are compared by identity (my term): when comparing two objects, their identities are compared","title":"Values"},{"location":"lectures/javascript-fundamentals/values/#values","text":"Separaton of values in JavaScript undefined with the only element undefined null with the only element null boolean with the elements false and true number the type of all numbers (e.g., -123, 3.141) bigint the type of all big integers (e.g., -123n) string the type of all strings (e.g., 'abc') symbol the type of all symbols (e.g., Symbol('My Symbol')) object the type of all objects (different from Object, the type of all instances of class Object and its subclasses)","title":"Values"},{"location":"lectures/javascript-fundamentals/values/#primitive-values-vs-objects","text":"","title":"Primitive Values vs. Objects"},{"location":"lectures/javascript-fundamentals/values/#primitive-values","text":"They are atomic building blocks of data in JavaScript. They are passed by value: when primitive values are assigned to variables or passed to functions, their contents are copied. They are compared by value: when comparing two primitive values, their contents are compared.","title":"Primitive values"},{"location":"lectures/javascript-fundamentals/values/#objects","text":"They are compound pieces of data They are passed by identity: when objects are assigned to variables or passed to functions, their identities (think pointers) are copied. They are compared by identity (my term): when comparing two objects, their identities are compared","title":"Objects"},{"location":"lectures/javascript-fundamentals/variables/","text":"Variables Const > Let Use always const unless you have to reset the variable, then use let const a = 2; a = 3; Uncaught TypeError: Assignment to constant variable. let a = 4; a = 6; And what about var? var was the variable before const and let were introduced. The reason why const and let were introduced is that they are block scoped. var is only function scoped but this is not enough as following example should show: function processArray(array) { for (var i = 0; i < array.length; i++) { console.log(\"Element \", array[i]); } console.log(\"I can use variable i outside the loop \", i); }","title":"Variables"},{"location":"lectures/javascript-fundamentals/variables/#variables","text":"","title":"Variables"},{"location":"lectures/javascript-fundamentals/variables/#const-let","text":"Use always const unless you have to reset the variable, then use let const a = 2; a = 3; Uncaught TypeError: Assignment to constant variable. let a = 4; a = 6;","title":"Const &gt; Let"},{"location":"lectures/javascript-fundamentals/variables/#and-what-about-var","text":"var was the variable before const and let were introduced. The reason why const and let were introduced is that they are block scoped. var is only function scoped but this is not enough as following example should show: function processArray(array) { for (var i = 0; i < array.length; i++) { console.log(\"Element \", array[i]); } console.log(\"I can use variable i outside the loop \", i); }","title":"And what about var?"},{"location":"lectures/react/","text":"Introduction","title":"Introduction"},{"location":"lectures/react/#introduction","text":"","title":"Introduction"}]}