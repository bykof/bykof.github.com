{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome!","text":"<p>On this website you will find lectures about:</p> <ul> <li>Webengineering</li> <li>React Workshop</li> <li>Go Lectures<ul> <li>Go Fundamentals</li> <li>Dependency Injection in Go</li> <li>Build Go Docker images</li> <li>Architecture and Best Practices</li> <li>Design Patterns</li> </ul> </li> </ul> <p>Or just click in the left upper corner on Javascript</p>"},{"location":"#lightdark-mode","title":"Light/Dark Mode","text":"<p>Just switch between Light and Dark mode with the switch in the navigation at the top beside the search input field.</p> <p>Feel free to visit my website: https://bykovski.de</p>"},{"location":"exercises/","title":"Exercises","text":""},{"location":"exercises/browser-api/shop/","title":"Shop Exercise","text":"<p>Let's continue with our shopping example in exercise JavaScript Fundamentals - Shop.</p> <p>Now we build an interface for the shop.</p> <p>It will look like this: responsive, mobile-ready, fast as hell \ud83d\udd25!</p>"},{"location":"exercises/browser-api/shop/#quickstart-example","title":"Quickstart Example","text":"<p>Use this example to start: index.html</p> <p>Note: Your browser will try to render the index.html, so just download and start to edit it.</p> <p>After downloading the example, try to add a JavaScript file as resource. Lastly just double-click the index.html file to see it in the browser.</p>"},{"location":"exercises/go/projects/product_service/","title":"Product Service","text":"Domain Driven Hexagonal Architecture <p>You are the main dev of a big online shop. The old product service is written in an esoteric language, which cannot handle more than 10.000 requests per second. Now you want to try Go, so let's do this!</p> <p>Create a RESTful service with the http web-framework Gin.</p> <p>It has the following endpoints:</p> <pre><code>GET     /product - List all articles\nGET     /product/{id} - Get a specific article\nPOST    /product - Create a product\nPUT     /product/{id} - Update a product\nDELETE  /product/{id} - Delete a product\n</code></pre> <p>The product struct uses the package https://pkg.go.dev/github.com/shopspring/decimal for prices:</p> core/domain/product.go<pre><code>import (\n\"github.com/shopspring/decimal\"\n)\ntype Product struct {\nID       int64\nName     string\nCategory string\nPrice    decimal.Decimal\n}\n</code></pre> <p>The service should have two possible ways to store products and categories. It should store all data in memory or in json files called <code>products.json</code>. Use interfaces, domain driven hexagonal architecture and dependency injection to built the service properly.</p> <p>Example Requests:</p>"},{"location":"exercises/go/projects/product_service/#create-products","title":"Create products","text":"<p>Request:</p> POST /products<pre><code>{\n    \"name\": \"iPhone 14 Pro\",\n    \"price\": 99.99,\n    \"category\": \"smartphones\"\n}\n</code></pre> <p>Response:</p> POST /products: 200<pre><code>1\n</code></pre> <p>Request:</p> POST /products<pre><code>{\n    \"name\": \"iPhone 12 Pro\",\n    \"price\": 999.99,\n    \"category\": \"smartphones\"\n}\n</code></pre> <p>Response:</p> POST /products: 200<pre><code>2\n</code></pre> <p>Request:</p> POST /products<pre><code>{\n    \"price\": 999.99,\n    \"category\": \"smartphones\"\n}\n</code></pre> <p>Response:</p> POST /products: 400<pre><code>{\n    \"error\": \"Key: 'ProductBody.Name' Error:Field validation for 'Name' failed on the 'required' tag\"\n}\n</code></pre>"},{"location":"exercises/go/projects/product_service/#get-products","title":"Get products","text":"<p>Request:</p> GET /products <p>Response:</p> GET /products: 200<pre><code>[\n    {\n        \"id\": 1,\n        \"name\": \"iPhone 14 Pro\",\n        \"category\": \"smartphones\",\n        \"price\": \"99.99\"\n    },\n    {\n        \"id\": 2,\n        \"name\": \"iPhone 13 Pro\",\n        \"category\": \"smartphones\",\n        \"price\": \"999.99\"\n    }\n]\n</code></pre>"},{"location":"exercises/go/projects/product_service/#get-a-specific-product","title":"Get a specific product","text":"<p>Request:</p> GET /products/1 <p>Response:</p> GET /products/1: 200<pre><code>{\n    \"id\": 1,\n    \"name\": \"iPhone 14 Pro\",\n    \"category\": \"smartphones\",\n    \"price\": \"99.99\"\n}\n</code></pre> <p>Request:</p> GET /products/999<pre><code>\n</code></pre> <p>Response:</p> GET /products/999: 404<pre><code>{\n    \"error\": \"could not find product with id: 999\"\n}\n</code></pre>"},{"location":"exercises/go/projects/product_service/#update-a-product","title":"Update a product","text":"<p>Request:</p> PUT /products/1<pre><code>{\n    \"name\": \"iPhone 11 Pro\",\n    \"category\": \"smartphones\",\n    \"price\": \"999.99\"\n}\n</code></pre> <p>Response:</p> PUT /products/1: 200<pre><code>{\n    \"name\": \"iPhone 11 Pro\",\n    \"category\": \"smartphones\",\n    \"price\": \"999.99\"\n}\n</code></pre>"},{"location":"exercises/go/projects/product_service/#delete-a-product","title":"Delete a product","text":"<p>Request:</p> DELETE /products/1 <p>Response:</p> DELETE /products/1: 204"},{"location":"exercises/go/projects/school/","title":"School","text":"<p>A school needs a programm, to store pupils, teachers, lessons and classrooms. The program should have a menu to display it:</p> <pre><code>*** School Program ***\nChoose one of the following options:\n    1. Add a pupil\n    2. Add a teacher\n    3. Add a classroom\n    4. Add a lesson\n    5. Add pupils to lesson\n    6. List all pupils\n    7. List all teachers\n    8. List all classrooms\n    9. List all lessons\n    10. List lessons of classroom\n    (11. List lessons of pupil)\n    (12. List lessons of teacher)\n\nYour choice:\n</code></pre> <p>Program 11 and 12 are Bonus parts.</p> <p>If you choose menu 1, following should be printed:</p> <pre><code>Add a pupil:\n&gt; Enter first name: Michael\n&gt; Enter last name: Bykovsi\n&gt; Enter grade: 10\n&gt; Pupil #1 Michael Bykovski successfully added\n</code></pre> <pre><code>Add a pupil:\n&gt; Enter first name: Tanja\n&gt; Enter last name: Stark\n&gt; Enter grade: 10\n&gt; Pupil #2 Tanja Stark successfully added\n</code></pre> <p>If you choose menu 2:</p> <pre><code>Add a teacher:\n&gt; Enter first name: Peter\n&gt; Enter last name: Lustig\n&gt; Enter teaching area: Deutsch und Biologie\n&gt; Teacher #1 Peter Lustig successfully added\n</code></pre> <p>If you choose menu 3:</p> <pre><code>Add a classroom:\n&gt; Enter room number: 405\n&gt; Enter location: Hauptgeb\u00e4ude\n&gt; Classroom #1 405 Hauptgeb\u00e4ude successfully added\n</code></pre> <p>If you choose menu 4 the following input should be</p> <pre><code>Add a lesson:\n&gt; Enter lesson name: Deutsche Grammatik #2\n&gt; Enter semester: SS22\n&gt; Enter classroom id: 1\n&gt; Enter teacher id: 2\n&gt; Teacher with id 2 does not exist, please choose an existing teacher id!\n&gt; Enter teacher id: 1\n&gt; Lesson #1 Deutsche Grammatik #2 successfully added\n</code></pre> <p>If you choose menu 5:</p> <pre><code>Add pupils to lesson:\n&gt; Enter lesson id: 1\n&gt; Enter pupils separated by comma: 1,2\n&gt; Pupils:\n    - #1 Michel Bykovski\n    - #2 Tanja Stark\n  were added to the lesson #1 Deutsche Grammatik #2\n</code></pre> <p>If you choose menu 6:</p> <pre><code>List of pupils:\n#1 Michael Bykovski (10)\n#2 Tanja Stark (10)\n</code></pre> <p>If you choose menu 7:</p> <pre><code>List of teachers:\n#1 Peter Lustig\n- Teaching Area: Deutsch und Biologie\n</code></pre> <p>If you choose menu 8:</p> <pre><code>List of classrooms:\n#1 405 Hauptgeb\u00e4ude\n</code></pre> <p>If you choose menu 9:</p> <pre><code>List of lessons:\n#1 Deutsche Grammatik #2\n- Semester: SS22\n- Classroom: #1 405 Hauptgeb\u00e4ude\n- Teacher: #1 Peter Lustig\n</code></pre> <p>If you choose menu 10:</p> <pre><code>&gt; Which classroom you would like to see?\n&gt; 1\n\n#1 405 Hauptgeb\u00e4ude\n- #1 Deutsche Grammatik #2\n    - Teacher: #1 Peter Lustig\n    - Pupils:\n        - #1 Michael Bykovski\n        - #2 Tanja Stark\n</code></pre> <p>Bonus task:</p> <p>If you choose menu 11:</p> <pre><code>&gt; Which pupil you would like to see?\n&gt; 2\n\n#2 Tanja Stark\n- #1 Deutsche Grammatik #2\n    - Teacher: #1 Peter Lustig\n    - Classroom: #1 405 Hauptgeb\u00e4ude\n</code></pre> <p>If you choose menu 12:</p> <pre><code>&gt; Which teacher you would like to see?\n&gt; 1\n\n#1 Peter Lustig\n- #1 Deutsche Grammatik #2\n    - Classroom: #1 405 Hauptgeb\u00e4ude\n</code></pre> <p>Start with this:</p> main.go<pre><code>package main\nimport (\n\"bufio\"\n\"fmt\"\n\"os\"\n)\nfunc main() {\nfor {\nreader := bufio.NewReader(os.Stdin)\nfmt.Printf(\"Your choice: \")\ncommand, _ := reader.ReadString('\\n')\nfmt.Println(command)\n}\n}\n</code></pre>"},{"location":"exercises/go/starter/","title":"Starter","text":"<p>For some starter tasks just clone yourself the repository: </p> <p>https://github.com/bykof/golang-workshop-tasks</p> <p>If you want to see the solutions, just switch the branch to: <code>solutions</code>.</p>"},{"location":"exercises/javascript-fundamentals/","title":"Introduction","text":"<p>Here you will find some exercises for JavaScript Fundamentals.</p>"},{"location":"exercises/javascript-fundamentals/#starting-with-the-exercises","title":"Starting with the exercises","text":"<p>To start with the exercises I can recommend you following steps:</p> <ol> <li>install Node.JS Link</li> <li>create a folder: <code>mkdir -p js-exercises/javascript-fundamentals/shop</code></li> <li>go to the folder: <code>cd js-exercises/javascript-fundamentals/shop</code></li> <li>init a node package: <code>npm init -y</code></li> <li>add a new script in the <code>package.json</code> see at the bottom:</li> <li>add an <code>index.js</code>: <code>touch index.js</code></li> <li>write your code and start the <code>index.js</code> with <code>npm run start</code></li> </ol>"},{"location":"exercises/javascript-fundamentals/#packagejson","title":"package.json","text":"<pre><code>{\n\"name\": \"shop\",\n\"version\": \"1.0.0\",\n\"main\": \"index.js\",\n\"license\": \"MIT\",\n\"devDependencies\": {\n\"jest\": \"^26.5.3\"\n},\n\"scripts\": {\n\"start\": \"node index.js\"\n}\n}\n</code></pre>"},{"location":"exercises/javascript-fundamentals/shop/","title":"Shopping Exercise","text":"<p>Online Shopping has a really heavy impact on all industries around the world.</p> <p>Therefore we try it ourselves and implement a small Node.JS shop, but in offline mode.</p> <p>Let's start!</p>"},{"location":"exercises/javascript-fundamentals/shop/#add-customer","title":"Add customer","text":"<p>Add a customer and ask for firstname, lastname, street, city, phone, email and then print out an incrementing customer number.</p>"},{"location":"exercises/javascript-fundamentals/shop/#example","title":"Example","text":"<pre><code>*** Menu ***\n1: Add Customer\n2: Add Product\n3: New Order\n4: Print Customers\n5: Print Products\n6: Print Orders\nx: Exit\n&gt; 1\nFirstname: Michael\nLastname: Tester\nStreet: Shoppingstreet 12\nPostal Code: 123456\nCity: Shop\nPhone: 0174 123 123\nEmail: tester@test.com\nCustomer #1 was added!\n*** Menu ***\n1: Add Customer\n2: Add Product\n3: New Order\n4: Print Customers\n5: Print Products\n6: Print Orders\nx: Exit\n&gt;\n</code></pre>"},{"location":"exercises/javascript-fundamentals/shop/#add-product","title":"Add Product","text":"<p>Add a product with a product number, name, and a product price in cent amount. If you use a product number, which was already used, just overwrite it.</p>"},{"location":"exercises/javascript-fundamentals/shop/#example_1","title":"Example","text":"<pre><code>*** Menu ***\n1: Add Customer\n2: Add Product\n3: New Order\n4: Print Customers\n5: Print Products\n6: Print Orders\nx: Exit\n&gt; 2\nNumber: s1\nName: Nintendo Switch\nPrice (in cents): 19999\nProduct #s1 was added!\n</code></pre>"},{"location":"exercises/javascript-fundamentals/shop/#errors","title":"Errors","text":"<p>If the Price in cents is not an integer, let the customer enter an integer until it's correct:</p> <pre><code>Number: 1\nName: Switch\nPrice (in cents): asdf\nPlease reenter a correct price as cents.\nPrice (in cents):\n</code></pre>"},{"location":"exercises/javascript-fundamentals/shop/#add-new-order","title":"Add New Order","text":"<p>Create a new order and store the draft order in the current application until the user is able to save it with menu item <code>8</code>.</p>"},{"location":"exercises/javascript-fundamentals/shop/#example_2","title":"Example","text":"<pre><code>*** Menu ***\n1: Add Customer\n2: Add Product\n3: New Order\n4: Print Customers\n5: Print Products\n6: Print Orders\nx: Exit\n&gt; 3\nPlease enter the customer number: 1\n1\nOrder #1 was created\n*** Menu ***\n1: Add Customer\n2: Add Product\n3: New Order\n4: Print Customers\n5: Print Products\n6: Print Orders\n7: Add OrderItem\n8: Save order\nx: Exit\n</code></pre>"},{"location":"exercises/javascript-fundamentals/shop/#errors_1","title":"Errors","text":"<p>If the customer could not be found, let the user reenter the customer number until the correct customer number is entered:</p> <pre><code>Please enter the customer number: f\nCustomer could not be found.\nPlease enter the customer number:\n</code></pre>"},{"location":"exercises/javascript-fundamentals/shop/#add-orderitem","title":"Add OrderItem","text":"<p>Add an product with a specific amount to the current draft order.</p>"},{"location":"exercises/javascript-fundamentals/shop/#example_3","title":"Example","text":"<pre><code>*** Menu ***\n1: Add Customer\n2: Add Product\n3: New Order\n4: Print Customers\n5: Print Products\n6: Print Orders\n7: Add OrderItem\n8: Save order\nx: Exit\n&gt; 7\nPlease enter the product number: 1\nPlease enter the amount: 3\n</code></pre>"},{"location":"exercises/javascript-fundamentals/shop/#errors_2","title":"Errors","text":"<p>If the product number does not exist, let the user reenter until the product can be found:</p> <pre><code>Please enter the product number: 3\nProduct could not be found.\nPlease enter the product number:\n</code></pre> <p>If the amount is not an integer, let the user reenter until it's an integer:</p> <pre><code>Please enter the amount: asd\nPlease enter a number as amount.\nPlease enter the amount:\n</code></pre>"},{"location":"exercises/javascript-fundamentals/shop/#save-order","title":"Save order","text":"<p>Saving the order just removes the possibility to add OrderItems to the current draft order.</p>"},{"location":"exercises/javascript-fundamentals/shop/#example_4","title":"Example","text":"<pre><code>*** Menu ***\n1: Add Customer\n2: Add Product\n3: New Order\n4: Print Customers\n5: Print Products\n6: Print Orders\n7: Add OrderItem\n8: Save order\nx: Exit\n&gt; 8\nOrder was saved!\n*** Menu ***\n1: Add Customer\n2: Add Product\n3: New Order\n4: Print Customers\n5: Print Products\n6: Print Orders\nx: Exit\n</code></pre>"},{"location":"exercises/javascript-fundamentals/shop/#print-customers","title":"Print Customers","text":"<p>Just print out all customers.</p> <p>Hint:</p> <p>Use <code>console.table</code></p>"},{"location":"exercises/javascript-fundamentals/shop/#example_5","title":"Example","text":"<pre><code>*** Menu ***\n1: Add Customer\n2: Add Product\n3: New Order\n4: Print Customers\n5: Print Products\n6: Print Orders\nx: Exit\n&gt; 4\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 (index) \u2502 number \u2502 firstName \u2502 lastName \u2502     street      \u2502   city   \u2502 postalCode \u2502      email      \u2502    phone     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    0    \u2502  '1'   \u2502  'Test'   \u2502 'Tester' \u2502 'Teststreet 12' \u2502 '123456' \u2502 'Testcity' \u2502 'test@test.com' \u2502 '0123456789' \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"exercises/javascript-fundamentals/shop/#print-products","title":"Print products","text":"<p>Print all products.</p>"},{"location":"exercises/javascript-fundamentals/shop/#example_6","title":"Example","text":"<pre><code>&gt; 5\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 (index) \u2502 number \u2502      name       \u2502          price          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    0    \u2502  's1'  \u2502    'Switch'     \u2502 Price { amount: 19999 } \u2502\n\u2502    1    \u2502  'p1'  \u2502 'Playstation 4' \u2502 Price { amount: 39999 } \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"exercises/javascript-fundamentals/shop/#print-orders","title":"Print orders","text":"<p>Print all orders</p> <p>Hint:</p> <p>Don't use <code>console.table</code> here!</p>"},{"location":"exercises/javascript-fundamentals/shop/#example_7","title":"Example","text":"<pre><code>&gt; 6\n&gt; 6\n--------------------------------------------------\nOrder #1 for 1 - Test Tester\n-------------------------\n1x #s1 Switch - 199.99\n-------------------------\n3x #p1 Playstation 4 - 399.99\nSum: 1399.96\n--------------------------------------------------\n--------------------------------------------------\nOrder #2 for 2 - Another Testy\n-------------------------\n2x #s1 Switch - 199.99\n-------------------------\n1x #p1 Playstation 4 - 399.99\nSum: 799.97\n--------------------------------------------------\n</code></pre>"},{"location":"exercises/react/components/","title":"Components / JSX","text":"<p>First create a React Project with <code>create-react-app</code>.</p> <p>Take this user information:</p> <pre><code>const users = [\n{\n\"firstName\": \"John\",\n\"lastName\": \"Smith\",\n\"email\": \"john@example.com\",\n\"profilePicture\": \"https://images.pexels.com/photos/6206980/pexels-photo-6206980.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=1260&amp;h=750&amp;dpr=1\",\n\"phone\": \"+1 (123) 456-7890\",\n\"address\": {\n\"street\": \"9062 Mertz Plains Apt. 623\",\n\"buildingNumber\": \"410\",\n\"city\": \"Boganside\",\n\"zipcode\": \"71562\",\n\"country\": \"Estonia\"\n},\n\"website\": \"http://www.johnsmith.com\"\n},\n{\n\"firstName\": \"Raegan\",\n\"lastName\": \"Haley\",\n\"email\": \"ustroman@hotmail.com\",\n\"profilePicture\": \"https://images.pexels.com/photos/733872/pexels-photo-733872.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=1260&amp;h=750&amp;dpr=1\",\n\"phone\": \"+5089956276536\",\n\"address\": {\n\"street\": \"2922 Retha Plaza\",\n\"city\": \"Lake Gail\",\n\"zipcode\": \"26859-4338\",\n\"country\": \"Mozambique\"\n},\n\"website\": \"http://zboncak.biz\"\n}\n]\n</code></pre> <p>And create the following website with React.js by using React components:</p> <p></p>"},{"location":"exercises/react/context/","title":"Context","text":"<p>Take this example and build a CounterContext and a CounterContextProvider to use a context.</p> <p>The context should have two functions <code>countUp</code> and <code>countDown</code> and a value called <code>counter</code>. <code>countUp</code> should add 1 to the current <code>counter</code> and <code>countDown</code> should subtract 1 from it.</p> <p>Example</p> <pre><code>import React from 'react';\nfunction CounterDisplay() {\nreturn &lt;p&gt;{counter}&lt;/p&gt;\n}\nfunction Counter() {\nreturn (\n&lt;&gt;\n&lt;button onClick={countUp}&gt;+&lt;/button&gt;\n&lt;button onClick={countDown}&gt;-&lt;/button&gt;\n&lt;/&gt;\n)\n}\nfunction App() {\nreturn (\n&lt;&gt;\n&lt;CounterDisplay&gt;\n&lt;Counter&gt;\n&lt;/&gt;\n)\n}\n</code></pre>"},{"location":"exercises/react/forms/","title":"Forms","text":"<p>Rebuild the application and use Events and States. Use <code>onSubmit</code> with the form element to catch submit events by submitting with enter or a submit button. Don't forget to prevent the default behaviour with: <code>event.preventDefault()</code></p>"},{"location":"exercises/react/hooks/","title":"Hooks","text":""},{"location":"exercises/react/hooks/#usestate","title":"useState","text":"<p>Take your solution from the <code>Components / JSX</code> section and add following behaviour:</p>"},{"location":"exercises/react/hooks/#solution","title":"Solution","text":"<pre><code>import React from 'react'\nfunction Address(props) {\nreturn (\n&lt;&gt;\n&lt;p&gt;{props.address.street}&lt;/p&gt;\n&lt;p&gt;\n{props.address.city} {props.address.zipcode}\n&lt;/p&gt;\n&lt;p&gt;{props.address.country}&lt;/p&gt;\n&lt;/&gt;\n)\n}\nfunction Person(props) {\nconst [showAddress, setShowAddress] = React.useState(false)\nreturn (\n&lt;div&gt;\n&lt;img width=\"250\" alt=\"\" src={props.person.profilePicture} /&gt;\n&lt;h1&gt;\n{props.person.firstName} {props.person.lastName}\n&lt;/h1&gt;\n&lt;p&gt;Phone: {props.person.phone}&lt;/p&gt;\n&lt;p&gt;\nEmail: &lt;a href={props.person.email}&gt;{props.person.email}&lt;/a&gt;\n&lt;/p&gt;\n&lt;a href={props.person.website}&gt;{props.person.website}&lt;/a&gt;\n&lt;br /&gt;\n&lt;br /&gt;\n&lt;button onClick={() =&gt; setShowAddress(!showAddress)}&gt;\n{showAddress ? 'Hide' : 'Show'} Address\n&lt;/button&gt;\n{showAddress ? &lt;Address address={props.person.address} /&gt; : null}\n&lt;/div&gt;\n)\n}\nfunction App() {\nconst users = [\n{\nfirstName: 'John',\nlastName: 'Smith',\nemail: 'john@example.com',\nprofilePicture:\n'https://images.pexels.com/photos/6206980/pexels-photo-6206980.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=1260&amp;h=750&amp;dpr=1',\nphone: '+1 (123) 456-7890',\naddress: {\nstreet: '9062 Mertz Plains Apt. 623',\nbuildingNumber: '410',\ncity: 'Boganside',\nzipcode: '71562',\ncountry: 'Estonia',\n},\nwebsite: 'http://www.johnsmith.com',\n},\n{\nfirstName: 'Raegan',\nlastName: 'Haley',\nemail: 'ustroman@hotmail.com',\nprofilePicture:\n'https://images.pexels.com/photos/733872/pexels-photo-733872.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=1260&amp;h=750&amp;dpr=1',\nphone: '+5089956276536',\naddress: {\nstreet: '2922 Retha Plaza',\ncity: 'Lake Gail',\nzipcode: '26859-4338',\ncountry: 'Mozambique',\n},\nwebsite: 'http://zboncak.biz',\n},\n]\nreturn (\n&lt;&gt;\n&lt;Person person={users[0]} /&gt;\n&lt;br /&gt;\n&lt;Person person={users[1]} /&gt;\n&lt;/&gt;\n)\n}\nexport default App\n</code></pre>"},{"location":"exercises/react/hooks/#usememo","title":"useMemo","text":"<p>The calculate function runs on every click of the button and slows the application. Can you improve the code by using useMemo?</p> <p>Example</p> <pre><code>function Component() {\nconst [state, setState] = React.useState(0);\nconst calculate = () =&gt; {\nlet a = 0;\nfor (let i = 0; i &lt; 10_000; i++) {\nfor (let j = 0; j &lt; 10_000; j++) {\na += i + j;\n}\n}\nreturn a;\n};\nreturn (\n&lt;div&gt;\n&lt;button onClick={() =&gt; setState(state + 1)}&gt;Add +1&lt;/button&gt;\n&lt;pre&gt;{state}&lt;/pre&gt;\n{calculate()}\n&lt;/div&gt;\n);\n}\nexport default function App() {\nreturn &lt;Component /&gt;;\n}\n</code></pre>"},{"location":"exercises/react/hooks/#usecallback","title":"useCallback","text":"<p>Woops, what is happening here? If we click the first CustomButton component, the second CustomButton component gets rerendered. Let's fix this by using <code>useCallback</code>.</p> <p>Example</p> <pre><code>import React from \"react\";\nfunction CustomButton({ onClick, children }) {\nReact.useEffect(() =&gt; {\nconsole.log(`button ${children} is rerendered!`);\n}, [onClick]);\nreturn &lt;button onClick={onClick}&gt;{children}&lt;/button&gt;;\n}\nfunction Wrapper() {\nconst [isCheckedFirst, setIsCheckedFirst] = React.useState(false);\nconst [isCheckedSecond, setIsCheckedSecond] = React.useState(false);\nreturn (\n&lt;&gt;\n&lt;CustomButton onClick={() =&gt; setIsCheckedFirst(!isCheckedFirst)}&gt;\nFirst isChecked\n&lt;/CustomButton&gt;\n&lt;p&gt;{isCheckedFirst ? \"First is checked\" : \"First is not checked\"}&lt;/p&gt;\n&lt;CustomButton onClick={() =&gt; setIsCheckedSecond(!isCheckedSecond)}&gt;\nSecond isChecked\n&lt;/CustomButton&gt;\n&lt;p&gt;{isCheckedSecond ? \"Second is checked\" : \"Second is not checked\"}&lt;/p&gt;\n&lt;/&gt;\n);\n}\n</code></pre>"},{"location":"exercises/react/mantine/","title":"Mantine","text":"<p>Build a website with your skills in Mantine.</p> <p>It should have at least one interactive element, like a filter or something to click on it.</p>"},{"location":"exercises/react/props/","title":"Props","text":"<p>Refactor the exercise Components/JSX and use props for your components.</p> <p>For example, pass in the <code>user</code> into a <code>User</code> component.</p> <p>Example</p> <pre><code>function User(props) {\nconst user = props.user\nreturn &lt;&gt;...&lt;/&gt;\n}\n</code></pre>"},{"location":"exercises/react/requests/","title":"Requests","text":"<p>Build the interface in the iframe down below.</p> <p>Don't forget to create proper components!</p> <p>Use this API endpoints:</p> <pre><code>Get all albums:\nGET https://jsonplaceholder.typicode.com/albums\n\nGet photos of an album:\nGET https://jsonplaceholder.typicode.com/albums/${id}/photos\n</code></pre> <p>The idea is to get all albums and display them. After clicking on an album the application should show all photos of this album.</p>"},{"location":"exercises/react/requests/#solution","title":"Solution","text":"<pre><code>function Album({ album, onAlbumSelected }) {\nreturn (\n&lt;div\nonClick={() =&gt; onAlbumSelected(album)}\nstyle={{\nborder: '1px solid black',\ndisplay: 'inline-block',\npadding: '0.5em',\nmargin: '0.25em',\ncursor: 'pointer',\n}}\n&gt;\n{album.title}\n&lt;/div&gt;\n)\n}\nfunction App() {\nconst [selectedAlbum, setSelectedAlbum] = React.useState(null)\nconst albumsQuery = useQuery(['albums'], async () =&gt; {\nconst response = await fetch(\n'https://jsonplaceholder.typicode.com/albums',\n)\nreturn await response.json()\n})\nconst photosQuery = useQuery(\n['photos', selectedAlbum],\nasync () =&gt; {\nconst response = await fetch(\n'https://jsonplaceholder.typicode.com/albums/' +\nselectedAlbum.id +\n'/photos',\n)\nreturn await response.json()\n},\n{ enabled: selectedAlbum !== null },\n)\nconst onAlbumSelected = React.useCallback((album) =&gt; {\nsetSelectedAlbum(album)\n}, [])\nreturn (\n&lt;&gt;\n{photosQuery.data &amp;&amp;\nphotosQuery.data.map((photo) =&gt; (\n&lt;img alt={''} key={photo.id} src={photo.thumbnailUrl} /&gt;\n))}\n{albumsQuery.data &amp;&amp;\nalbumsQuery.data.map((album) =&gt; (\n&lt;Album\nonAlbumSelected={onAlbumSelected}\nkey={album.id}\nalbum={album}\n/&gt;\n))}\n&lt;/&gt;\n)\n}\n</code></pre>"},{"location":"exercises/react/routing/","title":"Routing","text":"<p>Create a routing with react-router like in the example below.</p> <p>Use a <code>BrowserRouter</code> and <code>NavLink</code> for navigation.</p> <p>Use again the following requests to display albums and photos of albums:</p> <pre><code>Get all albums:\nGET https://jsonplaceholder.typicode.com/albums\n\nGet photos of an album:\nGET https://jsonplaceholder.typicode.com/albums/${id}/photos\n</code></pre>"},{"location":"golang/","title":"Introduction","text":"<p>Welcome to my Golang lectures.</p> <p>On the left side you will find several topics of this lecture.</p>"},{"location":"golang/architecture/","title":"Architecture and Best Practices in Go","text":"<p>For best practices written by the Go team check out <code>Effective Go</code></p> <p>Currently the best architecture for Go applications, in my opinion, is the domain driven hexagonal architecture: Link.</p> <p>It's so suitable because Go provides loosely coupled interface implementation to use dependency injection and packaging makes it clear, which struct belongs to which \"layer\".</p>"},{"location":"golang/architecture/#two-known-architecture-principles","title":"Two Known Architecture Principles","text":"<p>There are two known architecture principles in Go. The \"flat\" architecture and the \"domain driven\" architecture.</p> <p>Let's take a look at two examples:</p> <ol> <li>Cobra</li> <li>Go Cache</li> </ol> <p>Cobra uses the flat architecture. Go Cache uses the domain driven approach, at least it utilizes packages.</p> <p>Mostly the flat architecture is used, when the Go programm is small and does just one thing. If the Go program becomes more complicated and does several things, I would suggest to use the domain driven hexagonal approach.</p>"},{"location":"golang/architecture/#getter","title":"Getter","text":"<p>In Go it's unusual to use <code>Get</code> before a getter. You often just remove the <code>Get</code> in a getter method so that you access it with <code>.Thing()</code>.</p> <pre><code>owner := obj.Owner()\nif owner != user {\nobj.SetOwner(user)\n}\n</code></pre>"},{"location":"golang/architecture/#interface-names","title":"Interface Names","text":"<p>Interface names are often defined with <code>er</code> as suffix. Like <code>Reader</code>, <code>Writer</code>, <code>Closer</code> and so on...</p>"},{"location":"golang/architecture/#camelcase-or-snake_case","title":"CamelCase or snake_case?","text":"<p>In Go you normally write <code>CamelCase</code> or how they call it <code>MixedCaps</code> and not <code>snake_case</code> like in Python for example.</p>"},{"location":"golang/dependency_injection/","title":"Dependency Injection in Go","text":"<p>Dependency Injection in Go is a really important topic, because the programming language has a perfect basis to do dependency injection. Interfaces and Structs can decouple your application perfectly.</p> <p>Let's say we have a service which just redirects a call from a client to another service.</p> <p>First we define our core logic and values:</p> core/value_objects/ttl_say_body.go<pre><code>package valueobjects\ntype TTSVoiceType string\nconst (\nTTSMaleVoice  TTSVoiceType = \"male\"\nTTSFemaleVoid TTSVoiceType = \"female\"\n)\ntype TTSSayBody struct {\nMessage      string       `json:\"message\"`\nTTSVoiceType TTSVoiceType `json:\"ttsVoiceType\"`\n}\n</code></pre> core/value_objects/ttl_say_response.go<pre><code>package valueobjects\ntype TTSSayResponse struct {\nMessage string\nStatus  int\n}\n</code></pre> core/ports/ttl_service_port.go<pre><code>package ports\nimport valueobjects \"dependency_injection/core/value_objects\"\ntype TTSServicePort interface {\nSay(ttsRequestBody valueobjects.TTSSayBody) (valueobjects.TTSSayResponse, error)\n}\n</code></pre> <p>Then we implement the ports:</p> infrastructure/services/real_ttl_service.go<pre><code>package services\nimport (\n\"bytes\"\n\"dependency_injection/core/ports\"\nvalueobjects \"dependency_injection/core/value_objects\"\n\"encoding/json\"\n\"fmt\"\n\"io/ioutil\"\n\"net/http\"\n)\ntype RealTTSService struct {\nurl string\n}\nvar _ ports.TTSServicePort = RealTTSService{}\nfunc (r RealTTSService) formatEndpoint(endpoint string) string {\nreturn fmt.Sprintf(\"%s/%s\", r.url, endpoint)\n}\nfunc (r RealTTSService) Say(ttsRequestBody valueobjects.TTSSayBody) (valueobjects.TTSSayResponse, error) {\nvar ttsSayResponse valueobjects.TTSSayResponse\npostBody, _ := json.Marshal(ttsRequestBody)\nresp, err := http.Post(r.formatEndpoint(\"say\"), \"application/json\", bytes.NewBuffer(postBody))\ndefer resp.Body.Close()\nif err != nil {\nreturn valueobjects.TTSSayResponse{}, err\n}\nresponseBody, err := ioutil.ReadAll(resp.Body)\nif err != nil {\nreturn valueobjects.TTSSayResponse{}, err\n}\nerr = json.Unmarshal(responseBody, &amp;ttsSayResponse)\nif err != nil {\nreturn valueobjects.TTSSayResponse{}, err\n}\nreturn ttsSayResponse, nil\n}\nfunc NewRealTTSService() *RealTTSService {\nfmt.Println(\"Init RealTTSService\")\nreturn &amp;RealTTSService{}\n}\n</code></pre> infrastructure/services/fake_ttl_service.go<pre><code>package services\nimport (\n\"dependency_injection/core/ports\"\nvalueobjects \"dependency_injection/core/value_objects\"\n\"errors\"\n\"fmt\"\n)\ntype FakeTTSService struct {\n}\nvar _ ports.TTSServicePort = RealTTSService{}\nfunc (f FakeTTSService) Say(ttsRequestBody valueobjects.TTSSayBody) (valueobjects.TTSSayResponse, error) {\nif ttsRequestBody.Message == \"_Error!\" {\nreturn valueobjects.TTSSayResponse{}, errors.New(\"custom error\")\n}\nreturn valueobjects.TTSSayResponse{\nMessage: fmt.Sprintf(\"Said: \\\"%s\\\" with voice %s\", ttsRequestBody.Message, ttsRequestBody.TTSVoiceType),\nStatus:  200,\n}, nil\n}\nfunc NewFakeTTSService() *FakeTTSService {\nfmt.Println(\"Init FakeTTSService\")\nreturn &amp;FakeTTSService{}\n}\n</code></pre> <p>Now we can implement the interfaces for the application. Here we inject the <code>TTSServicePort</code> into the MainController. We execute a specific application functionality and receive a defined struct <code>TTSSayResponse</code></p> interface/controllers/main_controller.go<pre><code>package controllers\nimport (\n\"dependency_injection/core/ports\"\nvalueobjects \"dependency_injection/core/value_objects\"\n\"encoding/json\"\n\"io/ioutil\"\n\"net/http\"\n)\ntype MainController struct {\nttsService ports.TTSServicePort\n}\nfunc NewMainController(ttsService ports.TTSServicePort) *MainController {\nreturn &amp;MainController{\nttsService: ttsService,\n}\n}\nfunc (mc *MainController) Say(w http.ResponseWriter, r *http.Request) {\nvar ttsSayBody valueobjects.TTSSayBody\nbody, err := ioutil.ReadAll(r.Body)\ndefer r.Body.Close()\nif err != nil {\n_, _ = w.Write([]byte(err.Error()))\nreturn\n}\nerr = json.Unmarshal(body, &amp;ttsSayBody)\nif err != nil {\n_, _ = w.Write([]byte(err.Error()))\nreturn\n}\nttsSayResponse, err := mc.ttsService.Say(ttsSayBody)\nif err != nil {\n_, _ = w.Write([]byte(err.Error()))\nreturn\n}\njsonResponse, err := json.Marshal(ttsSayResponse)\nif err != nil {\n_, _ = w.Write([]byte(err.Error()))\nreturn\n}\n_, _ = w.Write(jsonResponse)\nreturn\n}\n</code></pre> <p>Now we wrap everything up in our <code>main.go</code> file and inject the dependencies now. Here we inject a specific <code>TTSServicePort</code> depending on the environment variable:</p> main.go<pre><code>package main\nimport (\n\"dependency_injection/core/ports\"\n\"dependency_injection/infrastructure/services\"\n\"dependency_injection/interface/controllers\"\n\"log\"\n\"net/http\"\n\"os\"\n)\nfunc main() {\nvar ttsService ports.TTSServicePort\nif os.Getenv(\"ENV\") == \"prod\" {\nttsService = services.NewRealTTSService()\n} else {\nttsService = services.NewFakeTTSService()\n}\nmainController := controllers.NewMainController(ttsService)\nhttp.HandleFunc(\"/say\", mainController.Say)\nlog.Println(\"Running server on http://localhost:8081\")\nlog.Fatal(http.ListenAndServe(\":8081\", nil))\n}\n</code></pre> <p>We have the following structure now:</p> <pre><code>|-- core\n|   |-- ports\n|   |   `-- ttl_service_port.go\n|   `-- value_objects\n|       |-- tts_say_body.go\n|       `-- tts_say_response.go\n|-- go.mod\n|-- infrastructure\n|   `-- services\n|       |-- fake_tts_service.go\n|       `-- real_tts_service.go\n|-- interface\n|   `-- controllers\n|       `-- main_controller.go\n`-- main.go\n</code></pre> <p>There are teams who use this kind of dependency injection. But if it becomes more complex, its easier to use a tooling like wire. Let's check in the next chapter, how to do this.</p>"},{"location":"golang/dependency_injection/wire/","title":"Wire","text":"<p>Google's own compile time dependency injection framework is called: Wire. Wire works a little bit different from guice for example. Wire generates code from a file called <code>wire.go</code> to a file called <code>wire_gen.go</code>, which can be used in the <code>main.go</code> file to initialize and start the application.</p> <p>Install wire first: </p> <pre><code>go install github.com/google/wire/cmd/wire@latest\n</code></pre> <p>Let's take our example from the chapter before. We first just create a file called <code>wire.go</code>:</p> wire.go<pre><code>//go:build wireinject\n// +build wireinject\npackage main\nimport (\n\"dependency_injection/core/ports\"\n\"dependency_injection/infrastructure/services\"\n\"dependency_injection/interface/controllers\"\n\"github.com/google/wire\"\n\"os\"\n)\nfunc NewTTSService() ports.TTSServicePort {\nif os.Getenv(\"ENV\") == \"prod\" {\nreturn services.NewRealTTSService()\n} else {\nreturn services.NewFakeTTSService()\n}\n}\nfunc InitializeMainController() *controllers.MainController {\nwire.Build(NewTTSService, controllers.NewMainController)\nreturn &amp;controllers.MainController{}\n}\n</code></pre> <p>After that we can run wire to generate a <code>wire_gen.go</code> file:</p> Run in project root<pre><code>wire\n</code></pre> wire_gen.go<pre><code>// Code generated by Wire. DO NOT EDIT.\n//go:generate go run github.com/google/wire/cmd/wire\n//go:build !wireinject\n// +build !wireinject\npackage main\nimport (\n\"dependency_injection/core/ports\"\n\"dependency_injection/infrastructure/services\"\n\"dependency_injection/interface/controllers\"\n\"os\"\n)\n// Injectors from wire.go:\nfunc InitializeMainController() *controllers.MainController {\nttsServicePort := NewTTSService()\nmainController := controllers.NewMainController(ttsServicePort)\nreturn mainController\n}\n// wire.go:\nfunc NewTTSService() ports.TTSServicePort {\nif os.Getenv(\"ENV\") == \"prod\" {\nreturn services.NewRealTTSService()\n} else {\nreturn services.NewFakeTTSService()\n}\n}\n</code></pre> <p>And now we can adapt the <code>main.go</code> file:</p> main.go<pre><code>func main() {\nmainController := InitializeMainController()\nhttp.HandleFunc(\"/say\", mainController.Say)\nlog.Println(\"Running server on http://localhost:8081\")\nlog.Fatal(http.ListenAndServe(\":8081\", nil))\n}\n</code></pre> <p>Since we have now two files for the main package, we need to adapt our start line. This is important because otherwise it won't compile properly:</p> <pre><code>go run main.go wire_gen.go\n</code></pre>"},{"location":"golang/design_patterns/","title":"Design Patterns in Go","text":"<p>In this chapter we will look at some design patterns in Go. All code example are taken from here: https://refactoring.guru/design-patterns/go</p>"},{"location":"golang/design_patterns/#singleton","title":"Singleton","text":"<p>Just hold a package variable, which is a pointer to your preferred struct. Then expose a function <code>SingleInstance</code> to retrieve the singleton. Note to use sync.Mutex to lock the creation for the singleInstance, otherwise you could create multiple instances within several goroutines.</p> single.go<pre><code>import (\n\"fmt\"\n\"sync\"\n)\nvar lock = &amp;sync.Mutex{}\ntype single struct {\n}\nvar singleInstance *single\nfunc SingleInstance() *single {\nif singleInstance == nil {\nlock.Lock()\ndefer lock.Unlock()\nif singleInstance == nil {\nfmt.Println(\"Creating single instance now.\")\nsingleInstance = &amp;single{}\n} else {\nfmt.Println(\"Single instance already created.\")\n}\n} else {\nfmt.Println(\"Single instance already created.\")\n}\nreturn singleInstance\n}\n</code></pre>"},{"location":"golang/design_patterns/#decorator","title":"Decorator","text":"<p>The decorator pattern allows adding new behaviours to objects dynamically. Let's see how we can do that by creating a pizza decorator pattern:</p> <p>First we create the decorator functionality</p> pizza.go<pre><code>type Pricer interface {\ngetPrice() int\n}\n</code></pre> <p>then we create create a concrete component:</p> <pre><code>type Pizza struct{}\nfunc (p Pizza) getPrice() int {\nreturn 3\n}\n</code></pre> <p>now we create some decorators:</p> toppings.go<pre><code>type Cheese struct {\npricer Pricer\n}\nfunc (c Cheese) getPrice() int {\nreturn c.pricer.getPrice() + 2\n}\ntype Tomato struct {\npricer Pricer\n}\nfunc (t Tomato) getPrice() int {\nreturn t.pricer.getPrice() + 1\n}\n</code></pre> <p>and now we stack the decorators:</p> main.go<pre><code>func main() {\nprice := Cheese{\npricer: Tomato{\npricer: Pizza{},\n},\n}.getPrice()\nfmt.Println(price)\n}\n</code></pre>"},{"location":"golang/docker/","title":"Docker Images for Go","text":"<p>Surprisingly Docker was built with the programming language Go.</p>"},{"location":"golang/docker/#go-application","title":"Go Application","text":"<p>Let's start with a simple Go webserver and init a go application:</p> <pre><code>go mod init go-webserver\n</code></pre> <p>Now we write the <code>main.go</code> file.</p> main.go<pre><code>package main\nimport (\n\"fmt\"\n\"html\"\n\"log\"\n\"net/http\"\n)\nfunc main() {\nhttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\nfmt.Fprintf(w, \"Hello, %q\", html.EscapeString(r.URL.Path))\n})\nhttp.HandleFunc(\"/hi\", func(w http.ResponseWriter, r *http.Request){\nfmt.Fprintf(w, \"Hi\")\n})\nlog.Fatal(http.ListenAndServe(\":8081\", nil))\n}\n</code></pre> <p>If we run it with <code>go run main.go</code> and access the URL with <code>http://localhost:8081/go</code> we get <code>Hello, \"/go\"</code> as response.</p>"},{"location":"golang/docker/#writing-the-dockerfile","title":"Writing the Dockerfile","text":"<p>We have a working Go application, now let's start to build it as a Docker image. For that we need first a Dockerfile in the same location, where the <code>main.go</code> file is located.</p> <p>Let's create a <code>Dockerfile</code> for that to build images:</p> Dockerfile<pre><code>FROM golang:1.18.1-alpine\nRUN mkdir /app\n\nWORKDIR /app\nCOPY . .\n\nRUN go build -o main .\n\nCMD [\"/app/main\"]\n</code></pre>"},{"location":"golang/docker/#build-the-image","title":"Build the image","text":"<p>Now we have a <code>Dockerfile</code> and can build the image:</p> <pre><code>docker build . -t go-webserver:latest\n</code></pre>"},{"location":"golang/docker/#start-or-push-the-image","title":"Start or push the image","text":"<p>From that point we can start the image or push it onto an image repository.</p> <p>Here is a demonstration, how to start the image:</p> <pre><code>docker run --rm -it -p 8081:8081 go-webserver\n</code></pre> <p>Now we can access again the browser: <code>http://localhost:8081/go</code> and the response should be <code>Hello, \"/go\"</code>.</p>"},{"location":"golang/docker/#smaller-images","title":"Smaller images","text":"<p>Since we compile the go application, we actually don't need the Go files anymore in the image. To save some space we can build the image in two stages (multistage).</p> <p>Here is an example to do that:</p> Dockerfile<pre><code>FROM golang:1.18.1-alpine AS BUILDER\nWORKDIR /app\nCOPY . .                                    RUN go build -o app main.go\n\nFROM alpine:latest\nWORKDIR /app\nCOPY --from=BUILDER /app ./\nCMD [\"./app\"]\n</code></pre> <p>Since we built the Go application on an alpine, we can use instead of <code>golang:alpine</code> just <code>alpine</code>, which is a smaller image.\\</p> <p>We built and start the image:</p> <pre><code>docker build . -t go-webserver-alpine\ndocker run --rm -it -p 8081:8081 go-webserver-alpine\n</code></pre> <p>If we compare those two images, there is a significant difference:</p> <pre><code>go-webserver-alpine            latest        4fe92b6799b2   38 seconds ago   11.4MB\ngo-webserver                   latest        c67bfbfc1bba   7 minutes ago    332MB\n</code></pre>"},{"location":"golang/golang-fundamentals/composite_types/","title":"Composite Types","text":"<p>Composite types in Go contain more functionality than the primitive types. There are builtin functions in Go to support composite types. Let's see how to use them and what are the best practices.</p>"},{"location":"golang/golang-fundamentals/composite_types/#comparable-types","title":"Comparable Types","text":"<p>This types are comparable:</p> <ul> <li>Boolean</li> <li>Numeric</li> <li>String</li> <li>Pointer</li> <li>Channel</li> <li>Interface types</li> <li>Structs \u2013 if all it\u2019s field type is comparable</li> <li>Array \u2013 if the type of value of array element is comparable</li> </ul> <p>This are not comparable types:</p> <ul> <li>Slice</li> <li>Map</li> <li>Function</li> </ul>"},{"location":"golang/golang-fundamentals/composite_types/#arrays","title":"Arrays","text":"<p>Arrays aren't used directly. Normally Go developers use Slices, we will see why in the next chapter, but let's first check what Arrays are and how to use them.</p> <p>First we look at the declaration of an array:</p> <pre><code>var x [3]int\n</code></pre> <p>This creates an array of three ints (<code>x[0]</code>, <code>x[1]</code>, <code>x[2]</code>), each initialized to a zero value (<code>0</code>). If you want to define the values for all array elements use the array literal:</p> <pre><code>var x = [3]int{1, 2, 3}\n</code></pre> <p>If can specify the indices of a new array:</p> <pre><code>var x = [10]int{\n1: 1,\n3: 2,\n5: 3,\n}\n</code></pre> <p>This will create the following array:</p> <pre><code>[0 1 0 2 0 3 0 0 0 0]\n</code></pre> <p>If you want to initialize an array with a dynamic number of values use the variadic keyword <code>...</code>.</p> <pre><code>var x = [...]int{\n1: 1,\n3: 2,\n5: 3,\n}\nfmt.Println(x)\n</code></pre> <p>This will create the following array:</p> <pre><code>[0 1 0 2 0 3]\n</code></pre> <p>You can also define multi-dimensional arrays:</p> <pre><code>var x [2][3]int\n</code></pre> <p>An array can be compared to other arrays with the same type:</p> <pre><code>var x = [3]int{1, 2, 3}\nvar y = [...]int{1, 2, 3}\nfmt.Println(x == y) // true\n</code></pre> <p>Use the known bracket syntax to access array indices:</p> <pre><code>var x = [3]int{1, 2, 3}\nx[0] = 5\nfmt.Println(x[2])\n</code></pre> <p>Note</p> <p>You cannot read or write past an array or use negative indices. If you do it, this will result in a compile time error. An out-of-bound read or write during the execution time will result in a <code>panic</code>. We will talk about that later.</p> <p>The builtin function <code>len</code> gives us the length of an array:</p> <pre><code>var x = [3]int{1, 2, 3}\nfmt.Println(len(x))\n</code></pre> <p>will output:</p> <pre><code>3\n</code></pre> <p>Array are used rarely and explcitly. If you define an array with the size <code>[3]int</code> another array with the size <code>[4]int</code> is a different type. This means you cannot use a variable to specify the size, because Go resolves the size at compile time.</p> <p>You cannot use type conversion to convert arrays. For example this won't work:</p> <p>Failure</p> <pre><code>package main\nimport \"fmt\"\nfunc main () {\nvar x [3]int\nvar y = [4]int(x)\nfmt.Println(x)\nfmt.Println(y)\n}\n</code></pre> <p>will result in:</p> <pre><code>./prog.go:7:16: cannot convert x (variable of type [3]int) to type [4]int\n</code></pre> <p>Therefore you should use arrays only, if you really know the exact length of your array.</p>"},{"location":"golang/golang-fundamentals/composite_types/#slices","title":"Slices","text":"<p>If you want to use arrays and you do not have a fixed size of elements, use slices. The length is not part of a slice.</p> <pre><code>var x = []int{1, 2, 3}\n</code></pre> <p>Note</p> <p>Using [...] makes arrays, using [] makes slices.</p> <p>Also use the same syntax for slices as for arrays just without the size specifier:</p> <pre><code>var x = []int{1: 1, 3: 2, 5: 3}\nvar y [][]int\n</code></pre> <p>You can read and write slices with the bracket syntax. Read or write past a slice or using negative syntax is not allowed:</p> <pre><code>x[0] = 20\nfmt.Println(x[1])\n</code></pre> <p>If you declare a slice without initializing it the zero value for a slice is <code>nil</code>. So if you want to check if a slice has been initialized use:</p> <pre><code>var x []int\nfmt.Println(x != nil) // -&gt; false\n</code></pre> <p>A slice is not a comparable.</p> <p>You can use following built-in functions for slices:</p> <ul> <li>len</li> <li>append</li> <li>cap</li> <li>make</li> </ul> <p>As for arrays you can use len to get the length of a slice:</p> <pre><code>var x []int\nfmt.Println(len(x)) // 0\n</code></pre> <p>The built-in <code>append</code> function can add elements to slices:</p> <pre><code>var x []int\nx = append(x, 1)\n</code></pre> <p>The append function takes at least two parameters, a slice of any type and a value of that type. It returns a new slice of the same type and the appended element at the end.</p> <p>You can append more than one value:</p> <pre><code>var x = []int{0}\nx = append(x, 1, 2, 3)\n</code></pre> <p>You can also append one slice to another by using variadic symbol:</p> <pre><code>var x = []int{1, 2, 3}\nvar y = []int{4, 5, 6}\nx = append(x, y...)\nfmt.Println(x)\n</code></pre> <p>output:</p> <pre><code>[1 2 3 4 5 6]\n</code></pre> <p>If you do not assign the return value of an append call, it will result in a compile time error:</p> <p>Failure</p> <pre><code>var x = []int{1, 2, 3}\nvar y = []int{4, 5, 6}\nappend(x, y...)\nfmt.Println(x)\n</code></pre> <p>will result in:</p> <pre><code>append(x, y...) (value of type []int) is not used\n</code></pre> <p>Go is a call by value language, therefore Go makes a copy of the slice that you pass in, adds an element and return the new copy.</p>"},{"location":"golang/golang-fundamentals/composite_types/#capacity","title":"Capacity","text":"<p>With <code>capacity</code> you retrieve the reserved consecutive memory locations. This can be larger than the length of a slice. Each time you <code>append</code> to a slice Go checks if the capacity is reached and allocates more memory for your slice.</p> <p>It takes some time, if you append to a slice which has reached it's capacity and Go allocates a new bigger slice, copies the values to the new slice and garbage collects the old slice. Therefore has following rule for handling with capacities:</p> <ul> <li>from 0 to 1024 Go doubles the sizes of the current capacity</li> <li>from 1024 to maximum default integer of the target built (32bit or 64bit) increase by 25%</li> </ul> <p><code>cap</code> returns the current capacity of a slice. Let's see how <code>append</code> and <code>cap</code> changes:</p> <pre><code>var x []int\nfmt.Println(x, len(x), cap(x))\nx = append(x, 1)\nfmt.Println(x, len(x), cap(x))\nx = append(x, 2)\nfmt.Println(x, len(x), cap(x))\nx = append(x, 3)\nfmt.Println(x, len(x), cap(x))\nx = append(x, 4)\nfmt.Println(x, len(x), cap(x))\nx = append(x, 5)\nfmt.Println(x, len(x), cap(x))\n</code></pre> <p>output:</p> <pre><code>[] 0 0\n[1] 1 1\n[1 2] 2 2\n[1 2 3] 3 4\n[1 2 3 4] 4 4\n[1 2 3 4 5] 5 8\n</code></pre> <p>This is just a syntactic sugar, to not care about sizes. But if you need to make the code more efficient and especially work with big data inside your slices use <code>make</code>.</p> <p>With <code>make</code> you create a slice with a defined length:</p> <p><code>x := make([]int, 5)</code></p> <p>This creates a slice with an initial length of 5. <code>x</code> is not <code>nil</code> and is already initialized with zero values from index 0 to 4.</p> <p>If you try to use <code>append</code>, because you want to start to fill the slice, it can be a mistake:</p> <pre><code>x := make([]int, 5)\nx = append(x, 1)\n</code></pre> <p>would append to an initialized slice, which would have 5 int zero values and an appended element:</p> <pre><code>[0, 0, 0, 0, 0, 1]\n</code></pre> <p>With the <code>cap</code> function you can also optionally specify the capacity of a slice.</p> <pre><code>x := make([]int, 5, 10)\n</code></pre> <p>This would create a slice of length 5 and a capacity of 10. If you want to initial the slice with append just <code>make</code> a slice if the initial length of 0 and a preferred capacity:</p> <pre><code>x := make([]int, 0, 4)\nx = append(x, 1)\nx = append(x, 2)\nx = append(x, 3, 4)\nfmt.Println(x)\n</code></pre> <p>output:</p> <pre><code>[1 2 3 4]\n</code></pre>"},{"location":"golang/golang-fundamentals/composite_types/#slicing","title":"Slicing","text":"<p>You can use slicing with slices to define a \"from\" \"to\" (excluded) range. If you do not the \"from\" range <code>0</code> will be assumed, as for \"to\".</p> <pre><code>x := []int{1, 2, 3, 4}\nfmt.Println(x[:2])\nfmt.Println(x[1:])\nfmt.Println(x[1:2])\nfmt.Println(x[:])\n</code></pre> <p>output:</p> <pre><code>[1 2]\n[2 3 4]\n[2]\n[1 2 3 4]\n</code></pre> <p>Note</p> <p>You will not make a copy of a slice, if you use slicing. Slicings of a slice share the same memory and can be modified.</p> <p>Let's see how we modify the sliced slice to the original slice:</p> <pre><code>x := []int{1, 2, 3, 4}\ny := x[:1]\ny[0] = 9\nfmt.Println(x)\n</code></pre> <p>output:</p> <pre><code>[9 2 3 4]\n</code></pre> <p>If you have arrays, you can convert them to a slice by using slicing.</p> <pre><code>x := [4]int{1, 2, 3, 4}\ny := x[:]\ny = append(y, 1)\nfmt.Println(x)\nfmt.Println(y)\n</code></pre> <p>Output:</p> <pre><code>[1 2 3 4]\n[1 2 3 4 1]\n</code></pre> <p>If you want to <code>copy</code> a slice you can use the built-in function.</p> <p>It copies all values from a source slice into a destination slice, but consider that the parameters are swapped: <code>copy(destination, source)</code>.</p> <p><code>copy</code> is limited to the length of the smaller slice (the capacity doesn't matter).</p> <p>So for example:</p> <pre><code>x := []int{1, 2, 3, 4}\ny := make([]int, 2)\nnum := copy(x, y)\nfmt.Println(num, y)\n</code></pre> <p>output:</p> <pre><code>2 [1 2]\n</code></pre>"},{"location":"golang/golang-fundamentals/composite_types/#maps","title":"Maps","text":"<p>Maps are key-value variables. Maps are not comparable. Let's see how to declare one:</p> <pre><code>var myMap map[string]int\nfmt.Println(myMap == nil) // -&gt; true\n</code></pre> <p>If you want to create a map you have several options:</p> <pre><code>classes := map[string][]string{\n\"Class 1\": []string{\n\"Sarah\", \"Peter\", \"Justin\",\n},\n\"Class 2\": []string{\n\"Fred\", \"Ralph\", \"Lea\",\n},\n}\n</code></pre> <p>or use the built-int <code>make</code> function. This will create a 10 length key-value pair map. But, other than slices, it will have a length of 0.</p> <pre><code>classes := make(map[string]int, 10)\n</code></pre> <p>The key of a slice can be a comparable type.</p> <p>Reading and writing to a map is similar to reading and writing to slices:</p> <pre><code>class1 := \"Class 1\"\nclass2 := \"Class 2\"\nclasses := map[string][]string{\nclass1: []string{\n\"Sarah\", \"Peter\", \"Justin\",\n},\nclass2: []string{\n\"Fred\", \"Ralph\", \"Lea\",\n},\n}\nfmt.Println(classes)\nclasses[class1] = append(classes[class1], \"Christian\")\nfmt.Println(classes[class1])\n</code></pre> <p>output:</p> <pre><code>map[Class 1:[Sarah Peter Justin] Class 2:[Fred Ralph Lea]]\n[Sarah Peter Justin Christian]\n</code></pre> <p>If you access a key which is not assigned to the map, it will return the zero value to that type:</p> <pre><code>classes := map[string][]string{\n\"Class 1\": []string{ \"Sarah\", \"Peter\", \"Justin\" },\n}\nfmt.Println(classes[\"Not exist\"])\nfmt.Println(classes[\"Not exist\"] == nil)\nages := map[string]int{\n\"Tester\": 31,\n}\nfmt.Println(ages[\"Not exist\"])\nfmt.Println(ages[\"Not exist\"] == 0)\n</code></pre> <p>output:</p> <pre><code>[]\ntrue\n0\ntrue\n</code></pre>"},{"location":"golang/golang-fundamentals/composite_types/#variable-ok-idiom","title":"variable, ok := idiom","text":"<p>Sometimes you don't want to explicitly check for the zero value like <code>\"\"</code> for strings or <code>0</code> for numeric values. There is a syntactic sugar, which helps to do that properly:</p> <pre><code>example := map[string]int{\n\"Hello\": 119,\n\"World\": 312,\n}\nvalue, ok := example[\"Hello\"]\nfmt.Println(value, ok)\nvalue, ok = example[\"NotExist\"]\nfmt.Println(value, ok)\n</code></pre> <p>output:</p> <pre><code>119 true\n0 false\n</code></pre> <p>If the key is present it will return the value as first return value and a boolean <code>true</code> in the second return value. If the key is not preset it will return the zero value as first return value and a boolean <code>false</code> in the second return value.</p> <p>If you need to delete from maps you can use the built-in <code>delete</code> function. The <code>delete</code> function takes a map and the key. If the key is not present or the map is nil nothing happens. The delete function does not return any value.</p> <pre><code>example := map[string]int{\n\"Hello\": 119,\n\"World\": 312,\n}\ndelete(example, \"Hello\")\ndelete(example, \"Test\")\n</code></pre>"},{"location":"golang/golang-fundamentals/composite_types/#structs","title":"Structs","text":"<p>With maps you can define dynamic data, but they have limitations. All values have to have the same type and you cannot define which keys are public or private. If you know already what classes are, this is probably what you are searching for: a struct</p> <p>Here is a struct:</p> <pre><code>type person struct {\nfirstName   string\nlastName    string\nage         int\n}\n</code></pre> <p>You can define structs inside or outside functions (respecting the scopes). If you declared a struct type, you can use it:</p> <pre><code>var michael person\n</code></pre> <p>The variable gets the zero value of a struct which the <code>nil</code> value. If you want to initialize a struct use <code>{}</code>, this will initialize the struct with zero values for all fields.</p> <pre><code>var michael = person{\n\"Michael\",\n\"Bykovski\",\n28,\n}\n</code></pre> <p>alternatively you can use the field names to make it explicit:</p> <pre><code>var michael = person{\nfirstName:  \"Michael\",\nlastName:   \"Bykovski\",\nage:        28,\n}\n</code></pre> <p>Access a struct field by punctuation:</p> <pre><code>var michael = person{\nfirstName:  \"Michael\",\nlastName:   \"Bykovski\",\nage:        28,\n}\nmichael.age++\nfmt.Println(michael)\n</code></pre> <p>output:</p> <pre><code>{Michael Bykovski 29}\n</code></pre>"},{"location":"golang/golang-fundamentals/composite_types/#anonymous-structs","title":"Anonymous structs","text":"<p>An anonymous struct is a struct without a name.</p> <p>Let's look at an example:</p> <pre><code>var person struct {\nfirstName   string\nlastName    string\nage         int\n}\npet := struct {\nname string\nkind string\n} {\nname: \"Jukes\",\nkind: \"cat\",\n}\n</code></pre> <p>Anonymous structs are useful if you want to serialize and deserialize data, which is called \"marshal\" and \"unmarshal\" in Go.</p>"},{"location":"golang/golang-fundamentals/composite_types/#comparing-and-converting-structs","title":"Comparing and Converting Structs","text":"<p>If you want to compare structs, Go only compares structs if the fields of a given struct are all comparable. So if you have a list or a map in a struct, it becomes not comparable.</p> <p>If you want to have a custom compare function, you can write your own method.</p> <p>If you compare two different type structs Go will falsify it. But you can do a type conversion between two type structs if they have the same field signatures.</p> <p>Let's first look at a successful type conversion but failed comparison.</p> <pre><code>type firstPet struct {\nname    string\nkind    string\n}\ntype secondPet struct {\nname    string\nkind    string\n}\npet := firstPet {\nname: \"Jukes\",\nkind: \"cat\",\n}\nvar pet2 secondPet\npet2 = secondPet(pet)\nfmt.Println(pet2)\n//fmt.Println(pet2 == pet)\n</code></pre> <p>Type conversion on line 16 would work. But it would fail on line 18 because <code>invalid operation: pet2 == pet (mismatched types secondPet and firstPet)</code></p> <p>Now let's look at failed type conversions and therefore failed comparisons.</p> <pre><code>type firstPet struct {\nname    string\nkind    string\n}\n// wrong order\ntype thirdPet struct {\nkind    string\nname    string\n}\n// wrong name\ntype fourthPet struct {\nname    string\nrace    string\n}\n// wrong signatures\ntype fifthPet struct {\nname    string\nkind    string\nage     int\n}\npet := firstPet {\nname: \"Jukes\",\nkind: \"cat\",\n}\nvar pet3 thirdPet\nvar pet4 fourthPet\nvar pet5 fifthPet\npet3 = thirdPet(pet)\npet4 = fourthPet(pet)\npet5 = fifthPet(pet)\n</code></pre> <p>Cannot type convert to any type, because all field signatures are wrong:</p> <pre><code>./prog.go:41:17: cannot convert pet (variable of type firstPet) to type thirdPet\n./prog.go:42:18: cannot convert pet (variable of type firstPet) to type fourthPet\n./prog.go:43:17: cannot convert pet (variable of type firstPet) to type fifthPet\n</code></pre> <p>Now we look at a successfull type conversion and comparison:</p> <pre><code>type firstPet struct {\nname    string\nkind    string\n}\nvar anonymousPet struct {\nname    string\nkind    string\n}\npet := firstPet {\nname: \"Jukes\",\nkind: \"cat\",\n}\nanonymousPet = pet\nfmt.Println(pet, anonymousPet, anonymousPet == pet)\n</code></pre> <p>output:</p> <pre><code>{Jukes cat} {Jukes cat} true\n</code></pre>"},{"location":"golang/golang-fundamentals/concurrency/","title":"Concurrency","text":""},{"location":"golang/golang-fundamentals/concurrency/#when-to-use-concurrency","title":"When to use concurrency","text":"<p>More Concurrency != More Speed</p> <p>Concurrency != Parallelism</p> <p>Concurrency is doing a lot of things at once, Parallelism is doing a lot of things at the same time.</p> <p>Generalizing on that a bit, any producer-consumer problem is a natural fit for 2 goroutines using a channel to pass outputs from the producer to the consumer.</p> <p>Another good use for concurrency is interacting with multiple input/output sources (disks, network, terminal, etc.). Your program should be able to wake up and do some work whenever a result comes from any of these sources. It is possible to do this with one thread and a system call like poll(2) or select(2). When your thread wakes up, it must figure out which result came in, find where it left off in the relevant task, and pick up from there. That's a lot of code you need to write.</p> <p>Writing that code is much easier using one goroutine per task. Then the state of that task is captured implicitly in the goroutine, and picking up where it left off is as simple as waking up and running.</p> <p>Source</p> <p>Go Concurrency Guide</p>"},{"location":"golang/golang-fundamentals/concurrency/#scheduler","title":"Scheduler","text":"<p>Every programm gets executed as a process and every process has one or many threads. The scheduler of an operating system decides which process (and the threads within a process) gets a specific amount of time to calculate.</p> <p>Go has it's own scheduler which creates some threads at the start of your Go application. The <code>main</code> function is actually the first Goroutine running in your Go application. Go schedules and assigns Goroutines to the created threads so that the system-overhead can be minimized.</p> <p>There are some benefits by doing that:</p> <ul> <li>Goroutines are created faster than usual system threads</li> <li>Goroutines stack sizes are smaller than usual system threads</li> <li>Switching between Goroutines is faster than switching betweens system threads because it happens within the Go programm (process), avoiding system calls</li> <li>The Go scheduler can optimize goroutines by themselves, because it's part of the Go process. It can decide to pause and resume a goroutine because it could have a blocking go operation (channel, mutex) or a blocking system call (ntework, IO, garbage collection).</li> </ul> <p>By implementing an own scheduler, this allows to spawn more than ten thousand of simultaneous goroutines. Try so spawn ten thousand system threads, this would result in a mess.</p>"},{"location":"golang/golang-fundamentals/concurrency/#goroutines","title":"Goroutines","text":"<p>Goroutines are executed by the keyword <code>go</code> before a function invocation. Don't see it as a async/await, it's more a \"go and never come back\" execution. If you want to return values from your <code>goroutine</code> don't use return, use it with <code>Channels</code>.</p> <pre><code>func Compute() {\nfor i := 0; i &lt; 10_000_000_000; i++ {}\nfmt.Println(\"Done\")\n}\nfunc main() {\nfmt.Println(\"Starting\")\ngo Compute()\nfmt.Println(\"After Compute\")\n}\n</code></pre> <p>output: </p> <pre><code>Starting\nAfter Compute\n</code></pre>"},{"location":"golang/golang-fundamentals/concurrency/#channels","title":"Channels","text":"<p>Channels are like slices and maps, they are a built-in type and can be created using the <code>make</code> function.</p> <pre><code>ch := make(chan int)\n</code></pre> <p>Channels are referenced, this means that channels are actually pointers. The zero value for channels are <code>nil</code>.</p>"},{"location":"golang/golang-fundamentals/concurrency/#reading-writing-channels","title":"Reading, Writing Channels","text":"<p>The <code>&lt;-</code> operator is used to read or write from channels. If you want to read from a channel, place the operator on the left side; writing on the right side.</p> <pre><code>val := &lt;- ch // reading\nch &lt;- 3 // writing\n</code></pre> <p>Values written to a channel can be read only once. If multiple goroutines try to read from a channel, only one will get the value.</p> <p>If you pass a channel into a function, indicate if the function will read or write from the channel. By doing this, you tell the compiler to check, if you only read or write to a channel. Usually a function read from one channel and writes into another.</p> <pre><code>func execute(in &lt;-chan int, out chan&lt;- int) {\ngo func() {\nfor val := range in {\nresult := process(val)\nout &lt;- result\n}\n}()\n}\n</code></pre> <p>Go uses unbuffered channels by default. Every write to an open, unbuffered channel causes the writing goroutine to pause until another goroutine reads from this channel. Every read to an open, unbuffered channel causes the reading goroutine to pause until another goroutine writes from this channel.</p> <pre><code>import (\n\"fmt\"\n\"time\"\n)\nfunc hello(done chan bool) {\nfmt.Println(\"Hello world goroutine\")\ntime.Sleep(5 * time.Second)\ndone &lt;- true\n}\nfunc main() {\ndone := make(chan bool)\ngo hello(done)\nfmt.Println(\"waiting...\")\n&lt;-done\nfmt.Println(\"main function\")\n}\n</code></pre> <p>will output:</p> <pre><code>waiting...\nHello world goroutine\nmain function\n</code></pre>"},{"location":"golang/golang-fundamentals/concurrency/#buffered-channels","title":"Buffered Channels","text":"<p>Go has buffered channels. This means, that those channels have a limited number of writes without blocking. If the buffer fills before the channel was read from a goroutine, it will block until the channel is read. Reading from an empty buffer blocks also.</p> <p>Creating a buffered channel works the same way as creating an unbuffered channels, but you enter a capacity:</p> <pre><code>ch := make(chan int, 10)\n</code></pre> <p><code>len</code> can be used to check, how many values are currently in the channel.</p> <p><code>cap</code> ca be used to find out the maximum buffer size.</p>"},{"location":"golang/golang-fundamentals/concurrency/#looping-over-a-channel","title":"Looping over a channel","text":"<p>You can use the for-range loop. The loop loops until the channel is closed, until a break or return inside of the loop.</p> <pre><code>for v := range ch {\nfmt.Println(v)\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/concurrency/#closing-a-channel","title":"Closing a channel","text":"<p>Close a channel if you are done writing to it:</p> <pre><code>close(ch)\n</code></pre> <p>If you attempt to write or try to close the channel again, Go will panic. Reading from a closed channel works, it will return the zero value of the channels type.</p> <p>When we can always read from a channel, how we can tell if the channel is closed or open and we just read a zero value? We can use the <code>comma ok idiom</code> to check if the channel is closed. If the channel is closed, ok is false; true otherwise:</p> <pre><code>v, ok := &lt;-ch\n</code></pre> <p>The responsibility to close a channel lies with the goroutine that writes to a channel. Closing is only required, if another goroutine waits for new inputs.</p> <p>This example would result in a deadlock:</p> <pre><code>import (\n\"fmt\"\n\"time\"\n)\nfunc hello(done chan bool) {\nfmt.Println(\"Hello world goroutine\")\nfmt.Println(\"Waiting 1 seconds\")\ntime.Sleep(1 * time.Second)\ndone &lt;- true\nfmt.Println(\"Waiting 1 seconds\")\ntime.Sleep(1 * time.Second)\ndone &lt;- true\n}\nfunc main() {\ndone := make(chan bool)\ngo hello(done)\nfor value := range done {\nfmt.Println(value)\n}\n}\n</code></pre> <p>output:</p> <pre><code>Hello world goroutine\nWaiting 1 seconds\ntrue\nWaiting 1 seconds\ntrue\nfatal error: all goroutines are asleep - deadlock!\n\ngoroutine 1 [chan receive]:\nmain.main()\n        /Users/michaelbykovski/workspace/daimler/golang_workshop/goroutines_sleep/main.go:21 +0xd0\nexit status 2\n</code></pre> <p>Because the <code>main</code> function would wait for a new value which cannot be filled by any \"active\" goroutine. To fix that you should close the channel, so that the for-range loop stops:</p> <pre><code>import (\n\"fmt\"\n\"time\"\n)\nfunc hello(done chan bool) {\nfmt.Println(\"Hello world goroutine\")\nfmt.Println(\"Waiting 1 seconds\")\ntime.Sleep(1 * time.Second)\ndone &lt;- true\nfmt.Println(\"Waiting 1 seconds\")\ntime.Sleep(1 * time.Second)\ndone &lt;- true\nclose(done)\n}\nfunc main() {\ndone := make(chan bool)\ngo hello(done)\nfor value := range done {\nfmt.Println(value)\n}\n}\n</code></pre> <p>output:</p> <pre><code>Hello world goroutine\nWaiting 1 seconds\nWaiting 1 seconds\ntrue\ntrue\n</code></pre>"},{"location":"golang/golang-fundamentals/concurrency/#select","title":"Select","text":"<p><code>Select</code> statements can be used, to wait for multiple channels simultaneously. <code>Select</code> blocks until one of it's cases fulfills. If multiple cases are ready, it chooses one randomly:</p> <pre><code>import (\n\"fmt\"\n\"time\"\n)\nfunc main() {\none := make(chan string)\ntwo := make(chan string)\ngo func() {\ntime.Sleep(time.Second * 1)\none &lt;- \"One\"\n}()\ngo func() {\ntime.Sleep(time.Second * 1)\ntwo &lt;- \"Two\"\n}()\nselect {\ncase result := &lt;-one:\nfmt.Println(\"Received:\", result)\ncase result := &lt;-two:\nfmt.Println(\"Received:\", result)\n}\nclose(one)\nclose(two)\n}\n</code></pre> <p>This will output sometime <code>two</code> and sometimes <code>one</code>. output:</p> <pre><code>Received: One\n</code></pre>"},{"location":"golang/golang-fundamentals/concurrency/#the-done-channel-pattern","title":"The done channel pattern","text":"<p>Sometimes you have multiple goroutines started, but you wait for only one to resolve and then you need to stop all the others. Then you need the done channel pattern:</p> <pre><code>import (\n\"fmt\"\n\"math/rand\"\n\"time\"\n)\ntype searcherFunc func(string) string\nfunc searchData(s string, searchers []searcherFunc) string {\ndone := make(chan bool)\nresult := make(chan string)\nfor _, searcher := range searchers {\ngo func(searcher searcherFunc) {\nselect {\ncase result &lt;- searcher(s):\ncase &lt;-done:\n}\n}(searcher)\n}\nr := &lt;-result\nclose(done)\nreturn r\n}\nfunc RandomBetween(min int, max int) int {\nreturn rand.Intn(max-min) + min\n}\nfunc main() {\nrand.Seed(time.Now().Unix())\nsearchers := []searcherFunc{\nfunc(s string) string {\nsleepSeconds := time.Second * time.Duration(RandomBetween(1, 10))\ntime.Sleep(sleepSeconds)\nreturn \"First!\"\n},\nfunc(s string) string {\nsleepSeconds := time.Second * time.Duration(RandomBetween(1, 10))\ntime.Sleep(sleepSeconds)\nreturn \"Second!\"\n},\nfunc(s string) string {\nsleepSeconds := time.Second * time.Duration(RandomBetween(1, 10))\ntime.Sleep(sleepSeconds)\nreturn \"Third!\"\n},\n}\ndata := searchData(\"test\", searchers)\nfmt.Println(data)\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/concurrency/#waitgroups","title":"WaitGroups","text":"<p><code>WaitGroups</code> are handy if you have multiple goroutines and you want to wait for all to finish. The <code>sync</code> package provides the <code>WaitGroup</code> struct. It has the following functions:</p> <ul> <li><code>Add(int)</code></li> <li><code>Done()</code></li> <li><code>Wait()</code></li> </ul> <p>Let's see the <code>WaitGroup</code> in practice:</p> <pre><code>import (\n\"fmt\"\n\"sync\"\n)\nfunc work(wg *sync.WaitGroup) {\ndefer wg.Done()\nfmt.Println(\"working...\")\n}\nfunc main() {\nvar wg sync.WaitGroup\nwg.Add(4)\ngo work(&amp;wg)\ngo work(&amp;wg)\ngo work(&amp;wg)\ngo work(&amp;wg)\nfmt.Println(\"Now lets wait for all to finish\")\nwg.Wait()\nfmt.Println(\"All finished\")\n}\n</code></pre> <p>output:</p> <pre><code>Now lets wait for all to finish\nworking...\nworking...\nworking...\nworking...\nAll finished\n</code></pre>"},{"location":"golang/golang-fundamentals/concurrency/#mutexes","title":"Mutexes","text":"<p>Mutexes are also located in the <code>sync</code> library. Mutexes help to <code>Lock</code> and <code>Unlock</code> critical sections, to prevent race conditions.</p> <p>Let's check an example:</p> <pre><code>package main\nimport (\n\"fmt\"\n\"sync\"\n)\ntype Counter struct {\nvalue int\n}\nfunc (c *Counter) Update(n int, wg *sync.WaitGroup) {\nvalue := c.value\ndefer wg.Done()\nfmt.Printf(\"Adding %d to %d\\n\", n, value)\nc.value = value + n\n}\nfunc main() {\nvar wg sync.WaitGroup\nc := Counter{}\nwg.Add(4)\ngo c.Update(10, &amp;wg)\ngo c.Update(-5, &amp;wg)\ngo c.Update(25, &amp;wg)\ngo c.Update(19, &amp;wg)\nwg.Wait()\nfmt.Println(c.value)\n}\n</code></pre> <p><code>c.Update()</code> works on the <code>c.value</code> variable and since they are all running concurrent, you never now, which value is currently in <code>c.value</code>. output:</p> <pre><code>Adding 19 to 0\nAdding -5 to 0\nAdding 10 to 0\nAdding 25 to 0\n25\n</code></pre> <p>You can fix that by using <code>Mutex</code>:</p> <pre><code>type Counter struct {\nm     sync.Mutex\nvalue int\n}\nfunc (c *Counter) Update(n int, wg *sync.WaitGroup) {\nc.m.Lock()\ndefer wg.Done()\nfmt.Printf(\"Adding %d to %d\\n\", n, c.value)\nc.value += n\nc.m.Unlock()\n}\nfunc main() {\nvar wg sync.WaitGroup\nc := Counter{}\nwg.Add(4)\ngo c.Update(10, &amp;wg)\ngo c.Update(-5, &amp;wg)\ngo c.Update(25, &amp;wg)\ngo c.Update(19, &amp;wg)\nwg.Wait()\nfmt.Println(c.value)\n}\n</code></pre> <p>Now the output is correct, because we Lock the critical section <code>c.value</code> and only one goroutine is allowed to work on it until it <code>Unlock</code> the <code>Mutex</code> again.</p> <pre><code>Adding 19 to 0\nAdding 10 to 19\nAdding -5 to 29\nAdding 25 to 24\n49\n</code></pre>"},{"location":"golang/golang-fundamentals/concurrency/#concurrency-in-go","title":"Concurrency in Go","text":"<p>Concurrency can be very frustrating, because a lot of things happen at the same time in your application and it can be very hard to predict or even debug, what is happening. For this there is a very good book by Katherine Cox-Buday it's called <code>Concurrency in Go</code>.</p>"},{"location":"golang/golang-fundamentals/context/","title":"Context","text":"<p>Context is the idea to have a <code>request scoped value storage</code> (Source).</p> <p>Let's start by taking a look at the context interface:</p> <pre><code>// A Context carries a deadline, cancellation signal, and request-scoped values\n// across API boundaries. Its methods are safe for simultaneous use by multiple\n// goroutines.\ntype Context interface {\n// Done returns a channel that is closed when this Context is canceled\n// or times out.\nDone() &lt;-chan struct{}\n// Err indicates why this context was canceled, after the Done channel\n// is closed.\nErr() error\n// Deadline returns the time when this Context will be canceled, if any.\nDeadline() (deadline time.Time, ok bool)\n// Value returns the value associated with key or nil if none.\nValue(key interface{}) interface{}\n}\n</code></pre> <p>Mostly <code>Context</code> is used to set values within a request and to cancel long running requests.</p> <p>Let's first take a look a simple example:</p> main.go<pre><code>func process(ctx context.Context) {\nfmt.Println(\"Processing user id: \", ctx.Value(\"user_id\"))\nselect {\ncase &lt;-time.After(10 * time.Second):\nfmt.Println(\"Processing finished\")\ncase &lt;-ctx.Done():\nfmt.Println(\"Processing cancelled\")\n}\n}\nfunc hello(w http.ResponseWriter, req *http.Request) {\nctx := req.Context()\n_, cancelFunc := context.WithCancel(ctx)\nctx = context.WithValue(ctx, \"user_id\", 123)\ngo process(ctx)\nselect {\ncase &lt;-time.After(3 * time.Second):\ncancelFunc()\nfmt.Fprint(w, \"Cancelled\")\ncase &lt;-ctx.Done():\nerr := ctx.Err()\nfmt.Println(\"server:\", err)\ninternalError := http.StatusInternalServerError\nhttp.Error(w, err.Error(), internalError)\n}\n}\nfunc main() {\nhttp.HandleFunc(\"/hello\", hello)\nhttp.ListenAndServe(\":8080\", nil)\n}\n</code></pre> <p>If you are not in a request-response loop, you can use the built-in functions to create a context for other purposes:</p> main.go<pre><code>import (\n\"context\"\n\"fmt\"\n\"time\"\n)\nfunc fastRequest(ctx context.Context, result chan&lt;- string) {\nselect {\ncase &lt;-ctx.Done():\nreturn\ncase &lt;-time.After(5 * time.Second):\nresult &lt;- \"fast\"\nreturn\n}\n}\nfunc slowRequest(ctx context.Context, result chan&lt;- string) {\nselect {\ncase &lt;-ctx.Done():\nreturn\ncase &lt;-time.After(30 * time.Second):\nresult &lt;- \"slow\"\nreturn\n}\n}\nfunc main() {\nctx := context.Background()\nctx, _ = context.WithDeadline(ctx, time.Now().Add(7*time.Second))\ndata := make(chan string)\nfmt.Println(\"Startig fast request\")\ngo fastRequest(ctx, data)\nfmt.Println(\"Startig slow request\")\ngo slowRequest(ctx, data)\nfor {\nselect {\ncase &lt;-ctx.Done():\nfmt.Println(\"Canceled context, quiting\")\nreturn\ncase result := &lt;-data:\nfmt.Println(result)\nreturn\n}\n}\n}\n</code></pre> <p>output is: </p> <pre><code>Startig fast request\nStartig slow request\nfast\n</code></pre>"},{"location":"golang/golang-fundamentals/control_structures/","title":"Control Structures","text":"<p>We studied the grammar, primitive types and composite types. Now we are able to work with variables, but they are nothing without \"algorithms\" (without control structures). Let's dive in and see how we do what in Go.</p>"},{"location":"golang/golang-fundamentals/control_structures/#blocks","title":"Blocks","text":"<p>Blocks define the scope of constants, variables, functions and types. Therefore there are several blocks, where one of these can exist.</p> <p>There is a <code>package</code>, <code>file</code>, <code>function</code>, and <code>{}</code> block.</p> <ul> <li>All constants, variables, functions and types declared outside of a function are in a <code>package block</code>.</li> <li>All <code>imported</code> constants, variables, functions and types are called <code>file block</code>.</li> <li>All constants, variables, functions and types (parameters included) declared in a function are in a <code>function block</code>.</li> <li>All constants, variables, functions and types declared in curly braces in a function are in a <code>{} block</code>.</li> </ul>"},{"location":"golang/golang-fundamentals/control_structures/#shadowing-variables","title":"Shadowing variables","text":"<p>Shadowing variables is setting the variable value shortly in a <code>{}</code>block inside of a function block. It only works if you use the same name of the \"shadow\" variable.</p> <p>Here is an example:</p> <pre><code>func main() {\nx := 20\nif x &gt; 0 {\nfmt.Println(x)\nx := 5\nfmt.Println(x)\n}\nfmt.Println(x)\n}\n</code></pre> <p>the output is:</p> <pre><code>20\n5\n20\n</code></pre> <p>That's why it is so problematic to use <code>:=</code>, we can shadow variables in inner scopes of a function, which makes it harder to really define, which value a variable has.</p> <p>Danger</p> <p>You can shadow imported package names. This can break your scope and you should never ever do this:</p> <pre><code>package main\nimport (\n\"fmt\"\n)\nfunc main() {\nx := \"Hello World\"\nfmt := 20\nfmt.Println(x)\n}\n</code></pre> <p>will output:</p> <pre><code>./prog.go:10:6: fmt.Println undefined (type int has no field or method Println)\n</code></pre>"},{"location":"golang/golang-fundamentals/control_structures/#universe-block","title":"Universe Block","text":"<p>Golang has only 25 keywords (var, for, switch). Types (int, string), Constants (true, false) and Functions(make, close) are not included in the keyword list.</p> <p>They were defined in a <code>universe block</code>. This is the most outside block. Because they are defined in the most outside block, they can be shadowed.</p> <p>Danger</p> <pre><code>package main\nimport (\n\"fmt\"\n)\nfunc main() {\nfmt.Println(true)\ntrue := 12\nfmt.Println(true)\n}\n</code></pre> <p><code>true</code> will be shadowed and can result in big misbehaviour of the code.</p>"},{"location":"golang/golang-fundamentals/control_structures/#if","title":"If","text":"<p>If is actually pretty easy and works in the same way as in other programming languages.</p> <pre><code>n := 12\nif n == 0 {\nfmt.Println(\"N is 0\")\n} else if n &gt; 0 {\nfmt.Println(\"N is bigger than 0\")\n} else {\nfmt.Println(\"N is lower than 0\")\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/control_structures/#scoping-variables-in-if-statements","title":"Scoping variables in if statements","text":"<p>If you want to declare a variable while checking for it's value you can declare a variable directly in an if statement. Variables defined as a scoped variable only exist in the defined scope.</p> <pre><code>if n := 12; n == 0 {\nfmt.Println(\"N is 0\")\n} else if n &gt; 0 {\nfmt.Println(\"N is bigger than 0\")\n} else {\nfmt.Println(\"N is lower than 0\")\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/control_structures/#for","title":"For","text":"<p>There is only one looping keywod called <code>for</code>. With for you can define 4 different formats in Go:</p> <ul> <li>C-style for</li> <li>Condition for</li> <li>Infinite for</li> <li>for-range</li> </ul>"},{"location":"golang/golang-fundamentals/control_structures/#c-style-for","title":"C-style for","text":"<p>This is probably known to you. The only thing to mention is that you can't use <code>var</code> keyword to define i.</p> <pre><code>for i := 0; i &lt; 10; i++ {\nfmt.Println(i)\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/control_structures/#condition-for","title":"Condition for","text":"<p>Go has the ability to run a go loop forever until a certain variable because <code>false</code>. This pattern is known as <code>while</code> loops in other programming languages:</p> <pre><code>i := 1\nfor i &lt; 10 {\ni++\nfmt.Println(i)\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/control_structures/#infinite-for","title":"Infinite for","text":"<p>The infinite for works the same way as for the condition for, you just have to leave the condition. This would force the for loop to run forever.</p> <pre><code>for {\nfmt.Println(\"Run forever\")\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/control_structures/#break-and-continue","title":"break and continue","text":"<p><code>break</code> helps you to stop a for loop. <code>continue</code> helps you to skip the rest of the scope and start a new loop</p> <pre><code>for {\n...\nif !condition {\nbreak\n}\n}\n</code></pre> <pre><code>for {\n...\nif !condition {\n...\ncontinue\n}\nfmt.Println(\"This is skipped when condition is false\")\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/control_structures/#for-range","title":"for-range","text":"<p><code>for-range</code> loops are designed to make a foreach loop in Go. You can use strings, arrays, slices and maps with foreach loops. Later on we will talk about <code>Channels</code> wher for-range loops can be handy too.</p> <pre><code>values := []int{1, 3, 5, 7, 9}\nfor i, v := range values {\nfmt.Println(i, v)\n}\n</code></pre> <p>output:</p> <pre><code>0 1\n1 3\n2 5\n3 7\n4 9\n</code></pre> <p>In a for-range loop you always get two variables. The first one is the index (strings, arrays, slices) or key (maps). The second one is the actual value.</p> <p>If you don't need the key or value in a for-range loop, you can use <code>_</code> to let Go know, that it should ignore this variable.</p> <pre><code>values := []int{1, 3, 5, 7, 9}\nfor _, v := range values {\nfmt.Println(v)\n}\n</code></pre> <p>output:</p> <pre><code>1\n3\n5\n7\n9\n</code></pre> <p>If you just want the key, you can use the first variable and leave the second not declared.</p> <pre><code>values := []int{1, 3, 5, 7, 9}\nfor i := range values {\nfmt.Println(i)\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/control_structures/#for-range-variables-are-copies","title":"for-range variables are copies","text":"<p>Go iterates over copies of your variable. Therefore modifying the for-range variables directly is useless. You have to overwrite outer scopes variables:</p> <pre><code>values := []int{1, 3, 5, 7, 9}\nfor _, v := range values {\nv++\nfmt.Println(v)\n}\nfmt.Println(values)\nfor i := range values {\nvalues[i]++\nfmt.Println(values[i])\n}\nfmt.Println(values)\n</code></pre> <p>output:</p> <pre><code>2\n4\n6\n8\n10\n[1 3 5 7 9]\n2\n4\n6\n8\n10\n[2 4 6 8 10]\n</code></pre>"},{"location":"golang/golang-fundamentals/control_structures/#labeling-for-statements","title":"Labeling for statements","text":"<p>You can <code>break</code> or <code>continue</code> in for loops by using <code>labels</code>. This example continues the outer for loop. You will find labeled for loops very rare in the Go ecosystem.</p> <pre><code>func main() {\nvalues := []string{\"hello\", \"world\"}\nouter:\nfor _, value := range values {\nfor i, r := range value {\nfmt.Println(i, r, string(r))\nif r == 'l' {\ncontinue outer\n}\n}\nfmt.Println(\"\\n\")\n}\n}\n</code></pre> <p>output:</p> <pre><code>0 104 h\n1 101 e\n2 108 l\n0 119 w\n1 111 o\n2 114 r\n3 108 l\n</code></pre>"},{"location":"golang/golang-fundamentals/control_structures/#switch","title":"switch","text":"<p>Switch statements in Go are very useful though in other languages they are more avoided.</p> <p>Let's see an example:</p> <pre><code>words := []string{\"a\", \"hello\", \"gopher\", \"go\", \"github\", \"javascript\"}\nfor _, word := range words {\nswitch size := len(word); size {\ncase 1, 2, 3, 4:\nfmt.Println(word, \"is less than 5 characters long\")\ncase 5:\nfmt.Println(word, \"is 5 characters long\")\ncase 6, 7, 8, 9:\ndefault:\nfmt.Println(word, \"is more than 5 characters long\")\n}\n}\n</code></pre> <p>output:</p> <pre><code>a is less than 5 characters long\nhello is 5 characters long\ngo is less than 5 characters long\njavascript is more than 5 characters long\n</code></pre>"},{"location":"golang/golang-fundamentals/control_structures/#duplicate-cases","title":"Duplicate cases","text":"<p>You cannot define multiple cases:</p> <pre><code>for _, word := range words {\nswitch size := len(word); size {\ncase 1, 2, 3, 4:\nfmt.Println(word, \"is less than 5 characters long\")\ncase 1:\nfmt.Println(word, \"\")\n}\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/control_structures/#break-switch-in-for-loop","title":"Break switch in for loop","text":"<p>Sometimes you have to break a for loop. But <code>break</code> inside a switch would result in breaking the switch scope and not the for loop. In that case you can use labels to break explicitly the loop.</p> <pre><code>func main () {\nfor i := 0; i &lt; 10; i++ {\nswitch {\ncase i%2 == 0:\nfmt.Println(i, \"is even\")\ncase i%3 == 0:\nfmt.Println(i, \"is divisible by 3\")\ncase i%7 == 0:\nfmt.Println(\"exit\")\nbreak\ndefault:\nfmt.Println(\"don't know what to do\")\n}\n}\n}\n</code></pre> <p>output:</p> <pre><code>0 is even\ndon't know what to do\n2 is even\n3 is divisible by 3\n4 is even\ndon't know what to do\n6 is even\nexit\n8 is even\n9 is divisible by 3\n</code></pre> <p>We can fix that by using labeled for loops:</p> <pre><code>func main () {\nouter:\nfor i := 0; i &lt; 10; i++ {\nswitch {\ncase i%2 == 0:\nfmt.Println(i, \"is even\")\ncase i%3 == 0:\nfmt.Println(i, \"is divisible by 3\")\ncase i%7 == 0:\nfmt.Println(\"exit\")\nbreak outer\ndefault:\nfmt.Println(\"don't know what to do\")\n}\n}\n}\n</code></pre> <p>output:</p> <pre><code>0 is even\ndon't know what to do\n2 is even\n3 is divisible by 3\n4 is even\ndon't know what to do\n6 is even\nexit\n</code></pre>"},{"location":"golang/golang-fundamentals/control_structures/#blank-switches","title":"Blank Switches","text":"<p>You can use a variable to switch on the value of it or use a blank switch to switch for boolean expression:</p> <pre><code>n := 2\nswitch n {\ncase 2:\nfmt.Println(\"n is two\")\ndefault:\nfmt.Println(\"n is not two\")\n}\n</code></pre> <pre><code>n := 2\nswitch {\ncase n == 2:\nfmt.Println(\"n is two\")\ndefault:\nfmt.Println(\"n is not two\")\n}\n</code></pre> <p>Surely the first one is more explicit.</p>"},{"location":"golang/golang-fundamentals/control_structures/#goto","title":"goto","text":"<p>Go has the support to use <code>goto</code> statements. You will probably never use goto, but I will show an example here anyway:</p> <pre><code>func main() {\na := 10\ngoto skip\nb := 20\nskip:\nc := 30\nfmt.Println(a, b, c)\nif c &gt; a {\ngoto inner\n}\nif a &lt; b {\ninner:\nfmt.Println(\"a is less than b\")\n}\n}\n</code></pre> <p>output:</p> <pre><code>./prog.go:9:10: goto skip jumps over declaration of b at ./prog.go:10:7\n./prog.go:18:14: goto inner jumps into block starting at ./prog.go:21:14\n</code></pre>"},{"location":"golang/golang-fundamentals/errors/","title":"Errors","text":"<p>Handling errors in Go can lead to a strange feeling, the concepts in Go are pretty well-thought. A lot of programmers might</p>"},{"location":"golang/golang-fundamentals/errors/#handling-errors","title":"Handling Errors","text":"<p>If a programm calculates an error or comes in an error state, the specific function should return an error. It is absolute convention to return the error as last return value and let it nil, if there is no error. Use the package <code>errors</code> to create new errors or wrap them.</p> <pre><code>import (\n\"errors\"\n\"fmt\"\n)\nfunc divide(dividend float64, divisor float64) (float64, error) {\nif divisor == 0 {\nreturn 0, errors.New(\"divisor is 0\")\n}\nreturn dividend / divisor, nil\n}\nfunc main() {\nresult, err := divide(12, 0)\nif err != nil {\nfmt.Println(err)\nreturn\n}\nfmt.Println(result)\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/errors/#the-error-interface","title":"The error interface","text":"<p><code>error</code> is a built-in interface which is quiet simple (link):</p> <pre><code>type error interface {\nError() string\n}\n</code></pre> <p>That's why we can return <code>nil</code> for an error, because it's an interface type.</p>"},{"location":"golang/golang-fundamentals/errors/#simple-errors-strings","title":"Simple Errors: Strings","text":"<p>In Go you can create errors with two built-in libraries: <code>error</code> and <code>fmt</code>.</p> <p>Here is an example:</p> <pre><code>import \"errors\"\nfunc divide(dividend float64, divisor float64) (float64, error) {\nif divisor == 0 {\nreturn 0, errors.New(\"divisor is 0\")\n}\nreturn dividend / divisor, nil\n}\n</code></pre> <p>or if you need some data in the error string:</p> <pre><code>import \"fmt\"\nfunc divide(dividend float64, divisor float64) (float64, error) {\nif divisor == 0 {\nreturn 0, fmt.Errorf(\"divisor is %d\", divisor)\n}\nreturn dividend / divisor, nil\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/errors/#sentinel-errors","title":"Sentinel Errors","text":"<p>Sentinel Errors are constants defined for a whole package (we will talk about packages later). It's convention to start the name with <code>Err</code>.</p> <p>Let's see an example:</p> <pre><code>type CustomError string\nfunc (ce CustomerError) Error() string {\nreturn string(ce)\n}\nconst (\nErrFileNotFound CustomError(\"File was not found\")\nErrFileCorrupted CustomError(\"File is corrupted\")\n)\n</code></pre>"},{"location":"golang/golang-fundamentals/errors/#errors-with-data","title":"Errors with data","text":"<p>Since <code>error</code> is an interface, you can create your own struct to hold more data than just a string. Please mark, that you always return <code>error</code> type and do not specifiy a specific type <code>StatusError</code> because this would minimize abstraction.</p> <p>Let's look at following example:</p> <pre><code>type Status int\nconst (\nInvalidLogin Status = iota + 1\nNotFound\n)\ntype StatusError struct {\nStatus  Status\nMessage string\n}\nfunc (se StatusError) Error() string {\nreturn se.Message\n}\nfunc Login(username string, password string) User, error {\nloginService := LoginService{}\nuserService := UserService{}\nid, err := loginService.login(username, password)\nif err != nil {\nreturn User{}, StatusError{\nStatus: InvalidLogin,\nMessage: err.Error(),\n}\n}\nuser, err := userService.User(id)\nif err != nil {\nreturn User{}, StatusError{\nStatus: NotFound,\nMessage: err.Error(),\n}\n}\nreturn user, nil\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/errors/#wrapping-errors","title":"Wrapping Errors","text":"<p>Sometimes you want to add additional information to an error, for example the location where the error happened. There is a builtin function called <code>fmt.Errorf</code> with the special verb <code>%w</code> to add an error into an error string.</p> <p>With another built-in library you can 'unwrap' the error from another one. It's called <code>errors.Unwrap</code>. It will return an <code>error</code> if it unwraps an error, otherwise <code>nil</code>.</p> <p>Let's see an example:</p> <pre><code>package main\nimport (\n\"errors\"\n\"fmt\"\n\"os\"\n)\nfunc fileChecker(name string) error {\nf, err := os.Open(name)\nif err != nil {\nreturn fmt.Errorf(\"in fileChecker: %w\", err)\n}\nf.Close()\nreturn nil\n}\nfunc main() {\nerr := fileChecker(\"doesNotExist.txt\")\nif err != nil {\nfmt.Println(err)\nif wrappedErr := errors.Unwrap(err); wrappedErr != nil {\nfmt.Println(wrappedErr)\n}\n}\n}\n</code></pre> <p>output:</p> <pre><code>in fileChecker: open doesNotExist.txt: no such file or directory\nopen doesNotExist.txt: no such file or directory\n</code></pre>"},{"location":"golang/golang-fundamentals/errors/#error-is-error-as","title":"Error Is, Error As","text":"<p>Multiple Wrapped Errors \"hide\" the errors they wrapped. There is a solution to check, if an error variable wrapped another error.</p> <p>Let's use our fileChecker example again:</p> <pre><code>package main\nimport (\n\"errors\"\n\"fmt\"\n\"os\"\n)\nfunc fileChecker(name string) error {\nf, err := os.Open(name)\nif err != nil {\nreturn fmt.Errorf(\"in fileChecker: %w\", err)\n}\nf.Close()\nreturn nil\n}\nfunc main() {\nerr := fileChecker(\"doesNotExist.txt\")\nif err != nil {\nfmt.Println(err)\nif errors.Is(err, os.ErrNotExist) {\nfmt.Println(\"The file does not exist\")\n}\n}\n}\n</code></pre> <p>With <code>errors.As</code> you can check, if an <code>error</code> has a custom error type:</p> <pre><code>package main\nimport (\n\"errors\"\n\"fmt\"\n\"os\"\n)\ntype FileCheckerError struct {\nname string\nerr  error\n}\nfunc (fce FileCheckerError) Error() string {\nreturn fmt.Sprintf(\"FileCheckerError %s: %s\", fce.name, fce.err)\n}\nfunc fileChecker(name string) error {\nf, err := os.Open(name)\nif err != nil {\nreturn FileCheckerError{\nname: name,\nerr:  err,\n}\n}\nf.Close()\nreturn nil\n}\nfunc main() {\nerr := fileChecker(\"doesNotExist.txt\")\nif err != nil {\nvar fileCheckerError FileCheckerError\nif errors.As(err, &amp;fileCheckerError) {\nfmt.Println(fileCheckerError)\n} else {\nfmt.Println(err)\n}\n}\n}\n</code></pre> <p>output:</p> <pre><code>FileCheckerError doesNotExist.txt: open doesNotExist.txt: no such file or directory\n</code></pre>"},{"location":"golang/golang-fundamentals/errors/#panic-and-recover","title":"panic and recover","text":"<p>Go programms run into panic when there is a state, where the Go programm does not know how to handle it. For example if the programm runs out of memory or if you accessed a slice past it's index.</p> <p>Let's check an example:</p> <pre><code>func doPanic(msg string) {\npanic(msg)\n}\nfunc main() {\ndoPanic(\"What is happening?\")\n}\n</code></pre> <p>output:</p> <pre><code>panic: What is happening?\n\ngoroutine 1 [running]:\nmain.doPanic(...)\n    /tmp/sandbox1809318792/prog.go:4\nmain.main()\n    /tmp/sandbox1809318792/prog.go:8 +0x34\n\nProgram exited.\n</code></pre> <p>You can <code>recover</code> from a panic. Call <code>recover</code> in a defer function, if recover returns the value of the given panic value, then you can handle the panic and the programm proceeds normaly:</p> <pre><code>func div60(i int) {\ndefer func() {\nif v := recover(); v != nil {\nfmt.Println(v)\n}\n}()\nfmt.Println(60 / i)\n}\nfunc main() {\nfor _, val := range []int{1, 2, 0, 6} {\ndiv60(val)\n}\n}\n</code></pre> <p>output is:</p> <pre><code>60\n30\nruntime error: integer divide by zero\n10\n</code></pre> <p>Panic and Recover look like exception handling, but they are not. A panic indicates a really problematical state and should'nt be abused. Therefore use panic and especially recover if you really know what you are doing!</p>"},{"location":"golang/golang-fundamentals/errors/#stacktrace-from-errors","title":"Stacktrace from Errors","text":"<p>Sometimes you want to see, where your error happened. For that you can just print out the error with the verb <code>%+v</code>.</p> <p>Here is an example:</p> <pre><code>func divide(dividend float64, divisor float64) (float64, error) {\nif divisor == 0 {\nreturn 0, fmt.Errorf(\"divisor is %d\", divisor)\n}\nreturn dividend / divisor, nil\n}\nfunc main() {\nerr := divide(10, 0)\nif err != nil {\nfmt.Printf(\"%+v\", err)\n}\n}\n</code></pre> <p>the output would be:</p> <pre><code>./prog.go:13:9: assignment mismatch: 1 variable but divide returns 2 values\n</code></pre>"},{"location":"golang/golang-fundamentals/functions/","title":"Functions","text":"<p>Functions are defined with the <code>func</code> keyword, then the function name, input parameters and their types and the return types.</p> <pre><code>func sum(a int, b int) int {\nreturn a + b\n}\n</code></pre> <p>There can be also functions without parameters and return types like the main function:</p> <pre><code>func main() {\nfmt.Println(\"Hello World\")\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/functions/#named-and-optional-parameters","title":"Named and Optional Parameters","text":"<p>Go doesn't have named and optional parameters. If you want to simulate such a feature, you have create a struct for that. When you want to explicitly set a value to nil, you should use Pointers (Zero Value vs. No Value).</p> <pre><code>type Options struct {\na   int\nb   int\n}\nfunc sum(options Options) int {\nreturn options.a + options.b\n}\nfunc main() {\nfmt.Println(sum(Options{a: 1}))\nfmt.Println(sum(Options{b: 2}))\nfmt.Println(sum(Options{a: 1, b: 2}))\n}\n</code></pre> <p>output:</p> <pre><code>1\n2\n3\n</code></pre>"},{"location":"golang/golang-fundamentals/functions/#variadic-input-parameters-and-slices","title":"Variadic Input Parameters and Slices","text":"<p>Go supports variadic parametes. Which means, that you can pass an undefined number of parameters of the same type into a function and it will be stored as a slice of the specified parameter type. Let's have a look at variadic functions:</p> <pre><code>func sum(values ...int) int {\nvar result int\nfor _, value := range values {\nresult += value\n}\nreturn result\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/functions/#multiple-return-values","title":"Multiple Return Values","text":"<p>Go allows multiple return values. It works nearly the same way as in Python.</p> <p>Let's check an example:</p> <pre><code>func divAndRemainder(numerator int, denominator int) (int, int, error) {\nif denominator == 0 {\nreturn 0, 0, errors.New(\"cannot divide by zero\")\n}\nreturn numerator / denominator, numerator % denominator, nil\n}\nfunc main () {\nresult, remainder, err := divAndRemainder(7, 4)\nif err != nil {\nfmt.Println(err)\nos.Exit(1)\n}\nfmt.Println(result, remainder)\n}\n</code></pre> <p>Danger</p> <p>You cannot assign multiple return values to one variable.</p> <pre><code>func divAndRemainder(numerator int, denominator int) (int, int, error) {\nif denominator == 0 {\nreturn 0, 0, errors.New(\"cannot divide by zero\")\n}\nreturn numerator / denominator, numerator % denominator, nil\n}\nfunc main () {\nresults := divAndRemainder(7, 4)\n}\n</code></pre> <p>output:</p> <pre><code>./prog.go:18:13: assignment mismatch: 1 variable but divAndRemainder returns 3 values\n</code></pre>"},{"location":"golang/golang-fundamentals/functions/#ignoring-return-values","title":"Ignoring Return Values","text":"<p>Surely you can use <code>_</code> to ignore are value as in variable declarations:</p> <pre><code>func divAndRemainder(numerator int, denominator int) (int, int, error) {\nif denominator == 0 {\nreturn 0, 0, errors.New(\"cannot divide by zero\")\n}\nreturn numerator / denominator, numerator % denominator, nil\n}\nfunc main () {\nresult, _, err := divAndRemainder(7, 4)\nif err != nil {\nfmt.Println(err)\nos.Exit(1)\n}\nfmt.Println(result)\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/functions/#named-return-values","title":"Named Return Values","text":"<p>You can use named return values to predeclare variables, which can be used inside of the function to return them later. Those variables will be initialized with zero values, therefore you can return them directly without overwriting the value.</p> <p>Let's check an example:</p> <pre><code>func divAndRemainder(numerator int, denominator int) (result int, remainder int, err error) {\nif denominator == 0 {\nerr = errors.New(\"cannot divide by zero\")\nreturn result, remainder, err\n}\nresult = numerator / denominator\nremainder = numerator % denominator\nreturn result, remainder, err\n}\nfunc main () {\nresult, _, err := divAndRemainder(7, 4)\nif err != nil {\nfmt.Println(err)\nos.Exit(1)\n}\nfmt.Println(result)\n}\n</code></pre> <p>You don't have to return the specified named return values but be careful. If you specified named return values, then you can use <code>return</code>, but you should never ever do this.</p>"},{"location":"golang/golang-fundamentals/functions/#functions-are-values","title":"Functions are values","text":"<p>As in other languages functions are values. Therefore you can store functions in variables and work with them.</p> <pre><code>package main\nimport (\n\"fmt\"\n\"strconv\"\n)\nfunc add(i int, j int) int {\nreturn i + j\n}\nfunc sub(i int, j int) int {\nreturn i - j\n}\nfunc mult(i int, j int) int {\nreturn i * j\n}\nfunc div(i int, j int) int {\nreturn i / j\n}\nvar operatorMap = map[string]func(int, int) int{\n\"+\": add,\n\"-\": sub,\n\"*\": mult,\n\"/\": div,\n}\nfunc main() {\noperations := [][]string{{\"2\", \"+\", \"4\"}, {\"43\", \"-\", \"17\"}}\nfor _, operation := range operations {\nn1, err := strconv.Atoi(operation[0])\nif err != nil {\nfmt.Println(err)\ncontinue\n}\noperatorFunc, ok := operatorMap[operation[1]]\nif !ok {\nfmt.Println(\"unsupported operator: \", operation[1])\ncontinue\n}\nn2, err := strconv.Atoi(operation[2])\nif err != nil {\nfmt.Println(err)\ncontinue\n}\nresult := operatorFunc(n1, n2)\nfmt.Println(result)\n}\n}\n</code></pre> <p>output:</p> <pre><code>6\n26\n</code></pre>"},{"location":"golang/golang-fundamentals/functions/#function-type-declarations","title":"Function Type Declarations","text":"<p>As we see in Functions are values you can use functions in variables. But to use a function as variable you have to define the type of the function. In Go you can define a function as type. Let's look at the following example:</p> <pre><code>type operatorFunction func(int, int) int\nvar operatorMap = map[string]operatorFunction {\n\"+\": add,\n\"-\": sub,\n\"*\": mult,\n\"/\": div,\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/functions/#anonymous-functions","title":"Anonymous functions","text":"<p>Anonymous functions can be declared right in the middle of you code. You can declare and call the function directly. Let's face an example:</p> <pre><code>func main() {\na := 1\nb := 3\nsum := func (a int, b int) int {\nreturn a + b\n}(a, b)\nfmt.Println(sum)\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/functions/#passing-functions-as-parameters","title":"Passing Functions as Parameters","text":"<p>Anonymous functions can be passed as parameters. The interesting thing is here, that those <code>functions inside of a function</code> create a <code>closure</code>. Which means, that the inner anonymous function can access and modify variables in the outer function. Let's see an example:</p> <pre><code>type Cat struct {\nName   string\nAge    int\n}\ncats := []Cat{\n{\"Mitsu\", 2},\n{\"Yuki\", 1},\n{\"Fred\", 12},\n{\"Bob\", 8},\n}\nfmt.Println(cats)\nsort.Slice(cats, func (i int, j int) bool {\nreturn cats[i].Age &lt; cats[j].Age\n})\nfmt.Println(cats)\n</code></pre> <p>output:</p> <pre><code>[{Mitsu 2} {Yuki 1} {Fred 12} {Bob 8}]\n[{Yuki 1} {Mitsu 2} {Bob 8} {Fred 12}]\n</code></pre>"},{"location":"golang/golang-fundamentals/functions/#defer","title":"defer","text":"<p>Since Go has no try-catch-finally keywords, we need some kind of functionality, to \"cleanup\" things or to run commands, even when everything breaks. In Go you use defer and pass a function call:</p> <pre><code>import (\n\"fmt\"\n)\nfunc main() {\ndefer func() {\nfmt.Println(\"Closing\")\n}()\na := 1\nb := 2\nfmt.Println(\"Sum is: \", a+b)\n}\n</code></pre> <p>Most of the time, you will use defer cleanup open sockets, file handlers or similar.</p> <p>Since defer can be a anonymous function, you can use it to read or set variables after the outer function has been executed.</p> <pre><code>import (\n\"fmt\"\n)\nfunc outer(a int, b int) (result int) {\ndefer func() {\na = 10\nresult = a + b\nfmt.Println(\"Closing function\")\n}()\nreturn result\n}\nfunc main() {\nresult := outer(1, 2)\nfmt.Println(\"Sum is: \", result)\n}\n</code></pre> <p>output would be:</p> <pre><code>Closing function\nSum is:  12\n</code></pre> <p>There is a pattern in Go, which you will find quiet often. A function that allocates a resource and returns a \"cleanup\" function, to free the resource again:</p> <pre><code>func getFile(name string) (*os.File, func(), error) {\nfile, err := os.Open(name)\nif err != nil {\nreturn nil, nil, err\n}\nreturn file, func() {\nfile.Close()\n}, nil\n}\nf, closer, err := getFile(os.Args[1])\nif err != nil {\nlog.Fatal(err)\n}\ndefer closer()\n</code></pre>"},{"location":"golang/golang-fundamentals/functions/#go-is-call-by-value","title":"Go is Call by Value","text":"<p>Go is call by value. If you pass a variable into a function and modify it within the function it will modify a <code>copied</code> value and not the passed in value itself. Let's check:</p> <pre><code>type person struct {\nage  int\nname string\n}\nfunc modify(number int, value string, person person) {\nnumber = 123\nvalue = \"Blah\"\nperson.name = \"Test\"\n}\nfunc main() {\nnumber := 321\nvalue := \"Test\"\nperson := person{\nage:  28,\nname: \"Michael\",\n}\nfmt.Println(number, value, person)\nmodify(number, value, person)\nfmt.Println(number, value, person)\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/generics/","title":"Generics","text":"<p>Generics can be used, if you want to do similar operations with the same function, but you have different variable types.</p> <p>Let's check an example first:</p> <pre><code>// SumInts adds together the values of m.\nfunc SumInts(m map[string]int64) int64 {\nvar s int64\nfor _, v := range m {\ns += v\n}\nreturn s\n}\n// SumFloats adds together the values of m.\nfunc SumFloats(m map[string]float64) float64 {\nvar s float64\nfor _, v := range m {\ns += v\n}\nreturn s\n}\nfunc main() {\n// Initialize a map for the integer values\nints := map[string]int64{\n\"first\":  34,\n\"second\": 12,\n}\n// Initialize a map for the float values\nfloats := map[string]float64{\n\"first\":  35.98,\n\"second\": 26.99,\n}\nfmt.Printf(\"Non-Generic Sums: %v and %v\\n\",\nSumInts(ints),\nSumFloats(floats))\n}\n</code></pre> <p>output:</p> <pre><code>Non-Generic Sums: 46 and 62.97\n</code></pre> <p>Now let's transform the function into a generic one:</p> <pre><code>func SumIntsOrFloats[K comparable, V int64 | float64](m map[K]V) V {\nvar s V\nfor _, v := range m {\ns += v\n}\nreturn s\n}\nfunc main() {\n// Initialize a map for the integer values\nints := map[string]int64{\n\"first\":  34,\n\"second\": 12,\n}\n// Initialize a map for the float values\nfloats := map[string]float64{\n\"first\":  35.98,\n\"second\": 26.99,\n}\nfmt.Printf(\"Generic Sums: %v and %v\\n\",\nSumIntsOrFloats(ints),\nSumIntsOrFloats(floats))\n}\n</code></pre> <p>output:</p> <pre><code>Generic Sums: 46 and 62.97\n</code></pre>"},{"location":"golang/golang-fundamentals/generics/#type-constraints","title":"Type Constraints","text":"<p>We can define type constraints by defining new interfaces and use interface embedding.</p> <p>For example we define:</p> <pre><code>type Number interface {\nint64 | float64\n}\n</code></pre> <p>now we can use:</p> <pre><code>func SumNumbers[K comparable, V Number](m map[K]V) V {\nvar s V\nfor _, v := range m {\ns += v\n}\nreturn s\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/generics/#underlying-types","title":"Underlying Types","text":"<p>Sometimes you define a user-defined type, but don't want to add your type to a generic function, which takes in just <code>primitive</code> types. Therefore just use underlying types:</p> <pre><code>type Number interface {\nint | int8 | int16 | int32 | int64\n}\ntype MySpecialNumber int32\nfunc Sum[V Number](a V, b V) V {\nreturn a + b\n}\nfunc main() {\nvar a MySpecialNumber = 1\nvar b MySpecialNumber = 2\nfmt.Println(Sum(a, b))\n}\n</code></pre> <p>makes the error:</p> <pre><code>MySpecialNumber does not implement Number (possibly missing ~ for int32 in constraint Number)\n</code></pre> <p>So what you need here is <code>underlying types</code> so that you allow any user-defined types, which use the underlying type. Use <code>~</code> to make the type underlying.</p> <p>Here is a fixed example:</p> <pre><code>type Number interface {\n~int | ~int8 | ~int16 | ~int32 | ~int64\n}\ntype MySpecialNumber int32\nfunc Sum[V Number](a V, b V) V {\nreturn a + b\n}\nfunc main() {\nvar a MySpecialNumber = 1\nvar b MySpecialNumber = 2\nfmt.Println(Sum(a, b))\n}\n</code></pre> <p>Warning</p> <p>You cannot use underlying types with user-defined types. You have to use a primitive type!</p>"},{"location":"golang/golang-fundamentals/generics/#which-types","title":"Which Types?","text":"<p>You can use built-in types for generics, but also interfaces:</p> <pre><code>type Stringer interface {\nString() string\n}\nfunc Join[E Stringer](things []E) string {\nvar result string\nfor _, value := range things {\nresult += value.String()\n}\nreturn result\n}\n</code></pre> <p>There are also new keywords invented for generics like: <code>any</code> and <code>comparable</code></p>"},{"location":"golang/golang-fundamentals/generics/#constraints-package","title":"Constraints Package","text":"<p>The constraints package provides some useful interfaces to use for Generics. For example</p>"},{"location":"golang/golang-fundamentals/generics/#user-defined-generic-types","title":"User defined generic types","text":"<p>We can also define user-defined generic types.</p> <p>Check the example here:</p> <pre><code>type Bunch[E any] []E\nvar myBunch := Bunch[int]{1, 2, 3}\n</code></pre> <p>Also you can use the <code>Bunch</code> now as parameter type:</p> <pre><code>type Bunch[E any] []E\nfunc PrintBunch[E any](bunch Bunch[E]) {\n//...\n}\nfunc [b Bunch[E]] Print() {\n// ...\n}\n</code></pre> <p>or as a struct:</p> <pre><code>type List[T any] struct {\nnext  *List[T]\nvalue T\n}\nfunc main() {\nmyList := List[int]{value: 2}\nfmt.Println(myList)\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/grammar/","title":"Grammar","text":""},{"location":"golang/golang-fundamentals/grammar/#introduction","title":"Introduction","text":""},{"location":"golang/golang-fundamentals/grammar/#comments","title":"Comments","text":"<ol> <li>Line comments start with the character sequence <code>//</code> and stop at the end of the line.</li> <li>General comments start with the character sequence <code>/*</code> and stop with the first subsequent character sequence <code>*/</code>.</li> </ol> <p>A comment cannot start inside a rune or string literal, or inside a comment. A general comment containing no newlines acts like a space. Any other comment acts like a newline.</p> <pre><code>package main\nimport \"fmt\"\nfunc main() {\n/* This is a multi line comment.\n    You can type within this section */\nfmt.Println(\"Go!\")\n// single line comment\nfmt.Println(\"Lang!\")\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/grammar/#semicolons","title":"Semicolons","text":"<p>Semicolons in Go are added automatically by the compiler in Go. They are added between the following token and a newline: </p> <ul> <li>An identifier (includes words like int, float64)</li> <li>A basic literal (a number or a string constant)</li> <li>One of the tokens: <code>break</code>, <code>continue</code>, <code>fallthrough</code>, <code>return</code>, <code>++</code>, <code>--</code>, <code>)</code> or <code>}</code></li> </ul> <p>This rule makes it easy to check if a code works imaginary. Check the following code:</p> <pre><code>func main()\n{\nfmt.Println(\"Hello World!\")\n}\n</code></pre> <p>With the rules from above it would prerpend a semicolon to the <code>)</code> at the end of line 1.</p> <pre><code>func main();\n{\nfmt.Println(\"Hello World!\");\n}\n</code></pre> <p>This is not valid Go code and would result in in a compiler error.</p>"},{"location":"golang/golang-fundamentals/grammar/#identifiers","title":"Identifiers","text":"<p>Identifiers name program entities such as variables and types. An identifier is a sequence of one or more letters and digits. The first character in an identifier must be a letter.</p> <pre><code>identifier = letter { letter | unicode_digit } .\n</code></pre> <pre><code>a\n_x9\nThisVariableIsExported\n\u03b1\u03b2\n</code></pre>"},{"location":"golang/golang-fundamentals/grammar/#blank-identifier","title":"Blank Identifier","text":"<p>There is one special identifier called the <code>blank identifier</code>.</p> <p>This identifier let's you assign every value to it, but you can never read from it: </p> <p><pre><code>var _ = 2\n</code></pre> It's often used to \"throw away\" values or to test a specific type over another. You will see in the next chapters, why we need this.</p> <p>Some identifiers are predeclared, you will find them in the next chapter Keywords.</p>"},{"location":"golang/golang-fundamentals/grammar/#keywords","title":"Keywords","text":"<p>The following keywords are reserved and may not be used as identifiers.</p> <pre><code>break        default      func         interface    select\ncase         defer        go           map          struct\nchan         else         goto         package      switch\nconst        fallthrough  if           range        type\ncontinue     for          import       return       var\n</code></pre>"},{"location":"golang/golang-fundamentals/grammar/#types","title":"Types","text":"<pre><code>any bool byte comparable\ncomplex64 complex128 error float32 float64\nint int8 int16 int32 int64 rune string\nuint uint8 uint16 uint32 uint64 uintptr\n</code></pre>"},{"location":"golang/golang-fundamentals/grammar/#constants","title":"Constants","text":"<p><code>true false iota</code></p> <p>Zero value:</p> <p><code>nil</code></p>"},{"location":"golang/golang-fundamentals/grammar/#functions","title":"Functions","text":"<pre><code>append cap close complex copy delete imag len\nmake new panic print println real recover\n</code></pre>"},{"location":"golang/golang-fundamentals/grammar/#operators-and-punctuation","title":"Operators and punctuation","text":"<p>Following operators, assignment operators and puctuation is defined in Go.</p> <pre><code>+    &amp;     +=    &amp;=     &amp;&amp;    ==    !=    (    )\n-    |     -=    |=     ||    &lt;     &lt;=    [    ]\n*    ^     *=    ^=     &lt;-    &gt;     &gt;=    {    }\n/    &lt;&lt;    /=    &lt;&lt;=    ++    =     :=    ,    ;\n%    &gt;&gt;    %=    &gt;&gt;=    --    !     ...   .    :\n     &amp;^          &amp;^=          ~\n</code></pre>"},{"location":"golang/golang-fundamentals/grammar/#integer-literals","title":"Integer literals","text":"<p>An integer literal is a sequence of digits representing an integer constant. An optional prefix sets a non-decimal base: 0b or 0B for binary, 0, 0o, or 0O for octal, and 0x or 0X for hexadecimal. A single 0 is considered a decimal zero. In hexadecimal literals, letters a through f and A through F represent values 10 through 15.</p> <p>For readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal's value. </p> <pre><code>int_lit        = decimal_lit | binary_lit | octal_lit | hex_lit .\ndecimal_lit    = \"0\" | ( \"1\" \u2026 \"9\" ) [ [ \"_\" ] decimal_digits ] .\nbinary_lit     = \"0\" ( \"b\" | \"B\" ) [ \"_\" ] binary_digits .\noctal_lit      = \"0\" [ \"o\" | \"O\" ] [ \"_\" ] octal_digits .\nhex_lit        = \"0\" ( \"x\" | \"X\" ) [ \"_\" ] hex_digits .\n</code></pre> <pre><code>decimal_digits = decimal_digit { [ \"_\" ] decimal_digit } .\nbinary_digits  = binary_digit { [ \"_\" ] binary_digit } .\noctal_digits   = octal_digit { [ \"_\" ] octal_digit } .\nhex_digits     = hex_digit { [ \"_\" ] hex_digit } .\n</code></pre> <pre><code>42\n4_2\n0600\n0_600\n0o600\n0O600       // second character is capital letter 'O'\n0xBadFace\n0xBad_Face\n0x_67_7a_2f_cc_40_c6\n170141183460469231731687303715884105727\n170_141183_460469_231731_687303_715884_105727\n\n_42         // an identifier, not an integer literal\n42_         // invalid: _ must separate successive digits\n4__2        // invalid: only one _ at a time\n0_xBadFace  // invalid: _ must separate successive digits\n</code></pre>"},{"location":"golang/golang-fundamentals/grammar/#floating-point-literals","title":"Floating-point literals","text":"<p>A floating-point literal is a decimal or hexadecimal representation of a floating-point constant.</p> <p>A decimal floating-point literal consists of an integer part (decimal digits), a decimal point, a fractional part (decimal digits), and an exponent part (e or E followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; one of the decimal point or the exponent part may be elided. An exponent value exp scales the mantissa (integer and fractional part) by 10exp.</p> <p>A hexadecimal floating-point literal consists of a 0x or 0X prefix, an integer part (hexadecimal digits), a radix point, a fractional part (hexadecimal digits), and an exponent part (p or P followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; the radix point may be elided as well, but the exponent part is required. (This syntax matches the one given in IEEE 754-2008 \u00a75.12.3.) An exponent value exp scales the mantissa (integer and fractional part) by 2exp.</p> <p>For readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal value.</p> <pre><code>float_lit         = decimal_float_lit | hex_float_lit .\n</code></pre> <pre><code>decimal_float_lit = decimal_digits \".\" [ decimal_digits ] [ decimal_exponent ] |\n                    decimal_digits decimal_exponent |\n                    \".\" decimal_digits [ decimal_exponent ] .\ndecimal_exponent  = ( \"e\" | \"E\" ) [ \"+\" | \"-\" ] decimal_digits .\n</code></pre> <pre><code>hex_float_lit     = \"0\" ( \"x\" | \"X\" ) hex_mantissa hex_exponent .\nhex_mantissa      = [ \"_\" ] hex_digits \".\" [ hex_digits ] |\n                    [ \"_\" ] hex_digits |\n                    \".\" hex_digits .\nhex_exponent      = ( \"p\" | \"P\" ) [ \"+\" | \"-\" ] decimal_digits .\n</code></pre> <pre><code>0.\n72.40\n072.40       // == 72.40\n2.71828\n1.e+0\n6.67428e-11\n1E6\n.25\n.12345E+5\n1_5.         // == 15.0\n0.15e+0_2    // == 15.0\n\n0x1p-2       // == 0.25\n0x2.p10      // == 2048.0\n0x1.Fp+0     // == 1.9375\n0X.8p-0      // == 0.5\n0X_1FFFP-16  // == 0.1249847412109375\n0x15e-2      // == 0x15e - 2 (integer subtraction)\n\n0x.p1        // invalid: mantissa has no digits\n1p-2         // invalid: p exponent requires hexadecimal mantissa\n0x1.5e-2     // invalid: hexadecimal mantissa requires p exponent\n1_.5         // invalid: _ must separate successive digits\n1._5         // invalid: _ must separate successive digits\n1.5_e1       // invalid: _ must separate successive digits\n1.5e_1       // invalid: _ must separate successive digits\n1.5e1_       // invalid: _ must separate successive digits\n</code></pre>"},{"location":"golang/golang-fundamentals/grammar/#imaginary-literals","title":"Imaginary literals","text":"<p>An imaginary literal represents the imaginary part of a complex constant. It consists of an integer or floating-point literal followed by the lower-case letter i. The value of an imaginary literal is the value of the respective integer or floating-point literal multiplied by the imaginary unit i.</p> <pre><code>imaginary_lit = (decimal_digits | int_lit | float_lit) \"i\" .\n</code></pre> <p>For backward compatibility, an imaginary literal's integer part consisting entirely of decimal digits (and possibly underscores) is considered a decimal integer, even if it starts with a leading <code>0</code>.</p> <pre><code>0i\n0123i         // == 123i for backward-compatibility\n0o123i        // == 0o123 * 1i == 83i\n0xabci        // == 0xabc * 1i == 2748i\n0.i\n2.71828i\n1.e+0i\n6.67428e-11i\n1E6i\n.25i\n.12345E+5i\n0x1p-2i       // == 0x1p-2 *\n</code></pre>"},{"location":"golang/golang-fundamentals/grammar/#rune-literals","title":"Rune literals","text":"<p>A rune literal represents a rune constant, an integer value identifying a Unicode code point. A rune literal is expressed as one or more characters enclosed in single quotes, as in 'x' or '\\n'. Within the quotes, any character may appear except newline and unescaped single quote. A single quoted character represents the Unicode value of the character itself, while multi-character sequences beginning with a backslash encode values in various formats.</p> <p>The simplest form represents the single character within the quotes; since Go source text is Unicode characters encoded in UTF-8, multiple UTF-8-encoded bytes may represent a single integer value. For instance, the literal 'a' holds a single byte representing a literal a, Unicode U+0061, value 0x61, while '\u00e4' holds two bytes (0xc3 0xa4) representing a literal a-dieresis, U+00E4, value 0xe4.</p> <p>Several backslash escapes allow arbitrary values to be encoded as ASCII text. There are four ways to represent the integer value as a numeric constant: \\x followed by exactly two hexadecimal digits; \\u followed by exactly four hexadecimal digits; \\U followed by exactly eight hexadecimal digits, and a plain backslash \\ followed by exactly three octal digits. In each case the value of the literal is the value represented by the digits in the corresponding base.</p> <p>Although these representations all result in an integer, they have different valid ranges. Octal escapes must represent a value between 0 and 255 inclusive. Hexadecimal escapes satisfy this condition by construction. The escapes \\u and \\U represent Unicode code points so within them some values are illegal, in particular those above 0x10FFFF and surrogate halves.</p> <p>After a backslash, certain single-character escapes represent special values:</p> <pre><code>\\a   U+0007 alert or bell\n\\b   U+0008 backspace\n\\f   U+000C form feed\n\\n   U+000A line feed or newline\n\\r   U+000D carriage return\n\\t   U+0009 horizontal tab\n\\v   U+000B vertical tab\n\\\\   U+005C backslash\n\\'   U+0027 single quote  (valid escape only within rune literals)\n\\\"   U+0022 double quote  (valid escape only within string literals)\n</code></pre> <p>All other sequences starting with a backslash are illegal inside rune literals.</p> <pre><code>rune_lit         = \"'\" ( unicode_value | byte_value ) \"'\" .\nunicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .\nbyte_value       = octal_byte_value | hex_byte_value .\noctal_byte_value = `\\` octal_digit octal_digit octal_digit .\nhex_byte_value   = `\\` \"x\" hex_digit hex_digit .\nlittle_u_value   = `\\` \"u\" hex_digit hex_digit hex_digit hex_digit .\nbig_u_value      = `\\` \"U\" hex_digit hex_digit hex_digit hex_digit\n                           hex_digit hex_digit hex_digit hex_digit .\nescaped_char     = `\\` ( \"a\" | \"b\" | \"f\" | \"n\" | \"r\" | \"t\" | \"v\" | `\\` | \"'\" | `\"` ) .\n</code></pre> <pre><code>'a'\n'\u00e4'\n'\u672c'\n'\\t'\n'\\000'\n'\\007'\n'\\377'\n'\\x07'\n'\\xff'\n'\\u12e4'\n'\\U00101234'\n'\\''         // rune literal containing single quote character\n'aa'         // illegal: too many characters\n'\\xa'        // illegal: too few hexadecimal digits\n'\\0'         // illegal: too few octal digits\n'\\uDFFF'     // illegal: surrogate half\n'\\U00110000' // illegal: invalid Unicode code point\n</code></pre>"},{"location":"golang/golang-fundamentals/grammar/#string-literals","title":"String literals","text":"<p>A string literal represents a string constant obtained from concatenating a sequence of characters. There are two forms: raw string literals and interpreted string literals.</p> <p>Raw string literals are character sequences between back quotes, as in <code>foo</code>. Within the quotes, any character may appear except back quote. The value of a raw string literal is the string composed of the uninterpreted (implicitly UTF-8-encoded) characters between the quotes; in particular, backslashes have no special meaning and the string may contain newlines. Carriage return characters ('\\r') inside raw string literals are discarded from the raw string value.</p> <p>Interpreted string literals are character sequences between double quotes, as in \"bar\". Within the quotes, any character may appear except newline and unescaped double quote. The text between the quotes forms the value of the literal, with backslash escapes interpreted as they are in rune literals (except that \\' is illegal and \\\" is legal), with the same restrictions. The three-digit octal (\\nnn) and two-digit hexadecimal (\\xnn) escapes represent individual bytes of the resulting string; all other escapes represent the (possibly multi-byte) UTF-8 encoding of individual characters. Thus inside a string literal \\377 and \\xFF represent a single byte of value 0xFF=255, while \u00ff, \\u00FF, \\U000000FF and \\xc3\\xbf represent the two bytes 0xc3 0xbf of the UTF-8 encoding of character U+00FF.</p> <pre><code>string_lit             = raw_string_lit | interpreted_string_lit .\nraw_string_lit         = \"`\" { unicode_char | newline } \"`\" .\ninterpreted_string_lit = `\"` { unicode_value | byte_value } `\"` .\n</code></pre> <pre><code>`abc`                // same as \"abc\"\n`\\n\n\\n`                  // same as \"\\\\n\\n\\\\n\"\n\"\\n\"\n\"\\\"\"                 // same as `\"`\n\"Hello, world!\\n\"\n\"\u65e5\u672c\u8a9e\"\n\"\\u65e5\u672c\\U00008a9e\"\n\"\\xff\\u00FF\"\n\"\\uD800\"             // illegal: surrogate half\n\"\\U00110000\"         // illegal: invalid Unicode code point\n</code></pre> <p>These examples all represent the same string:</p> <pre><code>\"\u65e5\u672c\u8a9e\"                                 // UTF-8 input text\n`\u65e5\u672c\u8a9e`                                 // UTF-8 input text as a raw literal\n\"\\u65e5\\u672c\\u8a9e\"                    // the explicit Unicode code points\n\"\\U000065e5\\U0000672c\\U00008a9e\"        // the explicit Unicode code points\n\"\\xe6\\x97\\xa5\\xe6\\x9c\\xac\\xe8\\xaa\\x9e\"  // the explicit UTF-8 bytes\n</code></pre> <p>If the source code represents a character as two code points, such as a combining form involving an accent and a letter, the result will be an error if placed in a rune literal (it is not a single code point), and will appear as two code points if placed in a string literal. </p>"},{"location":"golang/golang-fundamentals/introduction/","title":"Introduction","text":""},{"location":"golang/golang-fundamentals/introduction/#history","title":"History","text":"<p>The Go programming language was conceived in late 2007 as an answer to some of the problems we were seeing developing software infrastructure at Google. The computing landscape today is almost unrelated to the environment in which the languages being used, mostly C++, Java, and Python, had been created. The problems introduced by multicore processors, networked systems, massive computation clusters, and the web programming model were being worked around rather than addressed head-on. Moreover, the scale has changed: today's server programs comprise tens of millions of lines of code, are worked on by hundreds or even thousands of programmers, and are updated literally every day. To make matters worse, build times, even on large compilation clusters, have stretched to many minutes, even hours.</p> <p>Go was designed and developed to make working in this environment more productive. Besides its better-known aspects such as built-in concurrency and garbage collection, Go's design considerations include rigorous dependency management, the adaptability of software architecture as systems grow, and robustness across the boundaries between components.</p> <p>Source</p> <p>Pain points at Google:</p> <ul> <li>slow builds</li> <li>uncontrolled dependencies</li> <li>each programmer using a different subset of the language</li> <li>poor program understanding (code hard to read, poorly documented, and so on)</li> <li>duplication of effort</li> <li>cost of updates</li> <li>version skew</li> <li>difficulty of writing automatic tools</li> <li>cross-language builds</li> </ul>"},{"location":"golang/golang-fundamentals/introduction/#gopher","title":"Gopher","text":"Original Gopher Funny Gophers from different projects"},{"location":"golang/golang-fundamentals/introduction/#projects-using-golang","title":"Projects using Golang","text":"<ul> <li>Docker</li> <li>Kubernetes</li> <li>Gogs</li> <li>InfluxDB</li> <li>Snappy</li> <li>Minio</li> <li>Mattermost</li> <li>OpenShift</li> <li>Pocketbase</li> </ul>"},{"location":"golang/golang-fundamentals/introduction/#key-benefits","title":"Key Benefits","text":"<p>Deploy across platforms in record speed</p> <p>For enterprises, Go is preferred for providing rapid cross-platform deployment. With its goroutines, native compilation, and the URI-based package namespacing, Go code compiles to a single, small binary\u2014with zero dependencies\u2014making it very fast. Leverage Go\u2019s out-of-the-box performance to scale with ease</p> <p>Tigran Bayburtsyan, Co-Founder and CTO at Hexact Inc., summarizes five key reasons his company switched to Go:</p> <ul> <li>Compiles into a single binary \u2014 \u201cUsing static linking, Go actually combining all dependency libraries and modules into one single binary file based on OS type and architecture.\u201d</li> <li>Static type system \u2014 \u201cType system is really important for large scale applications.\u201d</li> <li>Performance \u2014 \u201cGo performed better because of its concurrency model and CPU scalability. Whenever we need to process some internal request, we are doing it with separate Goroutines which are 10x cheaper in resources than Python Threads.\u201d</li> <li>No need for a web framework \u2014 \u201cIn most of the cases you really don\u2019t need any third-party library.\u201d</li> <li>Great IDE support and debugging \u2014 \u201cAfter rewriting all projects to Go, we got 64 percent less code than we had earlier.\u201d</li> </ul>"},{"location":"golang/golang-fundamentals/introduction/#the-good","title":"The good","text":"<ul> <li>Simplicity</li> <li>Fast</li> <li>Built-in Build and Package Management</li> <li>Type Switch</li> <li>Concurrency</li> <li>Values vs Pointers</li> </ul>"},{"location":"golang/golang-fundamentals/introduction/#simplicity","title":"Simplicity","text":"<p>Go aims to be a simple programming language. It has a minimal set of language constructs. It makes simple project and package module structures possible. The visibility control only relies on public or private exports. Data Structures can be easily defined by just a few possibilities: Structs, Maps, Arrays. Testing is very easy in Golang, thanks to built-in commands and libraries.</p>"},{"location":"golang/golang-fundamentals/introduction/#fast","title":"Fast","text":"<p>Go programs being compiled down to machine code, and having a static type system, makes it really fast during the execution. Also, the startup time is much less than to something like Java or any JVM language.</p>"},{"location":"golang/golang-fundamentals/introduction/#built-in-build-and-package-management","title":"Built-in Build and Package Management","text":"<p>Golang has a built-in build and package management what makes it easy to maintain packages. This eliminates the requirement for a third-party package and build management systems like Gradle, Maven, make, etc., and makes life so much easier for developers.</p>"},{"location":"golang/golang-fundamentals/introduction/#type-switch","title":"Type Switch","text":"<p>In Golang it's possible to do easy type switches instead of doing expensive operations like <code>instanceof</code> (Java).</p>"},{"location":"golang/golang-fundamentals/introduction/#visibility-control","title":"Visibility Control","text":"<p>Visibility Control can be managed by using public or private variables, constants, and methods.</p>"},{"location":"golang/golang-fundamentals/introduction/#concurrency","title":"Concurrency","text":"<p>Golangs concurrency model is really simple. Goroutines make it possible to start a managed concurrency model.</p>"},{"location":"golang/golang-fundamentals/introduction/#values-vs-pointers","title":"Values vs. Pointers","text":"<p>Go supports pass-by-value and pass-by-reference.</p>"},{"location":"golang/golang-fundamentals/introduction/#the-bad","title":"The bad","text":"<ul> <li>No Constructors</li> <li>Error Checking</li> <li>Confusing Design</li> <li>No Generics</li> <li>(No Inheritance)</li> </ul>"},{"location":"golang/golang-fundamentals/introduction/#no-constructors","title":"No constructors","text":"<p>In Golang there are no constructors, you have to write constructors for structs by yourself.</p>"},{"location":"golang/golang-fundamentals/introduction/#error-checking","title":"Error Checking","text":"<p>Each and every error has to be checked.</p>"},{"location":"golang/golang-fundamentals/introduction/#confusing-design","title":"Confusing Design","text":"<p>There are some patterns, like the public/private concept and error handling and many more, which can confuse the first time.</p>"},{"location":"golang/golang-fundamentals/introduction/#no-generics","title":"No Generics","text":"<p>This isn't true anymore :)</p>"},{"location":"golang/golang-fundamentals/introduction/#no-inheritance","title":"No Inheritance","text":"<p>There is a lot of rumor about Golang, that it does not support inheritance. This is not really correct, it actually has a concept for that, which is called embedding. But it just differs from known concepts about inheritance.</p>"},{"location":"golang/golang-fundamentals/introduction/#which-ide-to-choose","title":"Which IDE to choose?","text":"<ul> <li>Jetbrains Goland - paid, preferred</li> <li>VSCode - free<ul> <li>Go Extension - free</li> </ul> </li> </ul>"},{"location":"golang/golang-fundamentals/introduction/#installation","title":"Installation","text":"<p>To install Golang simply see: go.dev / Download and install</p> <p>Mac users can install golang with brew: <code>brew install go</code></p> <p>Windows users can install golang with Chocolatey: <code>choco install golang</code></p>"},{"location":"golang/golang-fundamentals/introduction/#hello-world","title":"Hello World!","text":"main.go<pre><code>package main\nimport \"fmt\"\nfunc main() {\nfmt.Println(\"Hello World!\")\n}\n</code></pre> <p>To build and run it, simply run: <code>go run main.go</code></p>"},{"location":"golang/golang-fundamentals/introduction/#playground","title":"Playground","text":"<p>You can always use Go Playground to play around with go or just use it as \"REPL\" editor.</p>"},{"location":"golang/golang-fundamentals/introduction/#is-it-go-or-golang","title":"Is it \"Go\" or \"Golang\"?","text":"<p>Usually you say: \"Go\".</p> <p>This is the official name of the programming language.</p> <p>The only reason why some people say \"Golang\" is, because it helps to identify the term more as programming language and to use it as google query. Also the first domain was reserved for golang.com but now it became go.dev.</p>"},{"location":"golang/golang-fundamentals/introduction/#books-and-sources","title":"Books and Sources","text":"<ul> <li>Effective Go</li> <li>Learning Go</li> <li>The Go Programming Language</li> <li>Go by Example</li> <li>Go Cookbook</li> </ul>"},{"location":"golang/golang-fundamentals/logging/","title":"Logging","text":"<p>To use logging the <code>log</code> package provides a standard logger, which prints to the systems <code>Standard out</code>. Source</p> <p>The documentation says:</p> <p>Package log implements a simple logging package. It defines a type, Logger, with methods for formatting output. It also has a predefined 'standard' Logger accessible through helper functions Print[f|ln], Fatal[f|ln], and Panic[f|ln], which are easier to use than creating a Logger manually. That logger writes to standard error and prints the date and time of each logged message. Every log message is output on a separate line: if the message being printed does not end in a newline, the logger will add one. The Fatal functions call os.Exit(1) after writing the log message. The Panic functions call panic after writing the log message.</p> <p>So if you want to use the default logger, here is an example:</p> <pre><code>func main () {\na := 2\nlogger := log.Default()\nlogger.Print(\"Just print a string \", a)\nlogger.Printf(\"print a digit: %d\", a)\nlogger.Fatal(\"print and os.Exit(1)\")\nlogger.Panic(\"print and panic\")\n}\n</code></pre> <p>output:</p> <pre><code>2009/11/10 23:00:00 Just print a string 2\n2009/11/10 23:00:00 print a digit: 2\n2009/11/10 23:00:00 print and os.Exit(1)\n</code></pre>"},{"location":"golang/golang-fundamentals/logging/#json-logger","title":"JSON Logger","text":"<p>If you want to have a JSON logger, you can write one on your own. Here you could use embedding, to support the log.Logger struct:</p> <pre><code>type JSONLogger struct {\nlog.Logger\n}\nfunc (l JSONLogger) Print(value interface{}) {\nbytes, err := json.Marshal(map[string]interface{}{\n\"value\": value,\n\"time\":  time.Now().Format(\"2006-01-02T15:04:05Z07:00\"),\n})\nif err != nil {\npanic(err)\n}\nl.Logger.Print(string(bytes))\n}\nfunc NewJSONLogger(logger log.Logger) JSONLogger {\nreturn JSONLogger{\nLogger: logger,\n}\n}\nfunc main() {\njsonLogger := NewJSONLogger(*log.New(os.Stdout, \"\", 0))\njsonLogger.Print(struct {\nName     string `json:\"name\"`\nLastName string `json:\"lastName\"`\n}{\nName:     \"hello\",\nLastName: \"world\",\n})\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/logging/#zap-logger","title":"Zap Logger","text":"<p>The Zap Logger is faster than the default logger.</p> <p>Let's check an example:</p> <p>Add zap logger to your dependencies:</p> <pre><code>go get go.uber.org/zap\n</code></pre> <p>Then use the zap logger:</p> <pre><code>import (\n\"go.uber.org/zap\"\n)\nfunc main() {\ndevelopmentLogger, err := zap.NewDevelopment()\nif err != nil {\npanic(err)\n}\nproductionLogger, err := zap.NewProduction()\nif err != nil {\npanic(err)\n}\ndevelopmentLogger.Info(\"failed to fetch URL\",\nzap.String(\"url\", \"url\"),\n)\nproductionLogger.Info(\"failed to fetch URL\",\nzap.String(\"url\", \"url\"),\n)\n}\n</code></pre> <p>output:</p> <pre><code>2022-05-12T14:27:26.733+0200    INFO    bruh/main.go:16 failed to fetch URL     {\"url\": \"url\"}\n{\"level\":\"info\",\"ts\":1652358446.733641,\"caller\":\"bruh/main.go:19\",\"msg\":\"failed to fetch URL\",\"url\":\"url\"}\n</code></pre> <p>The Development Logger produces a tab separated string as log. The Production Logger produces a json string as log.</p>"},{"location":"golang/golang-fundamentals/modules_packages_imports/","title":"Modules, Packages, and Imports","text":""},{"location":"golang/golang-fundamentals/modules_packages_imports/#repositories-modules-and-packages","title":"Repositories, Modules, and Packages","text":"<p>There are three main concepts in Go: <code>repositories</code>, <code>modules</code>, and <code>packages</code>.</p> <p>A <code>repository</code> is the location, where the source code of a project is stored.</p> <p>A <code>module</code> is the root of a Go library or application, inside a <code>repository</code>.</p> <p><code>Modules</code> consist of one or more <code>packages</code>.</p> <p>Before we use third-party libraries we need to declare that our project is a <code>module</code>. Every module has it's own global unique identifier. It's like in Java the <code>com.example.project.library</code> name.</p> <p>In Go you usually use the location of your project, for example a Github repository. It doesn't have to be the repository location, a unique name is also fine.</p>"},{"location":"golang/golang-fundamentals/modules_packages_imports/#gomod","title":"go.mod","text":"<p>Create a module by using: <code>go mod init GLOBAL_UNIQUE_IDENTIFIER</code> The <code>GLOBAL_UNIQUE_IDENTIFIER</code> is case-sensitive, therefore try to avoid uppercase letters.</p> <p>Let's take a look a the <code>go.mod</code> if running the <code>go mod init</code> command.</p> <pre><code>module github.com/bykof/gostradamus\n\ngo 1.17\n\nrequire github.com/stretchr/testify v1.7.0\n\nrequire (\n    github.com/davecgh/go-spew v1.1.0 // indirect\n    github.com/pmezard/go-difflib v1.0.0 // indirect\n    gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c // indirect\n)\n</code></pre> <p>Beside the <code>require</code> section, there can be custom repositories like: <code>exclude</code> and <code>replace</code>.</p>"},{"location":"golang/golang-fundamentals/modules_packages_imports/#cross-compiling","title":"Cross Compiling","text":"<p>First we have to find available platforms, where we can compile to. (Source)</p> <p>To find all possible platforms use:</p> <pre><code>go tool dist list\n</code></pre> <p>output:</p> <pre><code>aix/ppc64\nandroid/386\nandroid/amd64\nandroid/arm\nandroid/arm64\ndarwin/amd64\ndarwin/arm64\ndragonfly/amd64\nfreebsd/386\nfreebsd/amd64\nfreebsd/arm\nfreebsd/arm64\nillumos/amd64\nios/amd64\nios/arm64\njs/wasm\nlinux/386\nlinux/amd64\nlinux/arm\nlinux/arm64\nlinux/mips\nlinux/mips64\nlinux/mips64le\nlinux/mipsle\nlinux/ppc64\nlinux/ppc64le\nlinux/riscv64\nlinux/s390x\nnetbsd/386\nnetbsd/amd64\nnetbsd/arm\nnetbsd/arm64\nopenbsd/386\nopenbsd/amd64\nopenbsd/arm\nopenbsd/arm64\nopenbsd/mips64\nplan9/386\nplan9/amd64\nplan9/arm\nsolaris/amd64\nwindows/386\nwindows/amd64\nwindows/arm\nwindows/arm64\n</code></pre> <p>This will print out all possible cross compilations, since Go 1.15 all possible platforms are built-in. The format of the output is: <code>$GOOS/$GOARCH</code>.</p> <p>Then you can use the following pattern for <code>$GOOS</code> and <code>$GOARCH</code> to cross compile your application:</p> <pre><code>GOOS=windows GOARCH=amd64 go build -o main.exe main.go\n</code></pre>"},{"location":"golang/golang-fundamentals/modules_packages_imports/#go-generate","title":"Go generate","text":"<p>Go generate is a useful tool to run important project commands.</p> <p>You can run it with:</p> <pre><code>go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]\n</code></pre> <p>Go generate will not run automatically with go build, go test and go run. It should be run manually and explicitly.</p> <p>The command should be placed a go file at the top of the file:</p> <p>For example we want to</p> main.go<pre><code>package main\n//go:generate echo \"Hello, Go Generate!\"\nfunc main() {}\n</code></pre> <p>If you run this file with following commands:</p> <pre><code>\u279c go run main.go\n\u279c go generate\nHello, Go Generate!\n</code></pre> <p>You will see later why it's an important tool and how it can be used with wire.</p>"},{"location":"golang/golang-fundamentals/modules_packages_imports/#go-format","title":"Go format","text":"<p>Go format is very important tool, to format your code upon Go conventions (Source).</p> <p>It make following standards possible:</p> <ul> <li>easier to write: never worry about minor formatting concerns while hacking away,</li> <li>easier to read: when all code looks the same you need not mentally convert others' formatting style into something you can understand.</li> <li>easier to maintain: mechanical changes to the source don\u2019t cause unrelated changes to the file\u2019s formatting; diffs show only the real changes.</li> <li>uncontroversial: never have a debate about spacing or brace position ever again!</li> </ul> <p>To use it execute:</p> <pre><code>go fmt path/to/your/package\n</code></pre> <p>This will format your code automatically.</p>"},{"location":"golang/golang-fundamentals/modules_packages_imports/#imports-and-exports","title":"Imports and Exports","text":"<p>In Go you can import exported:</p> <ul> <li>constants</li> <li>variables</li> <li>functions</li> <li>types</li> </ul> <p>and you can export:</p> <ul> <li>constants</li> <li>variables</li> <li>functions</li> <li>types</li> <li>methods in a struct</li> <li>fields in a sruct</li> </ul> <p>Exporting things in Go is managed by the <code>capitalization</code>.</p> <p>This means, if you start the name of a function with an uppercase letter it gets <code>exported</code>, otherwise it's only visible inside a package.</p> <pre><code>func Exported() {\n// this function can be accessed from other packages\n}\nfunc packageFunc() {\n// this function is only available in the package\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/modules_packages_imports/#packages","title":"Packages","text":"<p>Creating and accessing packages very easy in Go. Actually you just create a folder with the <code>package name</code>. Then, every file inside the package should have a package clause. The package clause can use the <code>package name</code> or another <code>custom package name</code>.</p> <p>Let's look at an example:</p> math/math.go<pre><code>package math\nfunc Double(a int) in {\nreturn a * 2\n}\n</code></pre> formatter/formatter.go<pre><code>package print\nimport \"fmt\"\nfunc Format(num int) string {\nreturn fmt.Sprintf(\"The numer is %d\", num)\n}\n</code></pre> <pre><code>package main\nimport (\n\"fmt\"\n\"example.com/formatter\",\n\"example.com/math\",\n)\nfunc main() {\nnum := math.Double(2)\noutput := print.Format(num)\nfmt.Println(output)\n}\n</code></pre> <p>The import path can be relative, but always use absolute paths with the repository name as root to the module name you want to import, separated by <code>/</code>.</p> <p>In the example we imported <code>example.com/formatter</code> but we defined the packagein <code>formatter.go</code> to be <code>package print</code>. This is because in Go the package declaration happens in the files itself not as directory name. BUT the package name should be the same across a dirctory. It won't work, if you mix package names in a directory.</p>"},{"location":"golang/golang-fundamentals/modules_packages_imports/#overriding-imports","title":"Overriding imports","text":"<p>It can happen, that you have to import two packages with the same name. Therefore you can just overwrite the package name by using <code>import alias</code>.</p> <p>Let's check an example:</p> <pre><code>import (\ncryptoRand \"crypto/rand\"\n\"math/rand\"\n)\n</code></pre>"},{"location":"golang/golang-fundamentals/modules_packages_imports/#documenting-with-godoc","title":"Documenting with godoc","text":"<p>With <code>godoc</code> you can document your repository and it's packages. There are several rules, which you have to follow:</p> <ul> <li>Place the comment directly before the item being documented with no blank lines between the comment and the declaration of the item</li> <li>Start the comment with two forward slashes <code>//</code> followeg by the name of the item</li> <li>Use a blank comment to break your comment into multiple paragraphs</li> <li>Insert preformatted comment by indenting the lines</li> </ul> <p>Comments before the package declaration create package level comments.</p> <p>Generate comments by using the command: <code>go doc</code>.</p>"},{"location":"golang/golang-fundamentals/modules_packages_imports/#internal-package","title":"internal package","text":"<p>If you want to export constants or types between your packages in your module, but you don't want to export them outside of your repository, you can use internal packages. Create a package called <code>internal</code>, everyting exported in the <code>internal</code> package will be accessable by the outer package or sibling package.</p> <p>Here is an example:</p> <pre><code>\u251c\u2500\u2500 bar\n\u2502   \u2514\u2500\u2500 bar.go\n\u251c\u2500\u2500 foo\n\u2502   \u251c\u2500\u2500 foo.go\n\u2502   \u251c\u2500\u2500 internal\n\u2502   \u2502   \u2514\u2500\u2500 internal.go\n\u2502   \u2514\u2500\u2500 sibling\n\u2502       \u2514\u2500\u2500 sibling.go\n\u251c\u2500\u2500 go.mod\n\u2514\u2500\u2500 main.go\n</code></pre> <p>Only <code>foo</code> and <code>sibling</code> can access exported types from <code>internal</code>. <code>bar</code> cannot access <code>internal</code>.</p>"},{"location":"golang/golang-fundamentals/modules_packages_imports/#circular-dependency","title":"Circular Dependency","text":"<p>Go doesn't allow you to have circular dependencies.</p>"},{"location":"golang/golang-fundamentals/modules_packages_imports/#modules","title":"Modules","text":"<p>Let's import now third party libraries by using the library: decimal</p> <p>Here is an example:</p> <pre><code>import (\n\"fmt\"\n\"github.com/shopspring/decimal\"\n)\nfunc main () {\nprice, err := decimal.NewFromString(\"136.02\")\nif err != nil {\npanic(err)\n}\nquantity := decimal.NewFromInt(3)\ntotal := price.Mul(quantity)\nfmt.Println(\"Total:\", total)\n}\n</code></pre> <p>If we run <code>go build</code> or <code>go run main.go</code> we get:</p> <pre><code>main.go:6:2: no required module provides package github.com/shopspring/decimal; to add it:\n        go get github.com/shopspring/decimal\n</code></pre> <p>Here just run:</p> <pre><code>go get github.com/shopspring/decimal\n</code></pre> <p>We see that Go automatically added the required module to the <code>go.mod</code> it created a <code>go.sum</code> file It took the latest version, since you did no specified one. If the repository does not specify a version, Go will create a pseudo version, with a hash of the module:</p> go.mod<pre><code>module decimal_example\n\ngo 1.18\n\nrequire github.com/shopspring/decimal v1.3.1 // indirect\n</code></pre> go.sum<pre><code>github.com/shopspring/decimal v1.3.1 h1:2Usl1nmF/WZucqkFZhnfFYxxxu8LG21F6nPQBE5gKV8=\ngithub.com/shopspring/decimal v1.3.1/go.mod h1:DKyhrW/HYNuLGql+MJL6WCR6knT2jwCFRcu2hWCYk4o=\n</code></pre>"},{"location":"golang/golang-fundamentals/modules_packages_imports/#versions","title":"Versions","text":"<p>If you want a specific version of a module, just use <code>go get</code> with the <code>@vx.x.x</code> tag:</p> <pre><code>go get github.com/shopspring/decimal@v1.1.0\n</code></pre> <p>This will install decimal at version <code>v1.1.0</code>.</p>"},{"location":"golang/golang-fundamentals/modules_packages_imports/#upgrade","title":"Upgrade","text":"<p>If you want to upgrade a module to the latest version use:</p> <pre><code>go get -u github.com/shopspring/decimal\n</code></pre> <p>If you just want to upgrade the patch version use <code>-u=patch</code>.</p> <pre><code>go get -u=patch github.com/shopspring/decimal\n</code></pre>"},{"location":"golang/golang-fundamentals/modules_packages_imports/#vendoring","title":"Vendoring","text":"<p>If you want to store the module inside the project folder without depending on the internet, you can use:</p> <pre><code>go mod vendor\n</code></pre> <p>This will create a <code>vendor</code> folder with downloaded module inside of it. If you update the <code>go.mod</code> you have to rebuild the vendor folder again.</p>"},{"location":"golang/golang-fundamentals/modules_packages_imports/#publishing","title":"Publishing","text":"<p>If you want to publish your module to the public, you can do it by upload it to a public repository like Github oder Gitlab. Check my own repository for example: https://github.com/bykof/gostradamus.</p>"},{"location":"golang/golang-fundamentals/modules_packages_imports/#versioning","title":"Versioning","text":"<p>Golang uses <code>semantic versioning</code> to create different versions of a module.</p> <p>If you release a new version of your module just tag the main branch of you repository with <code>v1.0.0</code> or a preferred version.</p>"},{"location":"golang/golang-fundamentals/modules_packages_imports/#proxying","title":"Proxying","text":"<p>If you run <code>go get</code> Go actually fetches the module from a Proxy Server ([https://proxy.golang.org]) where it holds copies of Go modules. If module is not available Google's Proxy Server downloads and stores the module you requested.</p> <p>If you do not want to use Google's Proxy Server but another one use:</p> <pre><code>GOPROXY=https://gocenter.io,direct go get ...\n</code></pre> <p>If you don't want to use Proxy Server at all and want to directly download the packages from the source use:</p> <pre><code>GOPROXY=direct go get ...\n</code></pre> <p>If you want to use your own proxy server in the company:</p> <ul> <li>Artifactory</li> <li>Sonatype</li> <li>Athens</li> <li>GOPROXY</li> </ul> <p>Setup surch a service and point to the URL via <code>GOPROXY</code> env variable.</p>"},{"location":"golang/golang-fundamentals/modules_packages_imports/#private-repositories","title":"Private Repositories","text":"<p>If you have private repositories but you are using a public proxy you can supress the call to a public proxy (by hiding the domain of your company for example):</p> <pre><code>GOPRIVATE=GOPRIVATE=*.corp.example.com,rsc.io/private\n</code></pre>"},{"location":"golang/golang-fundamentals/pointers/","title":"Pointers","text":""},{"location":"golang/golang-fundamentals/pointers/#overview","title":"Overview","text":"<p>Let's first check how variable are represented in the memory:</p> <pre><code>var x int32 = 10\nvar y bool = true\n</code></pre> Value 0 0 0 10 1 Address 1 2 3 4 5 Variable x y <p><code>x</code> is a 32bit integer, which needs 4 bytes (4*8) to store the integer in the memory. <code>y</code> is a boolean and needs just 1 byte to store it in the memory. For every byte in the memory there is an address, so the programm can read or write the specific values into the memory.</p> <p>A pointer \"points\" to a specific address of a variable. Let's check that:</p> <pre><code>var x int32 = 10\nvar y bool = true\npointerX := &amp;x\npointerY := &amp;y\nvar pointerZ *string\n</code></pre> Value 0 0 0 10 1 0 0 0 1 0 0 0 5 0 0 0 0 Address 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Variable x y pointer X pointerY pointerZ <p>The <code>&amp;</code> is the <code>address operator</code>. It returns a the address of the memory location where the value is stored.</p> <p>The <code>*</code> is the <code>indirection operator</code>. It returns the actual value of a pointer. This is also called dereferencing.</p> <p>If you dereference a pointer which is nil, you will get a panic:</p> <pre><code>var x *int\nfmt.Println(x == nil)\nfmt.Println(*x)\n</code></pre> <p>outputs:</p> <pre><code>true\npanic: runtime error: invalid memory address or nil pointer dereference\n[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x47dd2d]\n</code></pre> <p>There is a builtin function <code>new</code>, which creates a pointer type variable. It returns a pointer to a zero value of given type.</p> <pre><code>var x = new(int)\nfmt.Println(x == nil)\nfmt.Println(*x)\n// is the same as\nvar a int\nvar b *int\nb = &amp;a\nfmt.Println(*b)\n</code></pre> <p>For structs you can use just a <code>&amp;</code> while initializing one:</p> <pre><code>type person struct {\nFirstName string\nLastName string\n}\nperson := &amp;person{\nFirstName:  \"Michael\",\nLastName: \"Bykovski\",\n}\n</code></pre> <p>Take care, that you cannot take the address of a constant. Check here:</p> <pre><code>type person struct {\nFirstName string\nMiddleName *string\nLastName string\n}\np := &amp;person{\nFirstName:  \"Michael\",\nMiddleName: &amp;\"Michau\",\nLastName: \"Bykovski\",\n}\n</code></pre> <p>output:</p> <pre><code>invalid operation: cannot take address of \"Michau\" (untyped string constant)\n</code></pre> <p>You can use two solutions here. First introduce a variable of the constant and then take the address of it. Or create a function that gets a type and returns the pointer to that type.</p> <pre><code>func stringPointer(s string) *string {\nreturn &amp;s\n}\ntype person struct {\nFirstName  string\nMiddleName *string\nLastName   string\n}\nfunc main() {\ntype person struct {\nFirstName  string\nMiddleName *string\nLastName   string\n}\nmiddleName := \"Michau\"\np := &amp;person{\nFirstName:  \"Michael\",\nMiddleName: &amp;middleName,\nLastName:   \"Bykovski\",\n}\np2 := &amp;person{\nFirstName:  \"Michael\",\nMiddleName: stringPointer(\"Michau\"),\nLastName:   \"Bykovski\",\n}\nfmt.Println(p, p2)\n}\n</code></pre> <p>output:</p> <pre><code>&amp;{Michael 0xc000010250 Bykovski} &amp;{Michael 0xc000010260 Bykovski}\n</code></pre>"},{"location":"golang/golang-fundamentals/pointers/#mutable-parameters-or-call-by-reference","title":"Mutable Parameters or Call by Reference","text":"<p>Go is a call by value language, which means that if you pass a variable into a function as parameter, it will make a copy of that variable. So if you try to manipulate the passed in variable you will only do changed on a copy of the actual passed in variable. But what if you store an address of a variable and pass in the address into a function? -&gt; Then you will be able to manipulate the actual value of the outer variable. Let's check an example:</p> <pre><code>type Person struct {\nFirstName string\nLastName  string\nAge       int\n}\nfunc noBirthday(p Person) {\np.Age = p.Age + 1\n}\nfunc birthday(p *Person) {\np.Age = p.Age + 1\n}\nfunc main() {\np := Person{\nFirstName: \"Michael\",\nLastName:  \"Bykovski\",\nAge:       28,\n}\nfmt.Println(p)\nnoBirthday(p)\nfmt.Println(p)\nbirthday(&amp;p)\nfmt.Println(p)\n}\n</code></pre> <p>output:</p> <pre><code>{Michael Bykovski 28}\n{Michael Bykovski 28}\n{Michael Bykovski 29}\n</code></pre> <p>But it has some implications, which could be not self explanatory. For example, if you have a nil pointer and you want to assign a variable to this pointer. You still work on a \"copy\" of that pointer.</p> <pre><code>func failedUpdate(g *int) {\nx := 10\ng = &amp;x // g is still a copied pointer and will be vanished after function returns\n}\nfunc main() {\nvar f *int\nfailedUpdate(f)\nfmt.Println(f) // f is still nil\n}\n</code></pre> <p>This can be fixed by derefencing the value and setting it. By dereferencing we access the actual value in the memory and overwrite it within a function.</p> <pre><code>func failedUpdate(g *int) {\nx := 10\ng = &amp;x // g is still a copied pointer and will be vanished after function returns\n}\nfunc update(g *int) {\n*g = 10\n}\nfunc main() {\nf := 1\nfailedUpdate(&amp;f)\nfmt.Println(f) // f is still 1\nupdate(&amp;f)\nfmt.Println(f) // 10\n}\n</code></pre> <p>Danger</p> <p>Please be carefull with dereferencing, because they can panic. Therefore always check for nil pointer!</p> <pre><code>func update(g *int) {\n*g = 10\n}\nfunc main() {\nvar f *int\nupdate(f)\nfmt.Println(f) // error: invalid memory address or nil pointer dereference\n}\n</code></pre> <p>Fixed:</p> <pre><code>func update(g *int) {\nif g != nil {\n*g = 10\n}\n}\nfunc main() {\nvar f *int\nupdate(f)\nfmt.Println(f) // prints nil\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/pointers/#passing-pointers-rather-than-values","title":"Passing Pointers rather than Values","text":"<p>Surely passing pointers and modifying their values is easy. But it's actually an \"anti-pattern\" to make functions, which receive a pointer and modifying the value of your variable. Modern Software Engineering teaches us to work with immutable values rather than mutable ones Source.</p> <p>Therefore it's better to make functions which receive a copy of a value, mutate it and returns the mutated value:</p> <pre><code>type Person struct {\nFirstName string\nAge       int\n}\nfunc badBirthday(p *Person) {\np.Age++\n}\nfunc birthday(p Person) Person {\np.Age++\nreturn p\n}\nfunc main() {\nperson := Person{\nFirstName: \"Michael\",\nAge:       28,\n}\nfmt.Println(person)\nbadBirthday(person)\nfmt.Println(person)\nperson = birthday(person)\nfmt.Println(person)\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/pointers/#performance","title":"Performance","text":"<p>If you pass a variable into a function, the whole variable gets copied to work on it. So if you pass in a variable which is around 10megabytes big, it can take up to 1 millisecond to copy the variable. Beside that it takes only about 1 nanosecond to load a pointer into a function.</p> <p>But returning a pointer can take more time than returning a variable. But only in one case, if you variable is smaller than 1 megabyte. For example for a 100 byte pointer it takes 30 nanoseconds and to return a value, it takes 10 nanoseconds. Once your data is bigger than 1 megabyte, this rule inverts.</p> <p>So for the vast majority of cases you should use call by value, only in a few cases a pointer makes sense.</p>"},{"location":"golang/golang-fundamentals/pointers/#zero-value-vs-no-value","title":"Zero Value vs. No Value","text":"<p>A common usage for pointers is to set a variable either to it's zero value or to set it to nil. If you need to explicitly say, that a variable is not set, use a nil pointer.</p> <p>For example if you need optional parameters:</p> <pre><code>type Parameters struct {\na int\nb *int\n}\nfunc sum(parameters Parameters) int {\nif parameters.b != nil {\nreturn parameters.a + *parameters.b\n}\nreturn parameters.a\n}\nfunc main() {\nb := 2\np1 := Parameters{\na: 1,\nb: &amp;b,\n}\np2 := Parameters{\na: 5,\n}\nfmt.Println(sum(p1))\nfmt.Println(sum(p2))\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/pointers/#maps-and-pointers","title":"Maps and Pointers","text":"<p>If you pass a map into a function you can manipulate the actual value of the map. This is because Go doesn't copy the value of the map but passes a reference (a pointer to struct) into the function.</p> <p>Therefore you should avoid using maps, unless you are working with really dynamic JSON data for example. Especially if you design your code to work in a team, it is better to define a concrete struct for your data structure than to use a dynamic map.</p>"},{"location":"golang/golang-fundamentals/pointers/#when-to-use-methods-over-functions","title":"When to use Methods over Functions","text":"<p>Any time your logic depends on values that are configured at startup of changed while your program is running, those values should be stored in a struct and that logic should be implemented as a method.</p> <p>Follow this three rules and you'll be fine:</p> <ol> <li>when implementing methods of an interface for your struct (we will do interfaces in the next chapter)</li> <li>when the function needs to use a private variable within your struct</li> <li>when the function is completely related to the struct</li> </ol>"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/","title":"Primitive Types and Declarations","text":""},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#zero-value","title":"Zero Value","text":"<p>If a variable is declared but not initialized with a value it gets the 'zero value'.</p> <p>Following zero values will be defined:</p> Types Zero Value int 0 float 0.0 bool false string \"\" pointer nil interface nil slice nil map nil channel nil function nil"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#variable-declarations","title":"Variable Declarations","text":"<p>There are several ways to define a variable in Go. Each definition describes the way, the declared variable will be used.</p> <p>The default way to declare a variable is by using:</p> <pre><code>var x int = 10\n</code></pre> <p>Using the <code>var</code> keyword, the variable name, the type, the assignment operator, and a value.</p> <p>If there is a default type for the value you propose, you can use a shorter declaration:</p> <pre><code>var x = 10\n</code></pre> <p>If you don't want to initialize the variable and just declare it, you can leave the assignment operator with the value. The variable will be then initialized with the Zero Value.</p> <pre><code>var x int\n</code></pre> <p>You can declare multiple variables of the same type with:</p> <pre><code>var x, y int = 10\n</code></pre> <p>Also it's possible to just declare multiple variables of the same type without initialization:</p> <pre><code>var x, y int\n</code></pre> <p>or for different types, but only in this form:</p> <pre><code>var x, y = 10, \"hello\"\n</code></pre> <p>It's also possible to wrap declarations in paranthesis:</p> <pre><code>var (\nx    int\ny            = 20\nz    int     = 30\nd, e         = 40, \"hello\"\nf, g string\n)\n</code></pre>"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#short-declaration-format","title":"Short declaration format","text":"<p>Golang supports also a short declaration format. It can be only used within function scopes, not at the package scope.</p> <p>Here is an example:</p> <pre><code>x := 10\n</code></pre> <p>it's the same as:</p> <pre><code>var x = 10\n</code></pre> <p>With <code>:=</code> you can also assign values to variables as long as there is a new variable on the left hand side of <code>:=</code></p> <p>For example:</p> <pre><code>x := 10\nx, y := 20, \"Hello World\"\n</code></pre>"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#when-to-use-what","title":"When to use what?","text":"<p>When you should use <code>var</code> or <code>:=</code>?</p> <p>There are some rules to follow, when you decide when to use what:</p> <ul> <li>When you initialize a variable to its zero value, use <code>var x int</code>.</li> <li>When assigning an untyped constant or a literal to a typed variable:     <pre><code>var x byte = 20\n</code></pre></li> <li><code>:=</code> allows you to assign to new and existing variables. Therefore it's idiomatic to declare new variables with <code>var</code> and mixed (new and existing) variables with <code>:=</code>.</li> </ul>"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#package-variables","title":"Package Variables","text":"<p>Avoid defining variables in the <code>package block</code>, because they can be manipulated by other functions, which makes it harder to track, what values they have. Use <code>const</code> for this problem.</p>"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#const","title":"Const","text":"<p>Const allows variables to be immutable. It has the same syntax as variables. Here are some examples:</p> <pre><code>package main\nimport (\n\"fmt\"\n)\nconst x int = 10\nconst (\nidKey   = \"id\"\nnameKey = \"name\"\n)\nconst z = 20 * 10\nfunc main() {\nconst y = \"hello\"\nfmt.Println(x)\nfmt.Println(y)\nx = x + 1\ny = \"bye\"\nfmt.Println(x)\nfmt.Println(y)\n}\n</code></pre> <p>This would result in:</p> <pre><code>./prog.go:22:5: cannot assign to x (constant 10 of type int)\n./prog.go:23:5: cannot assign to y (untyped string constant \"hello\")\n</code></pre>"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#definition-at-compile-time","title":"Definition at compile time","text":"<p>Go initializes constants at compile time, therefore it's only possible to assign following values to them:</p> <ul> <li>Numeric literals</li> <li>Boolean literals</li> <li>Strings</li> <li>Runes</li> <li>built-in function like complex, real, imag, len, cap</li> <li>Expressions that consists of operators and the preceeding values</li> </ul>"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#unused-variables","title":"Unused variables","text":"<p>Go will complain if you leave variables unread.</p> <p>Take a look at the following example:</p> <pre><code>package main\nvar x = 10\nfunc main() {\nvar y = 20\n}\n</code></pre> <p>This will result in the error:</p> <pre><code>./prog.go:7:9: y declared but not used\n</code></pre> <p>Therefore you can define as many package variables as you want. Only function scope variables should be read at least once. This is an another argument to avoid package scope variables.</p>"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#unused-constants","title":"Unused constants","text":"<p>You can define as much constants as you want. Because constants are calculated at the compile time, they won't have any side effects.</p> <p>This compiles without errors:</p> <pre><code>package main\nconst x = 10\nfunc main() {\nconst y = 20\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#primitive-types","title":"Primitive Types","text":"<p>Following primitive types in Go can be used:</p> <ul> <li>Boolean</li> <li>Integer</li> <li>Float</li> <li>Complex</li> <li>Byte</li> <li>Rune</li> <li>String</li> </ul>"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#booleans","title":"Booleans","text":"<p><code>bool</code> types represents Boolean values. It can have <code>true</code> or <code>false</code> as value. The zero value for bool is <code>false</code>.</p>"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#numeric-types","title":"Numeric Types","text":"<p>Go has 12 different numeric types that are grouped into three categories.</p> <ul> <li>Integer</li> <li>Float</li> <li>Complex</li> </ul>"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#integer","title":"Integer","text":"<p>Go has signed and unsigned integers with different byte sizes. They are defined in the following table:</p> Type Name Value Range int8 -128 to 127 int16 -32768 to 32767 int32 -2147483648 to 2147483647 int64 -9223372036854775808 to 9223372036854775807 uint8 0 to 255 uint16 0 to 65535 uint32 0 to 4294967295 uint64 0 to 18446744073709551615"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#overflows","title":"Overflows","text":"<p>Trying to set a higher value to a numeric type with it's allowed byte size</p> <pre><code>package main\nimport (\n\"fmt\"\n)\nfunc main() {\nvar x uint8\nfmt.Println(\"Throws integer overflow\")\nx = 267       // range of uint8 is 0-255\n}\n</code></pre> <p>will result in following compiler error:</p> <pre><code>./prog.go:10:9: cannot use 267 (untyped int constant) as uint8 value in assignment (overflows)\n</code></pre>"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#special-integer-types","title":"Special integer types","text":"<p>There is a special name called <code>int</code>. It has different byte allocations depending on the CPU architecture. On a 32-bit CPU, <code>int</code> is a 32-bit signed integer like <code>int32</code>. On most 64-bit CPUs, <code>int</code> is a 64-bit signed integer like <code>int64</code>. Because <code>int</code> depends on the CPU architecture, it is not allowed to perform mathematical operations or between <code>int</code> and <code>int32</code> or <code>int64</code>.</p> <p>See following example for this:</p> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nvar x int = 2\nvar y int32 = 5\nvar z int64 = 2\nfmt.Println(x + y)\nfmt.Println(x + z)\n}\n</code></pre> <p>would result in a compile error:</p> <pre><code>./prog.go:9:14: invalid operation: x + y (mismatched types int and int32)\n./prog.go:10:14: invalid operation: x + z (mismatched types int and int64)\n\nGo build failed.\n</code></pre>"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#floating-point-types","title":"Floating point types","text":"<p>There are two floating point types, displayed in the following table:</p> Type Name Larget absolute value Smallest (nonzero) absolute value float32 3.4028e+38 1.4012e-45 float64 1.7976e+308 4.9406e-324 <p>In most cases you shouldn't use float, because Go just stores the nearest approximation for a value. If you want to use float, you will need <code>float64</code> unless you really know what you do.</p>"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#complex-types","title":"Complex types","text":"<p>Go has a built-in support for complex numbers. You're probably not going to need them.</p> <p>Here is an example how to use complex numbers in Go:</p> <pre><code>package main\nimport (\n\"math/cmplx\"\n\"fmt\"\n)\nfunc main() {\nx := complex(2.5, 4.1)\ny := complex(10.2, 6)\nfmt.Println(x + y)\nfmt.Println(x - y)\nfmt.Println(x * y)\nfmt.Println(x / y)\nfmt.Println(real(x))\nfmt.Println(imag(y))\nfmt.Println(cmplx.Abs(x))\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#byte","title":"Byte","text":"<p>A <code>byte</code> is an alias for <code>uint8</code>. You can compare, peform mathematical operations between a <code>byte</code> and <code>uint8</code>. For example the following code works:</p> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nvar x uint8 = 2\nvar y byte = 65\nfmt.Println(x + y)\n}\n</code></pre> <p>this would print:</p> <pre><code>67\n</code></pre> <p>However if you want to work with bytes just use <code>byte</code> and not <code>uint8</code>.</p>"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#rune","title":"Rune","text":"<p>A <code>rune</code> is a an alias for <code>int32</code>. You can compare, perform mathematical operations between a <code>rune</code> and <code>int32</code>. A <code>rune</code> can be initialized with single quotes:</p> <pre><code>const symbolRune = '\u2318'\n</code></pre> <p>This rune has the integer value: <code>0x2318</code> which is the unicode character \u2318 (See here).</p>"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#string","title":"String","text":"<p>A string is a read only slice of bytes in Go. Strings can be initialized in two ways:</p>"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#double-quote-strings","title":"double quote strings","text":"<p>Double quotes format the string with escape sequences. So if your string contains a <code>\\n</code> it will format it to a newline.</p> <pre><code>const myString = \"Hello\\n World!\"\nfmt.Println(myString)\n</code></pre> <p>output:</p> <pre><code>Hello\nWorld\n</code></pre>"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#back-quote-strings","title":"back quote strings","text":"<p>Back quotes ignore escape sequences in your string. Back quote strings can be also used as multiline strings</p> <pre><code>const myString = `Hello\\n World!`\nconst anotherString = `-&gt; Hello\n-&gt; World\n`\nfmt.Println(myString)\nfmt.Println(anotherString)\n</code></pre> <p>output:</p> <pre><code>Hello\\n World!\n-&gt; Hello\n-&gt; World\n</code></pre> <p>Each character in your string represents an <code>utf-8</code> encoded string character by default. In utf-8 each character occupies between 1-4 bytes. The characters <code>a</code> or <code>b</code> are encoded using <code>1 byte</code>. If you use characters like <code>\u00a3</code> (2 bytes) or <code>\u2318</code> (3 bytes) the byte size can vary. Therefore be cautious if you convert a string into a byte array, the byte array will contain each byte of a character:</p> <pre><code>package main\nimport \"fmt\"\nfunc main () {\nmyString := \"\u00a3\u2318a\"\nfmt.Println([]byte(s))\n}\n</code></pre> <p>will output:</p> <pre><code>|--\u00a3---| |---\u2318-----| |a|\n[194 163 226 140 152 97]\n</code></pre>"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#explicit-type-conversion","title":"Explicit Type Conversion","text":"<p>If you work with different type of integers and float you cannot just add, subtract, multiply, and divide those types independently. You have to explicitly type cast an <code>int32</code> to an <code>int64</code> for example to add it to another <code>int64</code>. That makes it clear with what types you work and if some data was truncated</p> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nvar x float64 = 1.2\nvar y int = 2\nz := int(x) + y\nfmt.Println(z)\n}\n</code></pre> <p>A type conversion to boolean is not possible.</p> <p>If you want to type cast a variable to a bool, you have to use the zero value of the specific type.</p> <pre><code>var x int\nvar s string = \"Test\"\nvar xZero bool = x == 0\nvar sZero bool = s == \"\"\nfmt.Println(x, xZero)\nfmt.Println(s, sZero)\n</code></pre>"},{"location":"golang/golang-fundamentals/reflect/","title":"Reflect","text":"<p>Informative Source</p> <p>With reflect we get information about our variables at runtime. It's highly recommended not to use reflection, because every wrong usage can <code>panic</code>. Reflect should be the last possible way to do \"meta-programming\" in Go.</p> <p>But let's check an example anyway:</p> <pre><code>package main\nimport (\n\"fmt\"\n\"reflect\"\n)\ntype Foo struct {\nA int `tag1:\"First Tag\" tag2:\"Second Tag\"`\nB string\n}\nfunc main() {\nsl := []int{1, 2, 3}\ngreeting := \"hello\"\ngreetingPtr := &amp;greeting\nf := Foo{A: 10, B: \"Salutations\"}\nfp := &amp;f\nfmt.Println(reflect.TypeOf(sl))\nfmt.Println(reflect.TypeOf(greeting))\nfmt.Println(reflect.TypeOf(greetingPtr))\nfmt.Println(reflect.TypeOf(f))\nfmt.Println(reflect.TypeOf(fp))\n}\n</code></pre> <p>output:</p> <pre><code>[]int\nstring\n*string\nmain.Foo\n*main.Foo\n</code></pre> <p>Reflection has three rules, that you should remember, when you work with <code>reflect</code>:</p> <ol> <li>Reflection goes from interface value to reflection object</li> <li>Reflection goes from reflection object to interface value</li> <li>To modify a reflection object, the value must be settable</li> </ol>"},{"location":"golang/golang-fundamentals/reflect/#reflection-goes-from-interface-value-to-reflection-object","title":"Reflection goes from interface value to reflection object","text":"<p>If you use <code>reflect.TypeOf</code> you pass in <code>any</code> and get a <code>Type</code> back. <code>Type</code> is an interface to get more information about the reflected type. If we want to examine the <code>Value</code> of a specific variable we can do that by:</p> <pre><code>var x float64 = 3.4\nfmt.Println(\"type:\", reflect.TypeOf(x))\nfmt.Println(\"value:\", reflect.ValueOf(x).String())\n</code></pre> <p>We can use the reflection to check, if a variable has a specific type:</p> <pre><code>var x float64 = 3.4\nv := reflect.ValueOf(x)\nfmt.Println(\"type:\", reflect.TypeOf(x))\nfmt.Println(\"value:\", v.String())\nfmt.Println(\"kind is float64:\", v.Kind() == reflect.Float64)\n</code></pre> <p>output would be:</p> <pre><code>type: float64\nvalue: &lt;float64 Value&gt;\nkind is float64: true\n</code></pre> <p>If you have a user-defined type, <code>Type</code> can give you the user-defined type, but <code>Kind</code> will always give you the built-in type.</p> <pre><code>type MyInt int\nvar x MyInt = 7\nv := reflect.ValueOf(x)\nfmt.Println(v.Kind().String())\nfmt.Println(v.Type())\n</code></pre>"},{"location":"golang/golang-fundamentals/reflect/#reflection-goes-from-reflection-object-to-interface-value","title":"Reflection goes from reflection object to interface value","text":"<p>If we have a reflected <code>reflect.Value</code>, we can derive back the inverse of it. We call the <code>Interface</code> method on a <code>Value</code> to get it's interface again and then we can Type Assert it back to it's natural Go type.</p> <p>Let's take an example:</p> <pre><code>y := 2.9\nv := reflect.ValueOf(y)\nx := v.Interface().(float64)\nfmt.Printf(\"x, type: %T, value: %v\\n\", x, x)\n</code></pre> <p>output:</p> <pre><code>x, type: float64, value: 2.9\n</code></pre>"},{"location":"golang/golang-fundamentals/reflect/#to-modify-a-reflection-object-the-value-must-be-settable","title":"To modify a reflection object, the value must be settable","text":"<p>To set a value via reflection, the value must be settable.</p> <pre><code>var x float64 = 3.4\nv := reflect.ValueOf(x)\nv.SetFloat(7.1) // Error: will panic.\n</code></pre> <p>output:</p> <pre><code>panic: reflect: reflect.Value.SetFloat using unaddressable value\n</code></pre> <p>Go is call-by-value, therefore it's a copy of the variable <code>x</code> what <code>reflect.ValueOf</code> is using. When we want to set the value of <code>x</code>, we have to pass a \"Setable\" type: a pointer.</p> <pre><code>var x float64 = 3.4\nv := reflect.ValueOf(&amp;x)\nv.SetFloat(7.1)\nfmt.Println(x)\n</code></pre> <p>If we now to set the value, the output would be:</p> <pre><code>panic: reflect: reflect.Value.SetFloat using unaddressable value\n</code></pre> <p>Why? Because we just try to set 7.1 to the pointer itself and not to the actual value in RAM. To get the actual Value of a pointer in the RAM we have to call [<code>Elem</code>].</p> <p>Elem returns the value that the interface v contains or that the pointer v points to. It panics if v's Kind is not Interface or Pointer. It returns the zero Value if v is nil.</p> <p>Example:</p> <pre><code>var x float64 = 3.4\nv := reflect.ValueOf(&amp;x)\nv.Elem().SetFloat(7.1)\nfmt.Println(x)\n</code></pre> <p>now the output is correct:</p> <pre><code>7.1\n</code></pre>"},{"location":"golang/golang-fundamentals/standard_library/","title":"The standard library","text":"<p>There are a lot of \"batteries included\" in Go. The standard library is really huge, let's check some of those packages to see, how they were implemented.</p>"},{"location":"golang/golang-fundamentals/standard_library/#io","title":"io","text":"<p>Input and Output Data into files is probably one of the main things, what a programm should can. The package <code>io</code> provide this functionality and two most used interfaces from this package are:</p> <pre><code>type Reader interface {\nRead(p []byte) (n int, err error)\n}\ntype Writer interface {\nWrite(p []byte) (n int, err error)\n}\n</code></pre> <p><code>Reader</code> and <code>Writer</code> are very simple and practical interfaces. They allow to read or write <code>len(p)</code> byte to a specific destination.</p> <p>This allows also to read buffered data, lets check an example here:</p> <pre><code>func countLetters(r io.Reader) (map[string]int, error) {\nbuf := make([]byte, 2048)\nout := map[string]int{}\nfor {\nn, err := r.Read(buf)\nfor _, r  range bug[:n] {\nif (r &gt;= 'A' &amp;&amp; r &lt;= 'Z') || (r &gt;= 'a' &amp;&amp; r &lt;= 'z') {\nout[string(r)]++\n}\n}\nif err == io.EOF {\nreturn out, nil\n}\nif err != nil {\nreturn nil, nil\n}\n}\n}\n</code></pre> <p>Let's see, how we can read a simple file:</p> <pre><code>import (\n\"fmt\"\n\"io\"\n\"log\"\n\"os\"\n)\nfunc main() {\nf, err := os.OpenFile(\"notes.txt\", os.O_RDWR|os.O_CREATE, 0755)\nif err != nil {\nlog.Fatal(err)\n}\ndefer func() {\nif err := f.Close(); err != nil {\nlog.Fatal(err)\n}\n}()\ndata, err := io.ReadAll(f)\nif err != nil {\nlog.Fatal(err)\n}\nfmt.Println(string(data))\n}\n</code></pre> <p>The <code>ioutil.ReadAll</code> reads a <code>Reader</code> interface until an error or <code>io.EOF</code> is read.</p>"},{"location":"golang/golang-fundamentals/standard_library/#time","title":"time","text":"<p>The <code>time</code> package is for working with dates, times and datetimes. The package contains two main types: <code>time.Duration</code> and <code>time.Time</code>.</p> <p>A period of time is represented as an <code>int64</code>. The smallest amount of time is one nanosecond. But there are some constants, which can be used to calculate a minute, two seconds and so on:</p> <pre><code>h := 2 * time.Hour // 2 hours\nm := 3 * time.Minute // 3 minutes\nhm := h + m // 2 hours and 3 minutes\n</code></pre> <p><code>time.ParseDuration</code> can parse strings like <code>300ms</code> or <code>2.3h</code>:</p> <pre><code>import (\n\"fmt\"\n\"time\"\n)\nfunc main() {\nhours, _ := time.ParseDuration(\"10h\")\ncomplex, _ := time.ParseDuration(\"1h10m10s\")\nmicro, _ := time.ParseDuration(\"1\u00b5s\")\n// The package also accepts the incorrect but common prefix u for micro.\nmicro2, _ := time.ParseDuration(\"1us\")\nfmt.Println(hours)\nfmt.Println(complex)\nfmt.Printf(\"There are %.0f seconds in %v.\\n\", complex.Seconds(), complex)\nfmt.Printf(\"There are %d nanoseconds in %v.\\n\", micro.Nanoseconds(), micro)\nfmt.Printf(\"There are %6.2e seconds in %v.\\n\", micro2.Seconds(), micro)\n}\n</code></pre> <p>Now we come to a really unusual thing... parsing and formatting datetimes. Go follows the idea to use a format depending on the position in the string: <code>01/02 03:04:05PM 06 -0700</code>.</p> <p>So for example:</p> <pre><code>func main () {\nt, err := time.Parse(\"2006-01-02 15:04:05 -0700\", \"2016-01-13 00:12:43 +0000\")\nif err != nil {\nfmt.Println(err)\n}\nfmt.Println(t.Format(\"January 2, 2006 at 03:04:05PM MST\"))\n}\n</code></pre> <p>output would be:</p> <pre><code>January 13, 2016 at 12:12:43AM UTC\n</code></pre> <p>There are a lot of more functions to manipulate <code>time.Time</code>. Jus see some of the documentation</p>"},{"location":"golang/golang-fundamentals/standard_library/#gostradamus","title":"gostradamus","text":"<p>If you want to work with datetimes and to have a in-replacement for time you can use my Go package: gostradamus. It's a more \"convenient\" way to work with <code>time.Time</code> variables:</p> <pre><code>import (\n\"fmt\"\n\"github.com/bykof/gostradamus\"\n)\nfunc main() {\ndateTime, err := gostradamus.Parse(\"14.07.2017 02:40:00\", \"DD.MM.YYYY HH:mm:ss\")\nif err != nil {\npanic(err)\n}\n// Easy manipulation\ndateTime = dateTime.ShiftMonths(-5).ShiftDays(2)\n// Easy formatting\nfmt.Println(dateTime.Format(\"DD.MM.YYYY HH:mm:ss\"))\n// 16.02.2017 02:40:00\n// Easy helper functions\nstart, end := dateTime.SpanWeek()\nfmt.Println(start.String(), end.String())\n}\n</code></pre> <p>output:</p> <pre><code>16.02.2017 02:40:00\n2017-02-13T00:00:00.000000Z 2017-02-19T23:59:59.999999Z\n</code></pre>"},{"location":"golang/golang-fundamentals/standard_library/#encodingjson","title":"encoding/json","text":"<p>Go has a builtin json parser. It uses the word <code>Marshal</code> (<code>Parse</code>) and <code>Unmarshal</code> (<code>Format</code>) for this library.</p> <p>Also Go uses structs or types to represent JSON object, arrays and so on. You can \"map\" json object fields onto your struct, even when the field names are different.</p> <p>Let's check an example:</p> <pre><code>{\n\"id\": 123,\n\"first_name\": \"Test\",\n\"last_name\": \"Tester\",\n\"birthday\": \"1994-01-19T00:00:00Z\",\n\"skills\": [\n{ \"id\": 1, \"name\": \"Running\" },\n{ \"id\": 1, \"name\": \"Jumping\" }\n]\n}\n</code></pre> <p>now we define a struct to map the data:</p> <pre><code>import (\n\"encoding/json\"\n\"fmt\"\n\"time\"\n)\ntype Skill struct {\nID   int    `json:\"id\"`\nName string `json:\"name\"`\n}\ntype Skills []Skill\ntype Person struct {\nID        int       `json:\"id\"`\nFirstName string    `json:\"first_name\"`\nLastName  string    `json:\"last_name\"`\nBirthday  time.Time `json:\"birthday\"`\nSkills    Skills    `json:\"skills\"`\n}\nfunc main() {\ns := `\n    {\n        \"id\": 123,\n        \"first_name\": \"Test\",\n        \"last_name\": \"Tester\",\n        \"birthday\": \"1994-01-19T00:00:00Z\",\n        \"skills\": [\n            {\"id\": 1, \"name\": \"Running\"},\n            {\"id\": 1, \"name\": \"Jumping\"}\n        ]\n    }`\nvar person Person\nerr := json.Unmarshal([]byte(s), &amp;person)\nif err != nil {\npanic(err)\n}\nfmt.Printf(\"%#v\", person)\n}\n</code></pre> <p>output:</p> <pre><code>main.Person{ID:123, FirstName:\"Test\", LastName:\"Tester\", Birthday:time.Date(1994, time.January, 19, 0, 0, 0, 0, time.UTC), Skills:main.Skills{main.Skill{ID:1, Name:\"Running\"}, main.Skill{ID:1, Name:\"Jumping\"}}}\n</code></pre>"},{"location":"golang/golang-fundamentals/standard_library/#nethttp","title":"net/http","text":"<p>The <code>net/http</code> library has a <code>client</code> and a <code>server</code>. So you can send and receive http requests.</p>"},{"location":"golang/golang-fundamentals/standard_library/#client","title":"client","text":"<p>You can create a <code>http.Client</code> instance with a default timeout:</p> <pre><code>import (\n\"context\"\n\"encoding/json\"\n\"fmt\"\n\"net/http\"\n\"time\"\n)\nfunc main() {\nclient := &amp;http.Client{\nTimeout: 30 * time.Second,\n}\nrequest, err := http.NewRequestWithContext(\ncontext.Background(),\nhttp.MethodGet,\n\"https://jsonplaceholder.typicode.com/todos/1\",\nnil,\n)\nif err != nil {\npanic(err)\n}\nresponse, err := client.Do(request)\nif err != nil {\npanic(err)\n}\ndefer response.Body.Close()\nif response.StatusCode != http.StatusOK {\npanic(fmt.Sprintf(\"got unexpected status: %v\", response.StatusCode))\n}\nvar data struct {\nID        int    `json:\"id\"`\nUserID    int    `json:\"userId\"`\nTitle     string `json:\"title\"`\nCompleted bool   `json:\"completed\"`\n}\nerr = json.NewDecoder(response.Body).Decode(&amp;data)\nif err != nil {\npanic(err)\n}\nfmt.Printf(\"%+v\", data)\n}\n</code></pre> <p>output would be:</p> <pre><code>{ID:1 UserID:1 Title:delectus aut autem Completed:false}%\n</code></pre>"},{"location":"golang/golang-fundamentals/standard_library/#server","title":"server","text":"<p>The server <code>http.ServeMux</code> handles multiple paths. You can combine multiple ServeMux Handlers, but be aware, that you have to strip the path before the request will be given to any underlying handler. Every incoming request will be handled by it's own goroutine.</p> <pre><code>import (\n\"fmt\"\n\"net/http\"\n\"time\"\n)\nfunc main() {\napiMux := http.NewServeMux()\napiMux.HandleFunc(\"/todo/\", func(w http.ResponseWriter, req *http.Request) {\nw.Write([]byte(\"todo\"))\n})\napiMux.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\nw.Write([]byte(\"api\"))\n})\nmux := http.NewServeMux()\nmux.Handle(\"/api/\", http.StripPrefix(\"/api\", apiMux))\nmux.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n// The \"/\" pattern matches everything, so we need to check\n// that we're at the root here.\nif req.URL.Path != \"/\" {\nhttp.NotFound(w, req)\nreturn\n}\nfmt.Fprintf(w, \"Welcome to the home page!\")\n})\nserver := http.Server{\nAddr:         \":8000\",\nReadTimeout:  30 * time.Second,\nWriteTimeout: 60 * time.Second,\nIdleTimeout:  120 * time.Second,\nHandler:      mux,\n}\nerr := server.ListenAndServe()\nif err != nil &amp;&amp; err != http.ErrServerClosed {\npanic(err)\n}\n}\n</code></pre> <p>Sometimes you need a middleware to check if the user is allowed to access an endpoint:</p> main.go<pre><code>const Password = \"notsecurepassword\"\nfunc securityMiddleware(h http.Handler) http.Handler {\nreturn http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\nif req.Header.Get(\"Authorization\") != Password {\nw.WriteHeader(http.StatusUnauthorized)\nw.Write([]byte(\"no access\"))\nreturn\n}\nh.ServeHTTP(w, req)\n})\n}\nfunc requestTimer(h http.Handler) http.Handler {\nreturn http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\nstart := time.Now()\nh.ServeHTTP(w, req)\nend := time.Now()\nlog.Printf(\"request took: %s\", end.Sub(start))\n})\n}\n// ...\nmux.Handle(\n\"/\",\nrequestTimer(\nsecurityMiddleware(\nhttp.HandlerFunc(\nfunc(w http.ResponseWriter, req *http.Request) {\n// The \"/\" pattern matches everything, so we need to check\n// that we're at the root here.\nif req.URL.Path != \"/\" {\nhttp.NotFound(w, req)\nreturn\n}\nfmt.Fprintf(w, \"Welcome to the home page!\")\n},\n),\n),\n),\n)\n</code></pre>"},{"location":"golang/golang-fundamentals/tags/","title":"Tags","text":"<p>Some libraries like <code>encoding/json</code> use tags for more information in a struct.</p> <p>Tags can be fetched by using reflect.</p> <p>Let's check an example:</p> <pre><code>type Person struct {\nFirstName string `json:\"first_name,omitempty\" other:\"hello\"`\n}\nfunc main() {\nperson := Person{\nFirstName: \"Michael\",\n}\npersonType := reflect.TypeOf(person)\nif firstNameField, ok := personType.FieldByName(\"FirstName\"); ok {\nfmt.Println(firstNameField.Tag.Get(\"json\"))\nfmt.Println(firstNameField.Tag.Get(\"other\"))\n}\n}\n</code></pre> <p>output:</p> <pre><code>first_name,omitempty\nhello\n</code></pre>"},{"location":"golang/golang-fundamentals/tags/#json-tags","title":"JSON Tags","text":"<p>If you use, for example <code>encoding/json</code>, you influence how your fields get <code>Marshaled</code> or <code>Unmarshaled</code> Source.</p> <p>We can set the key name of the json object, by using tags. Let's check an example:</p> <pre><code>type Person struct {\nFirstName string `json:\"first_name,omitempty\"`\n}\nfunc main() {\nperson := Person{\nFirstName: \"Michael\",\n}\ndata, err := json.Marshal(person)\nif err != nil {\nfmt.Println(err)\n}\nfmt.Println(string(data))\n}\n</code></pre> <p>output:</p> <pre><code>{\"first_name\":\"Michael\"}\n</code></pre> <p>If we use <code>omitempty</code> on a field and the field value is set to a zero value, then the field will be truncated:</p> <pre><code>person := Person{}\ndata, err := json.Marshal(person)\nif err != nil {\nfmt.Println(err)\n}\nfmt.Println(string(data))\n</code></pre> <p>output:</p> <pre><code>{}\n</code></pre> <p>If we do not use <code>omitempty</code> the field will be included always:</p> <pre><code>type Person struct {\nFirstName string `json:\"first_name\"`\n}\nfunc main() {\nperson := Person{}\ndata, err := json.Marshal(person)\nif err != nil {\nfmt.Println(err)\n}\nfmt.Println(string(data))\n}\n</code></pre> <p>output:</p> <pre><code>{\"first_name\":\"\"}\n</code></pre>"},{"location":"golang/golang-fundamentals/tests/","title":"Tests","text":"<p>Tests are important. Tests check, if you application works as expected. Tests in Go are so easy, it's easier to write tests than not to do it.</p> <p>Normally you will not see any logs from tests, unles you set the <code>-v</code> (verbose) flag.</p> <p>Tests are executed automatically when you name your files <code>*_test.go</code>.</p> <p>Let's dive in with an easy example:</p> calculator.go<pre><code>func add(a, b int) int {\nreturn a + b\n}\n</code></pre> calculator_test.go<pre><code>func Test_add(t *testing.T) {\nresult := add(1, 2)\nexpected := 2\nif result != expected {\nt.Error(\"not correct, expected\", expected, \" got\", result)\n}\n}\n</code></pre> <p>If you run <code>go test ./...</code> the output is:</p> <pre><code>?       example   [no test files]\n--- FAIL: Test_add (0.00s)\n    calculator_test.go:9: not correct, expected 2 got 3\nFAIL\nFAIL    example/calculator        0.153s\nFAIL\n</code></pre> <p>Let's fix the test:</p> calculator_test.go<pre><code>func Test_add(t *testing.T) {\nresult := add(1, 2)\nexpected := 3\nif result != expected {\nt.Error(\"not correct, expected\", expected, \" got\", result)\n}\n}\n</code></pre> <p>Now the tests are running properly:</p> <pre><code>?       example   [no test files]\nok      example/calculator        0.154s\n</code></pre>"},{"location":"golang/golang-fundamentals/tests/#setup-and-teardown","title":"Setup and Teardown","text":"<p>To setup a test use a function called <code>TestMain</code>. To teardown a tests files and data use <code>t.Cleanup(func() { ... })</code>.</p> calculator_test.go<pre><code>func TestMain(m *testing.M) {\nfmt.Println(\"Setting up...\")\nfmt.Println(\"Running tests...\")\nexitValue := m.Run()\nfmt.Println(\"Clean up all tests...\")\nos.Exit(exitValue)\n}\nfunc Test_add(t *testing.T) {\nresult := add(1, 2)\nexpected := 3\nif result != expected {\nt.Error(\"not correct, expected\", expected, \" got\", result)\n}\nt.Cleanup(func() {\nfmt.Println(\"Teardown test\")\n})\n}\n</code></pre> <p>By running the tests with:</p> <pre><code>go test ./... -v\n</code></pre> <p>the output is:</p> <pre><code>?       reader_writer   [no test files]\nSetting up...\nRunning tests...\n=== RUN   Test_add\nTeardown add test\n--- PASS: Test_add (0.00s)\nPASS\nClean up all tests...\nok      reader_writer/calculator        0.152s\n</code></pre>"},{"location":"golang/golang-fundamentals/tests/#public-api-testing","title":"Public API Testing","text":"<p>If you want to test your public exposed functions or methods you can create a \"*_test\" package. This will, by definition, create a new package, which can only access exported functions and methods.</p> <p>Let's check that:</p> calculator/calculator.go<pre><code>func Add(a int, b int) int {\nreturn a + b\n}\n</code></pre> calculator/calculator_test/calculator_test.go<pre><code>package calculator\nimport (\n\"testing\"\n\"example/calculator\"\n)\nfunc Test_Add(t *testing.T) {\nresult := calculator.Add(1, 2)\nexpected := 3\nif result != expected {\nt.Error(\"not correct, expected\", expected, \" got\", result)\n}\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/tests/#testify","title":"Testify","text":"<p>In a lot of projects you will see the package <code>github.com/stretchr/testify/assert</code>. This is because it brings a more \"convenient\" way of testing with assertions, mocking, and suite.</p> <p>Let's check some examples:</p> main.go<pre><code>import (\n\"testing\"\n\"github.com/stretchr/testify/assert\"\n)\nfunc Test_Add(t *testing.T) {\nassert.Equal(t, 3, calculator.Add(1, 2))\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/third_party_libraries/","title":"Third Party Libraries","text":"<ul> <li>gorm: ORM library</li> <li>gin: Web Framework</li> <li>cobra: CLI library</li> <li> <p>zap: Logger Library for Go</p> </li> <li> <p>Go Awesome</p> </li> </ul>"},{"location":"golang/golang-fundamentals/types_interfaces_methods/","title":"Types, Interfaces and Methods","text":""},{"location":"golang/golang-fundamentals/types_interfaces_methods/#types","title":"Types","text":"<p>Go allows you to declare a user-defined type. It can be a struct literal or primitive type. Let's see an example:</p> <pre><code>type Person struct {\nFirstName   string\nLastName    string\n}\ntype Score int\ntype Converter func(string)Score\ntype TeamScores map[string]Score\n</code></pre>"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#methods","title":"Methods","text":"<p>Like many programming languages, Go supports Methods on user-defined types.</p> <pre><code>type Person struct {\nFirstName string\nLastName  string\nAge       int\n}\nfunc (p Person) String() string {\nreturn fmt.Sprintf(\"%s %s: age %d\", p.FirstName, p.LastName, p.Age)\n}\nfunc main() {\np := Person{\nFirstName: \"Michael\",\nLastName:  \"Bykovski\",\nAge:       28,\n}\nfmt.Println(p.String())\n}\n</code></pre> <p>The <code>receiver</code> declares to which type a function belongs to. The receiver is between the <code>func</code> keyword and the method's name and it's usually a short abbreviation of the receiver type and not conventional names like <code>self</code> or <code>this</code>.</p> <p>Method overloading is prohibited. You can use the same name for different user-defined types, but not two methods with the same name for one specific user-defined types.</p>"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#pointer-receivers","title":"Pointer Receivers","text":"<p>As with usual functions the parameters (or receivers) of function are passed by value. This means, that the method will work on a copy of the receiver variable. If you want to modify the receiver variable, you can use pointer receivers:</p> <pre><code>type Counter struct {\ntotal       int\nlastUpdated time.Time\n}\nfunc (c *Counter) Increment() {\nc.total++\nc.lastUpdated = time.Now()\n}\nfunc (c Counter) String() string {\nreturn fmt.Sprintf(\"counts: %d, last updated %v\", c.total, c.lastUpdated)\n}\nfunc main() {\ncounter := Counter{}\nfmt.Println(counter.String())\ncounter.Increment()\nfmt.Println(counter.String())\n}\n</code></pre> <p>output will be:</p> <pre><code>counts: 0, last updated 0001-01-01 00:00:00 +0000 UTC\ncounts: 1, last updated 2009-11-10 23:00:00 +0000 UTC m=+0.000000001\n</code></pre> <p>If you use counter you dont have to convert it to a pointer type, because you use the method of the specific type. So therefore <code>counter.Increment()</code> is converted to <code>(&amp;counter).Increment()</code></p> <p>Be aware if you pass in a copy of a variable and work with the pointer type of it. For example:</p> <pre><code>type Counter struct {\ntotal       int\nlastUpdated time.Time\n}\nfunc (c *Counter) Increment() {\nc.total++\nc.lastUpdated = time.Now()\n}\nfunc (c Counter) String() string {\nreturn fmt.Sprintf(\"counts: %d, last updated %v\", c.total, c.lastUpdated)\n}\nfunc update(counter Counter) {\ncounter.Increment()\n}\nfunc main() {\ncounter := Counter{}\nfmt.Println(counter.String())\nupdate(counter)\nfmt.Println(counter.String())\n}\n</code></pre> <p>will output:</p> <pre><code>counts: 0, last updated 0001-01-01 00:00:00 +0000 UTC\ncounts: 0, last updated 0001-01-01 00:00:00 +0000 UTC\n</code></pre>"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#nil-and-methods","title":"Nil and Methods","text":"<p>If a struct poiner gets declared but not initialized it becomes nil. Implementing pointer receivers on structs can produce a problem. But Go handles it quiet easily:</p> <ul> <li>If you create a nil struct pointer and call a value receiver, it will panic</li> <li>If you create a nil struct pointer and call a pointer receiver, it will try to execute the function</li> </ul> <p>Here are some examples:</p> <pre><code>type Person struct {\nFirstName string\nLastName  string\n}\nfunc (p *Person) ChangeName(newName string) *Person {\nif p == nil {\nreturn &amp;Person{\nLastName: newName,\n}\n}\np.LastName = newName\nreturn p\n}\nfunc (p Person) String() string {\nreturn fmt.Sprintf(\"%s %s\", p.FirstName, p.LastName)\n}\nfunc main() {\nvar person *Person\nnewPerson := person.ChangeName(\"Test\")\nfmt.Println(newPerson.String())\nfmt.Println(person.String())\n}\n</code></pre> <p>output:</p> <pre><code>Test\npanic: runtime error: invalid memory address or nil pointer dereference\n</code></pre>"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#nested-typing-is-not-inheritance","title":"Nested Typing is not Inheritance","text":"<p>One could believe that if you nest different types, you get a similar behaviour like inheratance. But this is not correct. Inheritance would enable the possibility to use the underlying defined methods for the inherited type, but this is not the case. Every type builds it's own \"environment\" with methods. You can't even assign a child type to a parent type, because in Go those type are two different one and don't belong together.</p> <p>Danger</p> <p>This won't work:</p> <pre><code>type Score int\ntype TeamScore Score\nfunc (s Score) Good() bool {\nreturn s &gt; 10\n}\nfunc main() {\nvar score Score\nteamScore := TeamScore(10)\nfmt.Println(\"Team Score is: \", teamScore.Good())\nscore = teamScore\n}\n</code></pre> <p>Success</p> <p>This works:</p> <pre><code>type Score int\ntype TeamScore Score\nfunc (s Score) Good() bool {\nreturn s &gt; 10\n}\nfunc main() {\nvar score Score\nteamScore := TeamScore(10)\nfmt.Println(\"Team Score is: \", Score(teamScore).Good())\nscore = Score(teamScore)\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#iotas-are-enums","title":"iotas are Enums","text":"<p>Go doesn't have the concept of enumerations. But it has <code>iota</code>, which somehow has the same concepts, but different.</p> <p>If you start with <code>iota</code> define an integer type:</p> <pre><code>type PurchasingCategory int\n</code></pre> <p>then start with a <code>const</code> block and define a some iotas:</p> <pre><code>const (\nNoCategory PurchasingCategory = iota\nShirts\nPants\nWatches\nHats\n)\n</code></pre> <p>If the Go compiler sees <code>iota</code> at the end of a line and succeeding lines of constants it will increment each line by one. The first constant <code>NoCategory</code> receives the value <code>0</code>. If you define a new const block with another variable, iota will start again from <code>0</code>.</p> <p>Danger</p> <p>This will not work</p> <pre><code>type Test int\nconst (\none Test = 1\ntwo\nthree\n)\nfunc main() {\nfmt.Println(one, two, three)\n}\n</code></pre> <p>output:</p> <pre><code>1 1 1\n</code></pre> <p>Success</p> <p>This is the correct usage:</p> <pre><code>type Test int\nconst (\none Test = iota\ntwo\nthree\n)\nfunc main() {\nfmt.Println(one, two, three)\n}\n</code></pre> <p>Use iota only if you are not relying on the value of the constants. Because the values can be changed, if you insert a new constant in the middle of the definition block. Use commond constants with a value assigned if you use it for database entries or outgoing messages. Use <code>iotas</code> only for \"internal\" computation, where you need some kind of named constant where the value doesn't matter.</p>"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#embedding-is-composition","title":"Embedding is Composition","text":"<p>There is some kind of inheritance in Go what is called \"Composition\". Let's check an example:</p> <pre><code>package main\nimport (\n\"fmt\"\n\"strings\"\n)\ntype Employee struct {\nName    string\nID  string\n}\nfunc (e Employee) Description() string {\nreturn fmt.Sprintf(\"%s: %s\", e.ID, e.Name)\n}\ntype Project struct {\nName    string\n}\ntype Projects []Project\nfunc (ps Projects) ProjectNames() []string {\nvar names []string\nfor _, project := range ps {\nnames = append(names, project.Name)\n}\nreturn names\n}\ntype SoftwareDeveloper struct {\nEmployee\nProjects Projects\n}\nfunc (sd SoftwareDeveloper) String() string {\nreturn fmt.Sprintf(\n\"%s\\nProjects: \\n%s\",\nsd.Description(),\nstrings.Join(\nsd.Projects.ProjectNames(),\n\"\\n\",\n),\n)\n}\nfunc main () {\ndeveloper := SoftwareDeveloper{\nEmployee: Employee{\nName: \"Michael Bykovski\",\nID: \"1\",\n},\nProjects: Projects{\n{Name: \"Daimler\"},\n{Name: \"Deutsche B\u00f6rse\"},\n},\n}\nfmt.Println(developer)\n}\n</code></pre> <p>It is important to leave the name of the variable of the embedding struct (line 33). If you want to overwrite the embedded function or some field, just do it. They will be still accessable:</p> <pre><code>type Inner struct {\nY int\n}\nfunc (i Inner) String() string {\nreturn fmt.Sprintf(\"%d\", i.Y)\n}\ntype Outer struct {\nInner\nY int\n}\nfunc (o Outer) String() string {\nreturn fmt.Sprintf(\"%d\", o.Y)\n}\nfunc main () {\nouter := Outer{\nInner: Inner{\nY: 5,\n},\nY: 10,\n}\nfmt.Println(outer.String(), outer.Inner.String())\n}\n</code></pre> <p>output:</p> <pre><code>10 5\n</code></pre>"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#embedding-is-not-inheritance","title":"Embedding is not Inheritance","text":"<p>Do not treat embedding as inheritance.</p> <ol> <li>You cannot assign an inherited member to the parent type</li> </ol> <pre><code>type Inner struct {\nY int\n}\ntype Outer struct {\nInner\nY int\n}\nfunc main() {\nvar inner Inner\nouter := Outer{\nInner: Inner{\nY: 1,\n},\nY: 2,\n}\ninner = outer\n}\n</code></pre> <p>output would be:</p> <pre><code>cannot use outer (variable of type Outer) as type Inner in assignment\n</code></pre> <p>this would fix it:</p> <pre><code>func main() {\nvar inner Inner\nouter := Outer{\nInner: Inner{\nY: 1,\n},\nY: 2,\n}\ninner = outer.Inner\n}\n</code></pre> <ol> <li>Go does not dynamically dispatch the Methods</li> </ol> <pre><code>type Inner struct {\nY int\n}\nfunc (i Inner) IntPrinter(value int) string {\nreturn fmt.Sprintf(\"Inner: %d\", value)\n}\nfunc (i Inner) Double() string {\nreturn i.IntPrinter(i.Y * 2)\n}\ntype Outer struct {\nInner\nY int\n}\nfunc (o Outer) IntPrinter(value int) string {\nreturn fmt.Sprintf(\"Outer: %d\", value)\n}\nfunc main() {\nouter := Outer{\nInner: Inner{\nY: 2,\n},\nY: 4,\n}\nfmt.Println(outer.Double())\n}\n</code></pre> <p>If you have a struct, which embeds another struct and you can an embedded function, it will resolve other functions of the struct in the \"embedded scope\".</p>"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#interfaces","title":"Interfaces","text":""},{"location":"golang/golang-fundamentals/types_interfaces_methods/#why-interfaces","title":"Why interfaces?","text":"<p>Tip</p> <p>Interfaces specify behaviour.</p> <p>Interfaces are a tool to make code more reliable, shorter, clearer and easier to understand. But using to much and unnecessary interfaces can have the opposite effect.</p> <p>Let's have a look at the following example:</p> <pre><code>package main\nimport \"fmt\"\ntype Cat struct{}\nfunc (c Cat) Say() string  { return \"meow\" }\nfunc (c Cat) Type() string { return \"cat\" }\ntype Dog struct{}\nfunc (d Dog) Say() string  { return \"woof\" }\nfunc (d Dog) Type() string { return \"dog\" }\nfunc main() {\nc := Cat{}\nfmt.Println(c.Type(), \"says:\", c.Say())\nd := Dog{}\nfmt.Println(d.Type(), \"says:\", d.Say())\n}\n</code></pre> <p>Output:</p> <pre><code>cat says: meow\ndog says: woof\n</code></pre> <p>If we would like to make a function, which takes in a Cat or a Dog and prints out the output message, we would have to create two functions, because of Go's strict typing.</p> <pre><code>func TalkDog(dog Dog) {\nfmt.Println(dog.Type(), \"says:\", dog.Say())\n}\nfunc TalkCat(cat Cat) {\nfmt.Println(cat.Type(), \"says:\", cat.Say())\n}\n</code></pre> <p>But there is help, we can use interfaces.</p>"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#syntax","title":"Syntax","text":"<p>The only abstract type in Go are <code>interfaces</code>.</p> <pre><code>type Stringer interface {\nString() string\n}\n</code></pre> <p>Usually interfaces end with \"er\", there are several Go built-in interfaces like <code>io.Reader</code>, <code>io.Closer</code>, <code>io.ReadCloser</code>, <code>json.Marshaler</code>.</p>"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#implicit-interfaces","title":"Implicit Interfaces","text":"<p>Go Interfaces work in a different way compared to other programming languages. Types implement interfaces by implementing their function signatures. Let's check it out:</p> <pre><code>type ConsoleWriter struct {\nPrefix string\n}\nfunc (cw ConsoleWriter) Write(data string) {\nfmt.Println(cw.Prefix, \":\", data)\n}\ntype Writer interface {\nWrite(data string)\n}\ntype Application struct {\nW Writer\n}\nfunc (a Application) Run() {\na.W.Write(\"Hello World\")\n}\nfunc main() {\napplication := Application{\nW: ConsoleWriter{\nPrefix: \"ConsoleWriter\",\n},\n}\napplication.Run()\n}\n</code></pre> <p><code>Application</code> wants a type that fulfills the <code>Writer</code> interface. Since <code>ConsoleWriter</code> implements the defined function signatures of the <code>Writer</code> interface, it implements automatically the <code>Writer</code> interface.</p> <p>Interfaces are a type and therefore they can be shared like functions, variables and structs. Let's check this example:</p> <pre><code>type ConsoleWriter struct {\nPrefix string\n}\nfunc (cw ConsoleWriter) Write(data string) {\nfmt.Println(cw.Prefix, \":\", data)\n}\ntype Writer interface {\nWrite(data string)\n}\ntype Application struct {\nW Writer\n}\nfunc NewApplication(w Writer) Application {\nreturn Application{\nW: w,\n}\n}\nfunc (a Application) Run() {\na.W.Write(\"Hello World\")\n}\nfunc main() {\nconsoleWriter := ConsoleWriter{\nPrefix: \"ConsoleWriter\",\n}\napplication := NewApplication(consoleWriter)\napplication.Run()\n}\n</code></pre> <p>You can also append new methods to structs which implement interfaces. As long as the signature fulfills the interface, it implements the interface, all other methods belong to the struct. Multiple interface implementations are also possible:</p> <pre><code>type ConsoleWriter struct {\nPrefix string\nCache  string\n}\nfunc (cw ConsoleWriter) Write(data string) {\nfmt.Printf(\"%s: %s (cached: %s)\", cw.Prefix, data, cw.Cache)\ncw.Cache = \"\"\n}\nfunc (cw *ConsoleWriter) Read(data string) {\ncw.Cache = data\n}\nfunc (cw *ConsoleWriter) PurgeCache() {\ncw.Cache = \"\"\n}\ntype Writer interface {\nWrite(data string)\n}\ntype Reader interface {\nRead(data string)\n}\ntype Application struct {\nW Writer\nR Reader\n}\nfunc NewApplication(w Writer, r Reader) Application {\nreturn Application{\nW: w,\nR: r,\n}\n}\nfunc (a Application) Run() {\na.R.Read(\"Hello World\")\na.W.Write(\"Hello Go\")\n}\nfunc main() {\nconsoleWriter := ConsoleWriter{\nPrefix: \"ConsoleWriter\",\n}\napplication := NewApplication(&amp;consoleWriter, &amp;consoleWriter)\napplication.Run()\nconsoleWriter.PurgeCache()\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#embedding-interfaces","title":"Embedding Interfaces","text":"<p>The same way you can embed structs, you can embed interfaces too.</p> <p>Here is an example:</p> <pre><code>type ConsoleWriter struct {\nPrefix string\nCache  string\n}\nfunc (cw ConsoleWriter) Write(data string) {\nfmt.Printf(\"%s: %s (cached: %s)\", cw.Prefix, data, cw.Cache)\ncw.Cache = \"\"\n}\nfunc (cw *ConsoleWriter) Read(data string) {\ncw.Cache = data\n}\nfunc (cw *ConsoleWriter) PurgeCache() {\ncw.Cache = \"\"\n}\ntype Writer interface {\nWrite(data string)\n}\ntype Reader interface {\nRead(data string)\n}\ntype ReaderWriter interface {\nReader\nWriter\n}\ntype Application struct {\nRW ReaderWriter\n}\nfunc NewApplication(readerWriter ReaderWriter) Application {\nreturn Application{\nRW: readerWriter,\n}\n}\nfunc (a Application) Run() {\na.RW.Read(\"Hello World\")\na.RW.Write(\"Hello Go\")\n}\nfunc main() {\nconsoleWriter := ConsoleWriter{\nPrefix: \"ConsoleWriter\",\n}\napplication := NewApplication(&amp;consoleWriter)\napplication.Run()\nconsoleWriter.PurgeCache()\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#accept-interfaces-return-concrete-types","title":"Accept Interfaces, Return Concrete Types","text":"<p>As we want to decouple our code but make it easy to adapt we should build functions that accept interfaces and return concrete types. Because interfaces define a specific functionality our code should accept functionality, run it and return a concrete behaviour or value.</p> <p>Let's take for example:</p> <pre><code>type UserData struct {\n// ...\n}\ntype Authentication struct {\n// ...\n}\nfunc (a Authentication) Auth() (UserData, error) {\n// ...\nreturn UserData{}, nil\n}\nfunc DoAuthentication(a Authentication) (UserData, error) {\n// ...\nreturn a.Auth()\n}\n</code></pre> <p>If we want now to support multiple Auth methods for example, we can open the DoAuthentication for an interface, which defines the Method <code>Auth</code> but we should still a concrete struct, for further implementations:</p> userdata.go<pre><code>type AppleUserData struct {\n// ...\n}\ntype GoogleUserData struct {\n// ...\n}\ntype UserData struct {\nAppleUserData  *AppleUserData\nGoogleUserData *GoogleUserData\n}\nfunc (ud UserData) IsApple() {\n// ...\n}\nfunc (ud UserData) IsGoogle() {\n// ...\n}\ntype Authenticator interface {\nAuth() (UserData, error)\n}\ntype GoogleAuthentication struct {\n// ...\n}\nfunc (ga GoogleAuthentication) Auth() (UserData, error) {\n// ...\nreturn UserData{\nGoogleUserData: &amp;GoogleUserData{\n// ...\n},\n}, nil\n}\ntype AppleAuthentication struct {\n// ...\n}\nfunc (aa AppleAuthentication) Auth() (UserData, error) {\nreturn UserData{\nAppleUserData: &amp;AppleUserData{\n// ...\n},\n}, nil\n}\nfunc DoAuthentication(a Authenticator) (UserData, error) {\nreturn a.Auth()\n}\n</code></pre> <p>Danger</p> <p>Do NOT do this:</p> <pre><code>type UserData struct {\n// ...\n}\ntype UserDataGetter interface {\nUserData() UserData\n}\ntype AppleUserData struct {\n// ...\n}\nfunc (aud AppleUserData) UserData() {\n}\ntype GoogleUserData struct {\n// ...\n}\n// ...\nfunc DoAuthentication(a Authenticator) UserDataGetter {\nreturn a.Auth()\n}\n</code></pre> <p>If you want to read more about \"accept interfaces, return concrete types\" follow this and this</p> <p>The rule is:</p> <p>Unnecessary abstraction creates unnecessary complication. Don\u2019t over complicate code until it\u2019s needed.</p>"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#interface-as-a-type","title":"Interface as a type","text":"<p>An <code>interface</code> can be used as a type. It does the same if you define a user-defined user type. The example above shows a defined interface with no methods. Therefore every type can be used as this interface type.</p> <p>Take a look:</p> <pre><code>func main() {\nvar i interface{}\ni = 2\nfmt.Println(i)\ni = \"test\"\nfmt.Println(i)\ni = func () {\nfmt.Println(\"Test\")\n}\nfmt.Println(i)\ni = struct {\nname string\n} {\nname: \"Michael\",\n}\nfmt.Println(i)\n}\n</code></pre> <p>output:</p> <pre><code>2\ntest\n0x104244000\n{Michael}\n</code></pre> <p>You can also use <code>any</code> as an alias for an empty <code>interface{}</code>. But the empty interface is used regularly.</p> <pre><code>func main() {\nvar i any\ni = 2\nfmt.Println(i)\ni = \"test\"\nfmt.Println(i)\ni = func () {\nfmt.Println(\"Test\")\n}\nfmt.Println(i)\ni = struct {\nname string\n} {\nname: \"Michael\",\n}\nfmt.Println(i)\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#is-struct-implementing-interface-check","title":"Is struct implementing interface check","text":"<p>If you want to check, if a struct implements a specific interface. You can use a small \"hack\".</p> <p>Just initiate a blank identifier variable with the interface type and the struct value.</p> <pre><code>type Sayer interface {\nSay() string\n}\ntype Cat struct{}\nfunc (c Cat) Say() string  { return \"meow\" }\nvar _ Sayer = Cat{}\n</code></pre> <p>Since the compiler will ignore the value of <code>_</code> but will do the type checks, this can get very useful.</p>"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#interfaces-and-nil","title":"Interfaces and nil","text":"<p>Interfaces are nil as long as they:</p> <ol> <li>don't have a type</li> <li>don't have a value</li> </ol> <p>This example should make it clear:</p> <pre><code>var s *string\nfmt.Println(s == nil) // true\nvar i interface{}\nfmt.Println(i == nil) // true\ni = s\nfmt.Println(i == nil) // false\n</code></pre> <p>This tells us, that if an interface has a struct which is nil, it can still run methods of the nil-struct:</p> <pre><code>type Dog struct {}\nfunc (d *Dog) BarkGhost() {\nfmt.Println(\"Woof!\")\n}\nfunc main() {\nvar ghostDog interface{}\nvar dog *Dog\nghostDog = dog\nghostDog.(*Dog).BarkGhost()\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#empty-interface-all-the-way","title":"Empty Interface All The Way","text":"<p>Sometimes you need to define a variable, where you will not know which type it is going to have. Take <code>interface</code> for that:</p> <pre><code>var i interface{}\ni = 10\nfmt.Println(i)\ni = \"Hello\"\nfmt.Println(i)\ni = func(word string) string {\nreturn word\n}\nfmt.Println(i)\n</code></pre> <p>output:</p> <pre><code>10\nHello\n0x47dcc0\n</code></pre> <p>Mostly you won't need an empty interface. Sometimes you will need it to store some really unknown data structure, which comes from an unknown json schema:</p> <pre><code>func main() {\ndata := map[string]interface{}{}\ncontents, err := ioutil.ReadFile(\"data.json\")\nif err != nil {\nreturn err\n}\ndefer contents.Close()\njson.Unmarshal(contents, &amp;data)\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#type-assertions-and-type-switches","title":"Type Assertions and Type Switches","text":""},{"location":"golang/golang-fundamentals/types_interfaces_methods/#type-assertions","title":"Type Assertions","text":"<p>Let's make first a type assertions, so we assert a specific type to an interface variable:</p> <pre><code>type Score int\nfunc main() {\nvar i interface{}\nvar score Score = 20\ni = score\ni2 := i.(Score)\nfmt.Println(i2 + score)\n}\n</code></pre> <p>If you try to assert a type, which could not work, Go will panic:</p> <pre><code>type Score int\nfunc main() {\nvar i interface{}\nvar score Score = 20\ni = score\ni2 := i.(string)\nfmt.Println(i2)\n}\n</code></pre> <p>output:</p> <pre><code>interface conversion: interface {} is main.Score, not string\n</code></pre> <p>The type has to match the exact underlying type, not embedded or type inferenced.</p> <pre><code>type Score int\nfunc main() {\nvar i interface{}\nvar score Score = 20\ni = score\ni2 := i.(int)\nfmt.Println(i2 + score)\n}\n</code></pre> <p>output:</p> <pre><code>interface conversion: interface {} is main.Score, not int\n</code></pre> <p>If you want to test in your code and don't want to panic, use the <code>variable, ok := idiom</code></p> <pre><code>type Score int\nfunc main() {\nvar i interface{}\nvar score Score = 1\ni = score\ni2, ok := i.(int)\nif !ok {\nfmt.Printf(\"i is not an int: %v\", i)\nreturn\n}\nfmt.Println(i2 + 1)\n}\n</code></pre>"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#type-switches","title":"Type Switches","text":"<p>If your <code>interface</code> variable can have multiple types, use a type switch:</p> <pre><code>func checkType(i interface{}) {\nswitch j := i.(type) {\ncase nil:\nfmt.Println(\"i is nil\")\nreturn\ncase int:\nfmt.Println(\"i is an int\")\nreturn\ncase string\nfmt.Println(\"i is a string\")\nreturn\ndefault:\nfmt.Println(\"the type is not defined as case\")\nreturn\n}\n}\n</code></pre>"},{"location":"javascript/","title":"Introduction","text":"<p>If you are on a search for JavaScript expertise, follow here: JavaScript.info</p>"},{"location":"javascript/byot/","title":"Introduction","text":"<p>Build Your Own Tool follows the idea, that you build a small tool with the least effort possible.</p> <p>To achieve this solution there is currently a best practice way to do so.</p> <p>Strapi is an open source headless CMS which is build with JavaScript.</p> <p>Next.JS is a React Framework.</p> <p>You can find the whole example as repository on Github</p>"},{"location":"javascript/byot/add-theme/","title":"Add Theme","text":"<p>We add a theme to our application first with:</p> <pre><code>yarn add 98.css\n</code></pre> <p>and then in the file <code>dashboard/pages/_app.js</code>:</p> <pre><code>import \"../styles/globals.css\";\nimport \"98.css\";\nfunction MyApp({ Component, pageProps }) {\nreturn &lt;Component {...pageProps} /&gt;;\n}\nexport default MyApp;\n</code></pre>"},{"location":"javascript/byot/api/","title":"API","text":""},{"location":"javascript/byot/api/#find","title":"Find","text":"<p>Now after we setup the Content-Type and the Roles &amp; Permissions we are able to access the api:</p> <pre><code>http://localhost:1337/events\n</code></pre> <p>We will get a response like this:</p> <pre><code>[\n{\nid: 1,\nname: \"TechTalk #46 - BYOT - Build Your Own Tool mit Strapi und Next.js!\",\ndescription: \" \"Schnell mal ein Tool bauen\" ist f\u00fcr viele eine gro\u00dfe Herausforderung. Es muss ein Backend mit Datenbankzugriff, REST-Schnittstellen, Benutzerverwaltung und vielen mehr entwickelt werden. Hinzu kommt, dass eine Oberfl\u00e4che f\u00fcr das Eintragen und Anzeigen der Daten implementiert werden muss. Des Weiteren bleibt es meistens nicht bei der Verwaltung und Anzeige der Daten, denn es wird noch dazu ein Gesch\u00e4ftsprozess programmiert. Mit Strapi und Next.JS zeige ich anhand eines Live-Coding-Beispiels, wie ein Event-Verwaltungstool f\u00fcr interne Events eines Unternehmens in unter einer Stunde entwickelt werden kann.\",\nstart: \"2020-10-02T15:00:00.000Z\",\nend: \"2020-10-02T18:00:00.000Z\",\ncreated_by: {\nid: 1,\nfirstname: \"Test\",\nlastname: \"test\",\nusername: null\n},\nupdated_by: {\nid: 1,\nfirstname: \"Test\",\nlastname: \"test\",\nusername: null\n},\ncreated_at: \"2020-09-21T07:20:05.564Z\",\nupdated_at: \"2020-09-21T07:20:05.573Z\"\n}\n]\n</code></pre>"},{"location":"javascript/byot/api/#find-one","title":"Find One","text":"<p>And we can directly access the event with the id:</p> <pre><code>http://localhost:1337/events/1\n</code></pre> <p>Response:</p> <pre><code>{\nid: 1,\nname: \"TechTalk #46 - BYOT - Build Your Own Tool mit Strapi und Next.js!\",\ndescription: \" \"Schnell mal ein Tool bauen\" ist f\u00fcr viele eine gro\u00dfe Herausforderung. Es muss ein Backend mit Datenbankzugriff, REST-Schnittstellen, Benutzerverwaltung und vielen mehr entwickelt werden. Hinzu kommt, dass eine Oberfl\u00e4che f\u00fcr das Eintragen und Anzeigen der Daten implementiert werden muss. Des Weiteren bleibt es meistens nicht bei der Verwaltung und Anzeige der Daten, denn es wird noch dazu ein Gesch\u00e4ftsprozess programmiert. Mit Strapi und Next.JS zeige ich anhand eines Live-Coding-Beispiels, wie ein Event-Verwaltungstool f\u00fcr interne Events eines Unternehmens in unter einer Stunde entwickelt werden kann.\",\nstart: \"2020-10-02T15:00:00.000Z\",\nend: \"2020-10-02T18:00:00.000Z\",\ncreated_by: {\nid: 1,\nfirstname: \"Test\",\nlastname: \"test\",\nusername: null\n},\nupdated_by: {\nid: 1,\nfirstname: \"Test\",\nlastname: \"test\",\nusername: null\n},\ncreated_at: \"2020-09-21T07:20:05.564Z\",\nupdated_at: \"2020-09-21T07:20:05.573Z\"\n}\n</code></pre>"},{"location":"javascript/byot/client/","title":"Client","text":"<p>To communicate with the server, we need to implement a client in the dashboard.</p> <p>And to work easier with HTTP requests and responses, we install Axios:</p> <pre><code>yarn add axios\n</code></pre> <p>Now we implement the client:</p> <p><code>dashboard/client/index.js</code> <pre><code>import Axios from \"axios\";\nexport const API_URL = \"http://localhost:1337\";\nexport const getEvents = async () =&gt; {\nreturn Axios.get(`${API_URL}/events`);\n};\n</code></pre></p>"},{"location":"javascript/byot/content-type/","title":"Content-Type","text":"<p>Let's create our first content type.</p> <p>Imagine we want to build a small tool, which helps a company to store their upcoming and past events.</p> <p>First we need to create a \"content type\". You can compare it to a model or database table, which stores your information.</p> <p>Strapi creates and alters your table in the database automatically, so we just have to setup the content type through the UI.</p> <p>Click on the left side on <code>Content-Types Builder</code> and then on <code>Create new collection type</code>:</p> <p>Then we enter the name of the new content type <code>Event</code> for example:</p> <p>We click on <code>Continue</code> and add a new Textfield to the model:</p> <p>After that we enter \"name\" as name for the field and check the <code>Advanded Settings</code>, where we check <code>required field</code>.</p> <p>Now we do that for description (optional Textfield), start (required DateTimefield), end (required DateTimefield).</p> <p>After we created the fields we should see this model.</p> <p>We press <code>Save</code> to let Strapi create the tables in the database.</p> <p>On the left side under <code>Collection Types</code> should appear <code>Events</code>.</p> <p>We click on <code>Events</code> and then on <code>Add New Event</code>:</p> <p>Enter data for a new event and click on <code>Save</code>:</p>"},{"location":"javascript/byot/implement-the-frontend/","title":"Implement the frontend","text":""},{"location":"javascript/byot/implement-the-frontend/#event-component","title":"<code>Event</code> Component","text":"<p>First let's create a component to show our events later:</p> <p><code>dashboard/components/Event.js</code></p> <pre><code>export const Event = ({ title, description, start, end }) =&gt; {\nconst startDateTime = new Date(start);\nconst endDateTime = new Date(end);\nreturn (\n&lt;div className=\"window\" style={{ width: 300, marginBottom: \"1em\" }}&gt;\n&lt;div className=\"title-bar\"&gt;\n&lt;div className=\"title-bar-text\"&gt;{title}&lt;/div&gt;\n&lt;/div&gt;\n&lt;div className=\"window-body\"&gt;\n&lt;p&gt;{description}&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;\n{startDateTime.toLocaleString()} - {endDateTime.toLocaleString()}\n&lt;/p&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n);\n};\nexport default Event;\n</code></pre>"},{"location":"javascript/byot/implement-the-frontend/#add-react-query","title":"Add react-query","text":"<p>To fetch data properly from the backend server, we will use the library react-query. It is able to fetch, cache, synchronize and update server state.</p> <p>We install it using:</p> <pre><code>yarn add react-query\n</code></pre>"},{"location":"javascript/byot/implement-the-frontend/#events-container","title":"Events Container","text":"<p>Create a container to fetch the data from the server and display it by using our created <code>Event</code> component, our implemented <code>client</code>, and the <code>react-query</code> library.</p> <p><code>dashboard/containers/Events.js</code></p> <pre><code>import { useQuery } from \"react-query\";\nimport { getEvents } from \"../client\";\nimport { Event } from \"../components/Event\";\nexport const Events = () =&gt; {\nconst { isLoading, isError, data: events, error } = useQuery(\n\"events\",\ngetEvents\n);\nif (isLoading) {\nreturn &lt;div&gt;Loading...&lt;/div&gt;;\n}\nif (isError) {\nreturn &lt;div&gt;Error fetching events: {error.toString()}&lt;/div&gt;;\n}\nreturn events.map((event) =&gt; &lt;Event key={event.id} {...event} /&gt;);\n};\nexport default Events;\n</code></pre>"},{"location":"javascript/byot/implement-the-frontend/#glueing-it-all-together","title":"Glueing it all together","text":"<p>Now we are finished and just have to call the <code>Event</code> container in the <code>index.js</code> file.</p> <p><code>dashboard/pages/index.js</code></p> <pre><code>import Head from \"next/head\";\nimport Events from \"../containers/Events\";\nconst mainStyle = {\npadding: 30,\ndisplay: \"flex\",\nalignItems: \"center\",\njustifyContent: \"space-evenly\",\nflexWrap: \"wrap\",\n};\nexport default function Home() {\nreturn (\n&lt;div&gt;\n&lt;Head&gt;\n&lt;title&gt;Events Dashboard&lt;/title&gt;\n&lt;/Head&gt;\n&lt;main style={mainStyle}&gt;\n&lt;Events /&gt;\n&lt;/main&gt;\n&lt;/div&gt;\n);\n}\n</code></pre>"},{"location":"javascript/byot/implement-the-frontend/#result","title":"Result","text":""},{"location":"javascript/byot/installation/","title":"Installation","text":"<p>To setup the projects you need to install Node.JS.</p> <p>Preferably you need yarn.</p>"},{"location":"javascript/byot/roles-and-permissions/","title":"Roles &amp; Permissions","text":"<p>Before we consume our created content type <code>Event</code>, we need to enable the endpoint <code>find</code> and <code>findOne</code> to public API.</p>"},{"location":"javascript/byot/setup-next/","title":"Setup Next.JS","text":"<p>Now that we have setup our headless CMS, we can create a frontend to show an event dashboard for our employees.</p> <p>For that we run:</p> <pre><code>npx create-next-app dashboard\n</code></pre>"},{"location":"javascript/byot/setup/","title":"Setup Strapi","text":"<p>Create a new project with:</p> <pre><code>yarn create strapi-app backend --quickstart\n</code></pre> <p>Now your browser should show up this site:</p>"},{"location":"react/browser-storages/","title":"Browser Storages","text":"<p>There are three storages, which can be accessed easily via the Browser API:</p> Cookies Local Storage Session Storage Capacity 4KB 5MB 5MB Available At HTML4/HTML5 HTML5 HTML5 Accessibility Any window Any window Any window Expiration Manually set Never On tab close Browser Support Very high Very high Very high Supported Data Types String only String only String only Auto Expiry Yes No Yes Storage Location Browser and Server Browser Browser Sent with Requests Yes No No Editable and Blockable Yes Yes Yes Security More secure Less secure Less secure SSL Support Yes No No Server Side Accessibility Yes No No"},{"location":"react/component_lifecycles/","title":"Component Lifecycles","text":"<p>Here are the component lifecycles listed.</p> <p>Let's talk about that a little bit deeper:</p> <p>Example</p> <pre><code>import React from \"react\";\nimport * as ReactDOM from \"react-dom/client\";\nfunction Reactive({ prop }) {\nconst [state, setState] = React.useState();\n// Runs on mount\nReact.useEffect(() =&gt; {\nconsole.log(\"this runs only on component mount\");\n// Runs on unmount\nreturn () =&gt; {\nconsole.log(\"this run when the component unmounts\");\n};\n}, []);\n// Runs on every change of prop and state\nReact.useEffect(() =&gt; {\nconsole.log(\"this runs on every update of prop or state\");\n}, [prop, state]);\n// Returns on every state and prop change\nreturn &lt;button onClick={() =&gt; setState(\"test\")}&gt;Click&lt;/button&gt;;\n}\nfunction Component() {\nconst [isShowReactive, setIsShowReactive] = React.useState(false);\nconst [outerState, setOuterState] = React.useState(\"\");\nreturn (\n&lt;&gt;\n{isShowReactive &amp;&amp; &lt;Reactive prop={outerState} /&gt;}\n&lt;input\nvalue={outerState}\nonChange={(event) =&gt; setOuterState(event.target.value)}\n/&gt;\n&lt;button onClick={() =&gt; setIsShowReactive(!isShowReactive)}&gt;Toggle&lt;/button&gt;\n&lt;/&gt;\n);\n}\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(&lt;Component /&gt;);\n</code></pre>"},{"location":"react/component_structure/","title":"Component Structure","text":"<p>This site shows you some best practices for components and the structure inside of them.</p> <p>Let's first see an example:</p> <p>Example</p> <pre><code>export default function App({isLoggedIn, firstProp, children}) {\nconst { value, setValue, isLoading, error } = React.useContext(SomeContext);\n// use states\nconst [ state, setState ] = React.useState(false);\n// use memos\nconst memo = React.useMemo(() =&gt; {\n...\n}, [state]);\n// use or define callbacks\n// First define useCallbacks, which will be passed into child components\nconst callback = React.useCallback(() =&gt; {\n...\n}, [firstProp])\n// Second define local callbacks for html events\nconst onClick = () =&gt; {\n}\n// use effects\nReact.useEffect(() =&gt; {\n...\n}, [firstProp])\n// make hard conditions\nif (!isLoggedIn) {\nreturn &lt;p&gt;Not allowed&lt;/p&gt;\n}\n// return the actual component\nreturn (\n&lt;&gt;\n&lt;p&gt;You are logged in&lt;/p&gt;\n&lt;button onClick={() =&gt; setState(!state)}&gt;Click&lt;/button&gt;\n&lt;button onClick={onClick}&gt;Another Click&lt;/button&gt;\n{/* if render child react components, use useCallback always! */}\n&lt;AnotherComponent callback={callback}/&gt;\n&lt;/&gt;\n);\n}\n</code></pre>"},{"location":"react/components/","title":"Components","text":"<p>A React component is a small, reusable code, which is responsible for one part of the application UI. A React application is an aggregation of components. React can help us to build reusable components. The following diagram shows different components. All the components have different colors. In React we assemble different components together to create an application. We use JavaScript functions to make components. If we use a function, the component will be a functional component, but if we use a class, the component will be a class-based component.</p> <p></p>"},{"location":"react/components/#creating-react-components","title":"Creating React Components","text":"<p>Using a JavaScript function, we can make a functional React component.</p> <p>A React component has to start with an uppercase letter!</p> <p>This example is the most simple React Component you can image:</p> <p>Example</p> <pre><code>function ComponentName() {\nreturn &lt;p&gt;Content&lt;/p&gt;\n}\n</code></pre> <p>As we know already you can define variables and set the values in JSX:</p> <p>Example</p> <pre><code>function Component() {\nconst user = {\nfirstName: 'Test',\nlastName: 'Tester',\n}\nreturn (\n&lt;&gt;\n&lt;p&gt;{user.firstName}&lt;/p&gt;\n&lt;p&gt;{user.lastName}&lt;/p&gt;\n&lt;/&gt;\n)\n}\n</code></pre> <p>Also you can define styles in the Component:</p> <p>Example</p> <pre><code>function Component() {\nconst user = {\nfirstName: 'Test',\nlastName: 'Tester',\n}\nconst firstNameStyles = {\nfontSize: '24px',\n}\nconst lastNameStyles = {\nfontSize: '18px',\ncolor: 'red',\n}\nreturn (\n&lt;&gt;\n&lt;p style={firstNameStyles}&gt;First Name: {user.firstName}&lt;/p&gt;\n&lt;p style={lastNameStyles}&gt;{user.lastName}&lt;/p&gt;\n&lt;/&gt;\n)\n}\n</code></pre> <p>If you run the example above in Babel you get following JavaScript Code:</p> <p>Example</p> <pre><code>'use strict'\nfunction Component() {\nconst user = {\nfirstName: 'Test',\nlastName: 'Tester',\n}\nconst firstNameStyles = {\nfontSize: '24px',\n}\nconst lastNameStyles = {\nfontSize: '18px',\ncolor: 'red',\n}\nreturn /*#__PURE__*/ React.createElement(\nReact.Fragment,\nnull,\n/*#__PURE__*/ React.createElement(\n'p',\n{\nstyle: firstNameStyles,\n},\n'First Name: ',\nuser.firstName,\n),\n/*#__PURE__*/ React.createElement(\n'p',\n{\nstyle: lastNameStyles,\n},\nuser.lastName,\n),\n)\n}\n</code></pre> <p>As you see, you actually call <code>React.createElement</code> and pass in the element name + the variables you defined.</p> <p>The result of the example is:</p> <p>Example</p> <pre><code>&lt;p style=\"font-size: 24px;\"&gt;First Name: Test&lt;/p&gt;\n&lt;p style=\"font-size: 18px; color: red;\"&gt;Tester&lt;/p&gt;\n</code></pre>"},{"location":"react/components/#nesting-react-components","title":"Nesting React Components","text":"<p>Let's image you have a component, which you would like to insert into another component. Let's see this example:</p> <p>Example</p> <pre><code>function Text() {\nreturn &lt;p&gt;Some Text&lt;/p&gt;\n}\nfunction Wrapper() {\nreturn (\n&lt;&gt;\n{Text()}\n{Text()}\n{Text()}\n&lt;/&gt;\n)\n}\n</code></pre> <p>Because this is not the way <code>Components</code> are meant for, you can actually use React Component Functions as JSX Elements.</p> <p>Components are made for sharing. Because of that, components should be nestable. You can use React Components as JSX Elements to render them out. Let's check a simple example first:</p> <p>Example</p> <pre><code>function Text() {\nreturn &lt;p&gt;Some Text&lt;/p&gt;\n}\nfunction Wrapper() {\nreturn (\n&lt;&gt;\n&lt;Text /&gt;\n&lt;Text /&gt;\n&lt;Text /&gt;\n&lt;/&gt;\n)\n}\n</code></pre> <p>output:</p> <pre><code>&lt;p&gt;Some Text&lt;/p&gt;\n&lt;p&gt;Some Text&lt;/p&gt;\n&lt;p&gt;Some Text&lt;/p&gt;\n</code></pre> <p>if you check the Babel output this is what happens:</p> <p>Example</p> <pre><code>'use strict'\nfunction Text() {\nreturn /*#__PURE__*/ React.createElement('p', null, 'Some Text')\n}\nfunction Wrapper() {\nreturn /*#__PURE__*/ React.createElement(\nReact.Fragment,\nnull,\n/*#__PURE__*/ React.createElement(Text, null),\n/*#__PURE__*/ React.createElement(Text, null),\n/*#__PURE__*/ React.createElement(Text, null),\n)\n}\n</code></pre> <p>The actual function <code>Text</code> gets inserted into <code>React.createElement</code>.</p>"},{"location":"react/conditional_rendering/","title":"Conditional Rendering","text":"<p>As we can understand from the term, conditional rendering is a way to render different JSX or component at different condition. We can implement conditional rendering using regular if and else statement, ternary operator and &amp;&amp;. Let's implement a different conditional rendering.</p>"},{"location":"react/conditional_rendering/#conditional-rendering-using-if-and-else-statement","title":"Conditional Rendering using If and Else statement","text":"<p>The problem with using if and else statements is that you are not allowed to use hooks afterwards.</p> <p>Example</p> <pre><code>const Component = ({ isAllowed }) =&gt; {\nif (isAllowed) {\nreturn &lt;p&gt;You are allowed&lt;/p&gt;\n}\nreturn &lt;p&gt;You are not allowed!&lt;/p&gt;\n}\n</code></pre> <p>An if- and else statement inside a React component is done mostly at the bottom of the component. See an example here:</p> <p>Example</p> <pre><code>const Component = () =&gt; {\nconst { isLoggedIn, isLoading } = React.useContext(AuthenticationContext)\nconst [someState, setSomeState] = React.useState(false)\nif (!isLoggedIn) {\nreturn &lt;p&gt;You are not allowed to see this&lt;/p&gt;\n}\nif (!isLoading) {\nreturn &lt;p&gt;Loading...&lt;/p&gt;\n}\nreturn (\n&lt;p\nonClick={() =&gt; {\nsetSomeState(!someState)\n}}\n&gt;\nCurrently its: {someState}\n&lt;/p&gt;\n)\n}\n</code></pre>"},{"location":"react/conditional_rendering/#ternary-operator","title":"Ternary operator","text":"<p>In most cases you want to switch inside your component between different views. Therefore you will use the conditional operator the OR operator or the AND Operator.</p> <p>Here are some examples:</p> <p>Example</p> <pre><code>const Component = ({ isAllowed }) =&gt; {\nreturn (\n&lt;div&gt;\n&lt;h1&gt;Here is a title&lt;/h1&gt;\n&lt;p&gt;You are {isAllowed ? 'allowed' : 'not allowed'} to enter&lt;/p&gt;\n&lt;/div&gt;\n)\n}\n</code></pre> <p>Example</p> <pre><code>const Component = ({ isAllowed }) =&gt; {\nreturn (\n&lt;div&gt;\n&lt;h1&gt;Here is a title&lt;/h1&gt;\n&lt;p&gt;You are {!isAllowed &amp;&amp; 'not'} allowed to enter&lt;/p&gt;\n&lt;/div&gt;\n)\n}\n</code></pre> <p>Example</p> <pre><code>const Component = ({ value, defaultValue }) =&gt; {\nreturn (\n&lt;div&gt;\n&lt;h1&gt;Here is a title&lt;/h1&gt;\n&lt;p&gt;{value || defaultValue}&lt;/p&gt;\n&lt;/div&gt;\n)\n}\n</code></pre>"},{"location":"react/context/","title":"Context","text":"<p>Context is a very important tool to pass states and props to underlying components.</p>"},{"location":"react/context/#tutorial","title":"Tutorial","text":"<p>First we have to build our context.</p> <p>Let's start by creating a folder called: <code>contexts</code> and inside it we will create a file called <code>CheckContext.js</code>. In the file we create a CheckContext constant which should be exported. We pass the default value in <code>React.createContext({})</code>, which is an empty object <code>{}</code>.</p> <p>After that we create a provider <code>CheckContextProvider</code> of the context, which receives children. <code>CheckContextProvider</code> is actually a React Component which has useEffects, useStates, useMemos and so on. The only difference is that it returns a <code>CheckContext.Provider</code> (note the dot) as JSX Element with just one property <code>value</code>. In <code>value</code> we insert the values which should be passed to all components which consume the context later.</p> <p>Example</p> <pre><code>import React from 'react';\nexport const CheckContext = React.createContext({});\nexport const CheckContextProvider = ({children}) =&gt; {\nconst [isChecked, setIsChecked] = React.useState(false);\nreturn\n(\n&lt;CheckContext.Provider value={{isChecked, setIsChecked}}&gt;\n{children}\n&lt;/CheckContext.Provider&gt;\n)\n}\n</code></pre> <p>Now we have to use the <code>CheckContextProvider</code> in the <code>index.js</code> for example: This means, that all components inside the App component are able to access the context if they define it.</p> <p>Example</p> <pre><code>import { StrictMode } from \"react\";\nimport { createRoot } from \"react-dom/client\";\nimport App from \"./App\";\nimport { CheckContextProvider } from \"./contexts/CheckContext\";\nconst rootElement = document.getElementById(\"root\");\nconst root = createRoot(rootElement);\nroot.render(\n&lt;StrictMode&gt;\n&lt;CheckContextProvider&gt;\n&lt;App /&gt;\n&lt;/CheckContextProvider&gt;\n&lt;/StrictMode&gt;\n);\n</code></pre> <p>Next we can build components, that should exist within the App, that consume the context.</p> <p>Example</p> <pre><code>import React from 'react';\nimport { CheckContext } from '../contexts/CheckContext'\nexport default function Component() {\nconst { setIsChecked } = React.useContext(CheckContext)\nreturn (\n&lt;button onClick={setIsChecked}&gt;\nToggle\n&lt;/button&gt;\n)\n}\n</code></pre> <p>Example</p> <pre><code>import React from 'react';\nimport { CheckContext } from '../contexts/CheckContext'\nexport default function Component() {\nconst { isChecked } = React.useContext(CheckContext)\nreturn (\n&lt;p&gt;\n{isChecked ? 'Is checked' : 'Is not checked'}\n&lt;/p&gt;\n)\n}\n</code></pre>"},{"location":"react/controlled_versus_uncontrolled/","title":"Controlled vs. Uncontrolled","text":"<p>If a React component has an element which changes by itself, it's called uncontrolled. If you handle the rendering with React it's called controlled.</p>"},{"location":"react/controlled_versus_uncontrolled/#examples","title":"Examples","text":""},{"location":"react/controlled_versus_uncontrolled/#controlled","title":"Controlled","text":"<p>You influence controlled inputs by using state and props.</p>"},{"location":"react/controlled_versus_uncontrolled/#uncontrolled","title":"Uncontrolled","text":"<p>You can influence uncontrolled inputs by using ref and manipulating the DOM element directly.</p>"},{"location":"react/controlled_versus_uncontrolled/#pitfalls","title":"Pitfalls","text":"<p>It often happens, when you define a state with an empty default value and use this state as value for your input field. Then you set this state via the <code>onChange</code> method of the input field. What happens then is that a value is being set from <code>undefined -&gt; string</code>. If a prop is <code>undefined</code> it's not defined and there it won't be considered in the DOM element. If you then set the prop the element changes from an uncontrolled to a controlled element. React warns you about this problem. Enter text in the following textfield and check the console.</p>"},{"location":"react/custom_hooks/","title":"Custom Hooks","text":"<p>Lets image you want to have a scroll tracker in a lot of components, but you don't want to implement it in every component. Therefore you can implement a custom hook to outsource the logic and have a \"reactive\" hook.</p>"},{"location":"react/events/","title":"Events","text":""},{"location":"react/events/#what-is-an-event","title":"What is an event?","text":"<p>An event is an action or occurrence recognized by a software. To make an event more clear let's use the daily activities we do when we use a computer such as clicking on a button, hover on an image, pressing a keyboard, scrolling the mouse wheel and etc. The react documentation has already a detail note about events.</p> <p>Handling events in React is very similar to handling elements on DOM elements using pure JavaScript. Some of the syntax difference between handling event in React and pure JavaScript:</p> <ul> <li>React events are named using camelCase, rather than lowercase.</li> <li>With JSX you pass a function as the event handler, rather than a string.</li> </ul> <p>Lets check an example first:</p> <p>Example</p> <pre><code>function App() {\nconst greetPeople = (event) =&gt; {\nalert('Welcome')\n}\nreturn &lt;button onClick={greetPeople}&gt;Welcome&lt;/button&gt;\n}\n</code></pre> <p>However, in React it could be as follows:</p>"},{"location":"react/events/#overview","title":"Overview","text":"Event Type/Category: Events: Event Specific Properties: Clipboard onCopy, onCut, onPaste DOMDataTransfer, clipboardData Composition onCompositionEnd, onCompositionStart, onCompositionUpdate data Keyboard onKeyDown, onKeyPress, onKeyUp altKey, charCode, ctrlKey, getModifierState(key), key, keyCode, locale, location, metaKey, repeat, shiftKey, which Focus onChange, onInput, onSubmit DOMEventTarget, relatedTarget Form onFocus, onBlur Mouse onClick, onContextMenu, onDoubleClick, onDrag, onDragEnd, onDragEnter, onDragExit, onDragLeave, onDragOver, onDragStart, onDrop, onMouseDown, onMouseEnter, onMouseLeave, onMouseMove, onMouseOut, onMouseOver, onMouseUp altKey, button, buttons, clientX, clientY, ctrlKey, getModifierState(key), metaKey, pageX, pageY, DOMEventTarget relatedTarget, screenX, screenY, shiftKey Selection onSelect Touch onTouchCancel, onTouchEnd, onTouchMove, onTouchStart altKey DOMTouchList changedTouches, ctrlKey, getModifierState(key), metaKey, shiftKey, DOMTouchList targetTouches, DOMTouchList touches UI onScroll detail, DOMAbstractView view Wheel onWheel deltaMode, deltaX, deltaY, deltaZ Media onAbort, onCanPlay, onCanPlayThrough, onDurationChange, onEmptied, onEncrypted, onEnded, onError, onLoadedData, onLoadedMetadata, onLoadStart, onPause, onPlay, onPlaying, onProgress, onRateChange, onSeeked, onSeeking, onStalled, onSuspend, onTimeUpdate, onVolumeChange, onWaiting Image onLoad, onError Animation onAnimationStart, onAnimationEnd, onAnimationIteration animationName, pseudoElement, elapsedTime Transition onTransitionEnd propertyName, pseudoElement, elapsedTime"},{"location":"react/fetch_and_useQuery/","title":"Requests and Responses","text":"<p>To retrieve data from a server, you can use HTTP. The browser has already a pretty \"okayish\" request client called <code>fetch</code>. There is a nice library, which is used in many projects, called <code>React Query</code>.</p>"},{"location":"react/fetch_and_useQuery/#fetch","title":"Fetch","text":""},{"location":"react/fetch_and_useQuery/#react-query","title":"React Query","text":""},{"location":"react/forms/","title":"Forms","text":"<p>Forms are important to save input from a user and JavaScript was introduced back in the late 90s, to validate input data.</p> <p>Let's first check an example:</p>"},{"location":"react/forms/#react-hook-forms","title":"React Hook Forms","text":"<p>React Hook Forms is the goto library for React forms Link. It brings a lot of nice functionality like error handling, states and watches.</p>"},{"location":"react/getting_started/","title":"Getting Started","text":"<p>This section covers prerequisites to get started with React. You should have a good understanding of the following technologies:</p> <ul> <li>HTML</li> <li>CSS</li> <li>JavaScript</li> </ul>"},{"location":"react/getting_started/#what-is-react","title":"What is React?","text":"<p>React is a JavaScript library for building a reusable user interface(UI). It was initially released on May 29, 2013. The current version is 18.x.x and it is stable. React was created by Facebook. React makes creating UI components very easy. The official React documentation can be found here. When we work with React we do not interact directly with the DOM. React has its own way to handle the DOM(Document Object Model) manipulation. React uses its virtual DOM to make new changes and it updates only the element, that needs changing. Do not directly interact with DOM when you build a React Application and leave the DOM manipulation job for the React virtual DOM. A web application, or a website, is made of buttons, links, forms with different input fields, header, footer, sections, articles, texts, images, audios, videos and boxes with different shapes. We use react to make a reusable UI components of a website.</p> <p>To summarize:</p> <ul> <li>React was released in May 2013</li> <li>React was created by Facebook</li> <li>React is a JavaScript library for building user interfaces</li> <li>React is used to build single page applications - An application which has only one HTML page.</li> <li>React allows us to create reusable UI components</li> <li>React latest release is 18.x.x</li> <li>React versions</li> <li>React official documentation can be found here</li> </ul>"},{"location":"react/getting_started/#why-react","title":"Why React?","text":"<p>React is one of the most popular JavaScript libraries. Many developers and companies have been using it for the last couple of years. Its popularity has been growing fast and it has a huge community. How do we measure popularity? One measure of popularity could be GitHub repository stars, watchers and forks. Let us compare the popularity of React and Vue. As of today, the popularity between the two most popular JavaScript looks like as shown on the diagram. From the diagram, you can speculate the most popular JavaScript library. You may look at the number of watchers, stars and forks for both React and Vue. These alone will not be a very good measure of popularity, but still it tells a little bit about the popularity of the two technologies. If I have to recommend another JavaScript library next to React, it would be Vue.js.</p>"},{"location":"react/getting_started/#react-vs-vue-vs-angular-popularity-in-october-2022","title":"React vs Vue vs Angular popularity in October 2022","text":"<p>React Official GitHub Repository</p> <p></p> <p>Vue Official GitHub Repository</p> <p></p> <p>Angular Official GitHub Repository</p> <p></p> <p>Why we choose to use React?</p> <ul> <li>fast</li> <li>modular</li> <li>scalable</li> <li>flexible</li> <li>big community and popular</li> <li>open source</li> <li>High job opportunity</li> <li>most used JavaScript rendering library</li> </ul>"},{"location":"react/getting_started/#ide","title":"IDE","text":"<p>Which IDE should you choose?</p> <ul> <li>Webstorm</li> <li>Visual Studio Code</li> </ul> <p>Good extensions for Visual Studio Code:</p> <ul> <li>Prettier</li> <li>Auto Rename Tag</li> <li>npm Intellisense</li> <li>Path Intellisense</li> </ul>"},{"location":"react/hooks/","title":"React Hooks","text":"<p>Hooks are a new addition in React 16.8. They allow you use state, life cycle methods and other React features without writing a class component. If we are using hooks we can have only a functional component in the entire application. For more detail explanation you check React documentation.</p> <p>Different hooks have been introduced to React: Basic hooks and additional hooks</p>"},{"location":"react/hooks/#basic-hooks","title":"Basic Hooks","text":"<p>The basic hooks are:</p> <ul> <li>useState</li> <li>useEffect</li> <li>useContext</li> </ul>"},{"location":"react/hooks/#state-hook","title":"State Hook","text":"<p>Using hooks we can access state.</p> <p>To use hooks, first we should import the <code>useState</code> hooks from react. The useState is a function which takes one argument (the initial value) and returns an array of the current state and a function that lets you update it.</p>"},{"location":"react/hooks/#state-with-data-types","title":"State with Data Types","text":"<p>If you use <code>useState</code> with primitive data types, there is no problem by using operators to set the state with the current value, like in our example above.</p> <p>But if you use non-primitive data types you can't just change the value and set it.</p> <p>Note</p> <p>The reason is that React compares object by strict equality <code>===</code>.</p> <p>Strict equality works for strings, numbers and booleans.</p> <p>For example for strings:</p> <pre><code>const one = 'one'\nconst anotherOne = 'one'\nconst two = 'two'\none === anotherOne\none !== two\n</code></pre> <p>For example for numbers:</p> <pre><code>const one = 1\nconst anotherOne = 1\nconst two = 2\none === anotherOne\none !== two\n</code></pre> <p>For example for booleans:</p> <pre><code>const one = true\nconst anotherOne = true\nconst two = false\none === anotherOne\none !== two\n</code></pre> <p>But it doesn't work for arrays, objects and functions (functions and arrays are objects under the hood), because JavaScript compares the memory address of the variable containing arrays, objects and functions.</p> <p>For example for arrays:</p> <pre><code>const one = ['one']\nconst anotherOne = ['one']\nconst two = ['two']\none !== anotherOne\none !== two\n</code></pre> <p>For example for objects:</p> <pre><code>const one = { one: 'value' }\nconst anotherOne = { one: 'value' }\nconst two = { two: 'value' }\none !== anotherOne\none !== two\n</code></pre> <p>For example for functions:</p> <pre><code>const one = () =&gt; 'one'\nconst anotherOne = () =&gt; 'one'\nconst two = () =&gt; 'two'\none !== anotherOne\none !== two\n</code></pre> <p>You have to create a \"new\" object or copy the old one and set it.</p> <p>Here is a bad example, which won't work:</p> <p>Here is the fixed example:</p> <p>The same happens to arrays:</p> <p>Here is the fixed examle:</p> <p>When a state changes, React will check if the state is used somewhere and update the element.</p>"},{"location":"react/hooks/#effect-hook","title":"Effect Hook","text":"<p>Effects happen, when a state or a prop changes. To watch for changes and do a sideeffect (not computing a value or not preparing a callback) you can use <code>useEffect</code>.</p>"},{"location":"react/hooks/#context","title":"Context","text":"<p><code>useContext</code> will be discussed later in the Context chapter.</p>"},{"location":"react/hooks/#additional-hooks","title":"Additional Hooks","text":"<p>Additional Hooks can be used to express specific statements or to speed up your code.</p> <ul> <li>useReducer</li> <li>useCallback</li> <li>useMemo</li> <li>useRef</li> <li>useImperativeHandle</li> <li>useLayoutEffect</li> <li>useDebugValue</li> <li>useDeferredValue</li> <li>useTransition</li> <li>useId</li> </ul>"},{"location":"react/hooks/#reducer","title":"Reducer","text":"<p>Reducer are handy if you have multiple actions for the same state. For example, if you work on the same state with different functions, then a reducer can be used to define the actions on a state in one place:</p>"},{"location":"react/hooks/#callbacks","title":"Callbacks","text":"<p>Callbacks are important to pass a behaviour into a component from an outer scope. Let's check this example first:</p> <p>You see that an update of our states results in an update for our buttons. Let's improve the code by using <code>useCallback</code> to listen for specific changes:</p> <p>Now the buttons does not update if the other button gets clicked. This can lead to massive performance improvements.</p>"},{"location":"react/hooks/#memo","title":"Memo","text":"<p>If you have some operations, which take a lot of computing time, <code>useMemo</code>. Actually I would say, use always <code>useMemo</code> if you calculate something depending on a state or prop.</p> <p>Here is a bad example:</p> <p>Here we use <code>useMemo</code>, additionally we define the dependency:</p>"},{"location":"react/hooks/#ref","title":"Ref","text":"<p>What if you need to access to the actual html element in the dom, to call a function on the element? You can <code>useRef</code> for that:</p>"},{"location":"react/hooks/#imperative-handle","title":"Imperative Handle","text":""},{"location":"react/hooks/#layout-effect","title":"Layout Effect","text":"<p><code>useLayoutEffect</code> works the same way <code>useEffect</code> works. The signature is identical to useEffect, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint.</p>"},{"location":"react/hooks/#debug-value","title":"Debug Value","text":"<p><code>useDebugValue</code> shows a value in React DevTools.</p> <pre><code>function useFriendStatus(friendID) {\nconst [isOnline, setIsOnline] = useState(null)\n// Show a label in DevTools next to this Hook  // e.g. \"FriendStatus: Online\"\nuseDebugValue(isOnline ? 'Online' : 'Offline')\nreturn isOnline\n}\n</code></pre>"},{"location":"react/hooks/#deferred-value","title":"Deferred Value","text":"<p><code>useDeferredValue</code> receives a state variable and returns a new state variable, which will wait until all rendering finishes for the given state variable and then rerenders the deferred value.</p> <pre><code>function Typeahead() {\nconst query = useSearchQuery('')\nconst deferredQuery = useDeferredValue(query)\n// Memoizing tells React to only re-render when deferredQuery changes,\n// not when query changes.\nconst suggestions = useMemo(\n() =&gt; &lt;SearchSuggestions query={deferredQuery} /&gt;,\n[deferredQuery],\n)\nreturn (\n&lt;&gt;\n&lt;SearchInput query={query} /&gt;\n&lt;Suspense fallback=\"Loading results...\"&gt;{suggestions}&lt;/Suspense&gt;\n&lt;/&gt;\n)\n}\n</code></pre>"},{"location":"react/hooks/#transition","title":"Transition","text":"<p><code>useTransition</code> can handle loading states.</p>"},{"location":"react/hooks/#id","title":"ID","text":"<p><code>useId</code> is a hook for generating unique IDs that are stable across the server and client, while avoiding hydration mismatches.</p> <p>Warning</p> <p><code>useId</code> is not for generating keys in a list. Keys should be generated from your data.</p> <pre><code>function Checkbox() {\nconst id = useId()\nreturn (\n&lt;&gt;\n&lt;label htmlFor={id}&gt;Do you like React?&lt;/label&gt;\n&lt;input id={id} type=\"checkbox\" name=\"react\" /&gt;\n&lt;/&gt;\n)\n}\n</code></pre>"},{"location":"react/jsx/","title":"JSX","text":"<p>JSX stands for JavaScript XML. JSX allows us to write HTML elements with JavaScript code. An HTML element has an opening and closing tags, content, and attribute in the opening tag. However, some HTML elements may not have content and a closing tag - they are self closing elements.</p> <p>Example</p> <pre><code>const content = 'Test'\nconst style = {background: 'red', color: 'white'}\nconst element = &lt;p style={style}&gt;{content}&lt;/p&gt;\n</code></pre>"},{"location":"react/jsx/#babel","title":"Babel","text":"<p>To create HTML elements in React we do not use the <code>createElement()</code> instead we just use JSX elements. Therefore, JSX makes it easier to write and add HTML elements in React. JSX will be converted to JavaScript on browser using a transpiler - babel.js. Babel is a library which transpiles JSX to pure JavaScript and latest JavaScript to older version. See the JSX code below.</p> <p>In conclusion with Babel this:</p> <p>Example</p> <pre><code>const a = &lt;h1 id=\"123\"&gt;test&lt;/h1&gt;\n</code></pre> <p>becomes this:</p> <p>Example</p> <pre><code>'use strict'\nconst a = /*#__PURE__*/ React.createElement(\n'h1',\n{\nid: '123',\n},\n'test',\n)\n</code></pre> <p>JSX is stricter than html. If you write for example <code>&lt;br&gt;</code> in HTML this becomes valid. If you write the same in JSX, it will throw an error.</p> <p>Therefore you have to close every element properly:</p> <p>Example</p> <pre><code>&lt;br /&gt;\n</code></pre>"},{"location":"react/jsx/#expressions-in-jsx","title":"Expressions in JSX","text":"<p>If you work with JSX, you can use expressions to inject values into jsx code:</p> <p>Example</p> <pre><code>const value = 123\nconst element = &lt;p&gt;{value}&lt;/p&gt;\n</code></pre> <pre><code>&lt;p&gt;123&lt;/p&gt;\n</code></pre> <p>Expressions produce values. According to MDN an expression is:</p> <pre><code>An expression is any valid unit of code that resolves to a value.\n</code></pre> <p>Do not confuse it with statements which produce code statements, assignments and expressions.</p> Statements Expressions <code>let a = 1 + 2</code> <code>1 + 2</code> <code>if (1 === 2) { return 3 } else { return 4 }</code> <code>1 === 2 ? 3 : 4</code> <p>For example, you can also use the result of a function inside of jsx:</p> <p>Example</p> <pre><code>function formatName(user) {\nreturn `${user.firstName} ${user.lastName}`\n}\nconst user = {\nfirstName: 'Test',\nlastName: 'Tester',\n}\nconst element = &lt;h1&gt;Hello, {formatName(user)}! &lt;/h1&gt;\n</code></pre> result<pre><code>&lt;h1&gt;Hello, Test Tester&lt;/h1&gt;\n</code></pre>"},{"location":"react/jsx/#attributes-in-jsx","title":"Attributes in JSX","text":"<p>You can specify attributes in JSX:</p> <p>Example</p> <pre><code>const h1Id = 'testId'\nconst element = &lt;h1 id={h1Id}&gt;Test&lt;/h1&gt;\n</code></pre> <p>Warning</p> <p>Since JSX is closer to JavaScript than to HTML, React DOM uses camelCase property naming convention instead of HTML attribute names.</p> <p>For example, class becomes className in JSX, and tabindex becomes tabIndex.</p>"},{"location":"react/jsx/#children-in-jsx","title":"Children in JSX","text":"<p>We discussed simple elements for now. But when HTML elements can have children, JSX elements can have them too:</p> <p>Example</p> <pre><code>const container = (\n&lt;div&gt;\n&lt;h1&gt;Hello World&lt;/h1&gt;\n&lt;p&gt;Some text&lt;/p&gt;\n&lt;/div&gt;\n)\n</code></pre> <p>Warning</p> <p>Do not use nested elements without paranthesis.</p> <p>This is a false example:</p> <pre><code>const container =\n&lt;div&gt;\n&lt;h1&gt;Hello World&lt;/h1&gt;\n&lt;p&gt;Some text&lt;/p&gt;\n&lt;/div&gt;\n</code></pre> <p>Warning</p> <p>Note that you cannot use multiple elements as JSX:</p> <pre><code>// this won't work!\nconst container = (\n&lt;h1&gt;Hello World&lt;/h1&gt;\n&lt;p&gt;Some text&lt;/p&gt;\n)\n</code></pre> <p>You have to wrap multiple elements into an outer element. This can be another html element or the 'empty' element <code>&lt;&gt;...</code></p> <p>For example:</p> <p>Example</p> <pre><code>const container = (\n&lt;div&gt;\n&lt;h1&gt;Hello World&lt;/h1&gt;\n&lt;p&gt;Some text&lt;/p&gt;\n&lt;/div&gt;\n)\n</code></pre> <p>will result as HTML in the DOM as:</p> result<pre><code>&lt;div&gt;\n&lt;h1&gt;Hello World&lt;/h1&gt;\n&lt;p&gt;Some text&lt;/p&gt;\n&lt;/div&gt;\n</code></pre> <p>Example</p> <pre><code>const container = (\n&lt;&gt;\n&lt;h1&gt;Hello World&lt;/h1&gt;\n&lt;p&gt;Some text&lt;/p&gt;\n&lt;/&gt;\n)\n</code></pre> <p>will result als HTML in the DOM as:</p> result<pre><code>&lt;h1&gt;Hello World&lt;/h1&gt;\n&lt;p&gt;Some text&lt;/p&gt;\n</code></pre>"},{"location":"react/jsx/#adding-styles","title":"Adding styles","text":"<p>If you want to add a style to a JSX element, you can use <code>className</code> (instead of the html <code>class</code>) or <code>style</code>. Please note, that <code>style</code> will be overwritten by Babel so that you cannot use just a string, but you use an object:</p> <p>Example</p> <pre><code>const container = (\n&lt;p style={{ color: 'red', fontSize: '' }} className={'bordered'}&gt;\nabc\n&lt;/p&gt;\n)\n</code></pre>"},{"location":"react/mantine/","title":"Mantine","text":"<p>Mantine is a beautiful library to create frontend applications fast. It contains a lot of well designed and accessability-proven components, to use and customize them.</p> <p>Mantine Docs</p>"},{"location":"react/mantine/#mantine-ui","title":"Mantine UI","text":"<p>Mantine UI is a set of prebuilt Mantine Components, which can be used to build your frontend application even faster!</p> <p>Mantine UI</p>"},{"location":"react/openapi/","title":"OpenAPI (Swagger)","text":"<p>If you have a Swagger file you can generate code by use openapi-generator Install openapi-generator according to the <code>Getting Started</code>.</p> <p>You can generate an openapi client by using this: </p> <pre><code>openapi-generator-cli generate \\ \n    -g javascript \\\n    -o out \\ \n    -i &lt;insert json swagger endpoint here&gt;\n</code></pre>"},{"location":"react/popular-libraries/","title":"Popular Libraries and other sources","text":"<p>Tao of React</p>"},{"location":"react/popular-libraries/#component-libraries","title":"Component libraries","text":"<ul> <li>Mantine</li> <li>Material UI</li> <li>Chakra UI</li> </ul>"},{"location":"react/popular-libraries/#communication-libraries","title":"Communication libraries","text":"<p>REST:</p> <ul> <li>Tanstack Query (former react-query)</li> <li>SWR</li> </ul> <p>GraphQL:</p> <ul> <li>Apollo</li> </ul>"},{"location":"react/popular-libraries/#other-libraries","title":"Other libraries","text":"<p>Workers (Heavy Background Tasks):</p> <ul> <li>useWorker</li> </ul> <p>Hook Libraries:</p> <ul> <li>react-use</li> <li>ahooks</li> </ul>"},{"location":"react/project_structure/","title":"Project Structure","text":"<p>To have a good <code>software-architecture</code> I can give you a short glimpse about how a React application should be structured. There is a framework called Next.JS, which always have some groundbreaking ideas on how to build things in React. They also defined a React application structure, which is, in my opinion, the current best structure. I think that, because I used it in three different React projects and it always went really well.</p> <p>So here is the structure:</p> <p>Example</p> <pre><code>my-app/\n|- node_modules\n|- public/\n|   |- favicon.ico\n|   |- index.html\n|   |- robots.txt\n|   |- imgs\n|- src/\n|   |- index.js\n|   |- pages/\n|   |   |- index.js\n|   |   |- about.js\n|   |   |- products/\n|   |   |   |- index.js\n|   |   |   |- [id].js\n|   |- components/\n|   |   |- Product.js\n|   |   |- ProductList.js\n|   |- clients/\n|   |   |- productService\n|   |   |   |- index.js\n|   |   |   |- ...\n|   |- contexts/\n|   |   |   |- AuthenticationContext.js\n</code></pre>"},{"location":"react/props/","title":"Props","text":""},{"location":"react/props/#what-is-props","title":"What is props?","text":"<p>Props is a special keyword in React that stands for properties and is being used to pass data from one component to another and mostly from parent component to child component. We can say props is a data carrier or a means to transport data.</p> <p>I hope you are familiar with the JavaScript function. Most of the time, functions with parameters are smart and they can take dynamic data likewise props is a way we pass data or parameter to a component. Let's see the difference between a function and a component.</p> <p>In a React component function you will always get the first parameter as an object, which represents your</p> <p>Example</p> <pre><code>// JavaScript\nconst getUserInfo = (firstName, lastName, country) =&gt; {\nreturn `${firstName} ${lastName}. Lives in ${country}.`\n}\nconst userInfo = getUserInfo('Test', 'Tester', 'Finland')\n// JSX\nfunction User(props) {\nreturn (\n&lt;div&gt;\n&lt;h1&gt;\n{props.firstName}\n{props.lastName}\n&lt;/h1&gt;\n&lt;small&gt;{props.country}&lt;/small&gt;\n&lt;/div&gt;\n)\n}\nconst renderedUser = (\n&lt;User firstName={'Test'} lastName={'Tester'} country={'Finland'} /&gt;\n)\n</code></pre> <p> </p> React passing `props` into JSX Element"},{"location":"react/props/#children","title":"Children","text":"<p>If you nest JSX Elements you can decide how to wrap the child elements of your component. The word <code>children</code> is a reserved keyword to pass in the child elements into your component.</p> <p>You can pick elements and render them separately or render them all at one (which is the most common case)</p> <p>Example</p> <pre><code>function User(props) {\nreturn (\n&lt;div&gt;\n{props.children}\n&lt;/div&gt;\n)\n}\nconst renderedUser = (\n&lt;User&gt;\n&lt;p&gt;Test&lt;/p&gt;\n&lt;p&gt;Tester&lt;/p&gt;\n&lt;/User&gt;\n)\n</code></pre> <p>the result is:</p> <pre><code>&lt;div&gt;\n&lt;p&gt;Test&lt;/p&gt;\n&lt;p&gt;Tester&lt;/p&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"react/props/#different-data-type-props","title":"Different data type props","text":""},{"location":"react/props/#string-props-type","title":"String props type","text":"<p>Strings are easy to pass into components</p> <p>Example</p> <pre><code>function Component(props) {\nreturn &lt;div&gt;{props.text}&lt;/div&gt;\n}\nconst component = &lt;Component text={'Hello World!'} /&gt;\n</code></pre> <p>the result is:</p> <pre><code>&lt;div&gt;Hello World!&lt;/div&gt;\n</code></pre>"},{"location":"react/props/#number-props-type","title":"Number props type","text":"<p>Let's use a number props to a component</p> <p>Example</p> <pre><code>function Component(props) {\nreturn &lt;div&gt;{props.year}&lt;/div&gt;\n}\nconst component = &lt;Component year={2022} /&gt;\n</code></pre> <p>the result is:</p> <pre><code>&lt;div&gt;2022&lt;/div&gt;\n</code></pre>"},{"location":"react/props/#boolean-props-type","title":"Boolean props type","text":"<p>We can pass boolean data types to a React component but they do not get rendered.</p> <p>Example</p> <pre><code>function Component(props) {\nreturn &lt;div&gt;{props.isChecked}&lt;/div&gt;\n}\nconst component = &lt;Component isChecked={true} /&gt;\n</code></pre> <p>the result is:</p> <pre><code>&lt;div&gt;&lt;/div&gt;\n</code></pre> <p>Boolean types do not get rendered with their <code>.toString()</code> method. Therefore you have to set the value, which should be rendered.</p> <p>Example</p> <pre><code>function Component(props) {\nreturn &lt;div&gt;{props.isChecked ? 'is checked' : 'not checked'}&lt;/div&gt;\n}\nconst component = &lt;Component isChecked={true} /&gt;\n</code></pre> <p>the result is:</p> <pre><code>&lt;div&gt;is checked&lt;/div&gt;\n</code></pre>"},{"location":"react/props/#array-props-type","title":"Array props type","text":"<p>In programming arrays and objects are the most frequently used data structure to solve different problems and store data in a more structured way. Therefore, we encounter data in the form of an array quite often. Let's pass an array as props to a component</p> <p>Example</p> <pre><code>function Component(props) {\nreturn &lt;div&gt;{props.skills}&lt;/div&gt;\n}\nconst component = &lt;Component skills={['HTML', 'CSS', 'JavaScript']} /&gt;\n</code></pre> <p>the result is:</p> <pre><code>&lt;div&gt;HTMLCSSJavaScript&lt;/div&gt;\n</code></pre> <p>In this case, react tries to iterate over the array and render each element. In the example above we are lucky, because we have only strings. If we would use something not renderable like a boolean, React wouldn't show anything.</p> <p>Example</p> <pre><code>function Component(props) {\nreturn &lt;div&gt;{props.skills}&lt;/div&gt;\n}\nconst component = &lt;Component skills={[true, false, true]} /&gt;\n</code></pre> <p>the result is:</p> <pre><code>&lt;div&gt;&lt;/div&gt;\n</code></pre> <p>In the most cases you would wrap each element in a HTML element or prerender the given array elements:</p> <p>Wrap each array element in a HTML element</p> <pre><code>function Component(props) {\nreturn &lt;ul&gt;{props.skills.map((skill) =&gt; &lt;li&gt;{skill}&lt;/li&gt;)}&lt;/ul&gt;\n}\nconst component = &lt;Component skills={['HTML', 'CSS', 'JavaScrip']} /&gt;\n</code></pre> <p>the result is:</p> <pre><code>&lt;ul&gt;\n&lt;li&gt;HTML&lt;/li&gt;\n&lt;li&gt;CSS&lt;/li&gt;\n&lt;li&gt;JavaScript&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre> <p>Render prerendered JSX element</p> <pre><code>function Component(props) {\nreturn &lt;ul&gt;{props.skills}&lt;/ul&gt;\n}\nconst component = &lt;Component skills={[&lt;li&gt;HTML&lt;/li&gt;, &lt;li&gt;CSS&lt;/li&gt;, &lt;li&gt;JavaScript&lt;/li&gt;]} /&gt;\n</code></pre> <p>the result is:</p> <pre><code>&lt;ul&gt;\n&lt;li&gt;HTML&lt;/li&gt;\n&lt;li&gt;CSS&lt;/li&gt;\n&lt;li&gt;JavaScript&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>"},{"location":"react/props/#object-props-type","title":"Object props type","text":"<p>We may pass an object as props to a React component. Let's see an example.</p> <p>Example</p> <pre><code>function Component(props) {\nreturn &lt;p&gt;{props.user.firstName} {props.user.lastName}&lt;/p&gt;\n}\nconst component = &lt;Component user={{firstName: 'Test', lastName: 'Tester'}} /&gt;\n</code></pre> <p>the result is:</p> <pre><code>&lt;p&gt;Test Tester&lt;/p&gt;\n</code></pre> <p>When we use an object as props we usually destructure the data to access the values. Destructuring makes our code easy to read.</p> <p>Example</p> <pre><code>function Component(props) {\nconst {firstName, lastName} = props.user\nreturn &lt;p&gt;{firstName} {lastName}&lt;/p&gt;\n}\nconst component = &lt;Component user={{firstName: 'Test', lastName: 'Tester'}} /&gt;\n</code></pre> <p>the result is:</p> <pre><code>&lt;p&gt;Test Tester&lt;/p&gt;\n</code></pre>"},{"location":"react/props/#function-prop-types","title":"Function prop types","text":"<p>We can pass a function as props type to a React component. Functions passed in React Compoents are often used as callbacks</p> <p>Let's see some examples</p> <p>Example</p> <pre><code>function Component(props) {\nreturn &lt;p&gt;{props.callback()}&lt;/p&gt;\n}\nconst component = &lt;Component callback={() =&gt; 'Hello World'} /&gt;\n</code></pre> <p>the result is:</p> <pre><code>&lt;p&gt;Hello World&lt;/p&gt;\n</code></pre>"},{"location":"react/props/#default-props","title":"Default Props","text":"<p>You can define default or optional props, by assigning values or defining undefined to them:</p> <p>Example</p> <pre><code>function Component({firstName = 'Default', lastName='Default'}) {\nreturn (\n&lt;p&gt;\n{firstName} {lastName}\n&lt;/p&gt;\n);\n}\nconst component = (\n&lt;Component firstName={'Test'} lastName={'Tester'} /&gt;\n);\nconst defaultComponent = &lt;Component /&gt;;\n</code></pre> <p>the result is:</p> <pre><code>&lt;p&gt;Test Tester&lt;/p&gt;\n&lt;p&gt;Default Default&lt;/p&gt;\n</code></pre>"},{"location":"react/react-router/","title":"React Router","text":"<p>https://reactrouter.com/en/main</p>"},{"location":"react/setting_up/","title":"Setting Up","text":"<p>Here we will learn, how to setup a React project fast, so that we don't have to setup every dependency by ourselves.</p>"},{"location":"react/setting_up/#create-react-app","title":"Create React App","text":"<p>To create a react project you can use one of the following ways. Let's assume you installed node. Open the command line interface (CLI), git bash or terminal on Mac or Linux. Then run the following command. I am using git bash.</p> <pre><code>npx create-react-app name-of-your-project\n</code></pre> <p>If you do not like to write npx every time you create a project you may install create-react-app package globally in your computer using the following command.</p> <pre><code>npm install -g create-react-app\n</code></pre> <p>After you installed create-react-app, you create a React application as follows:</p> <pre><code>create-react-app name-of-project\n</code></pre>"},{"location":"react/setting_up/#your-first-react-app","title":"Your first React App","text":"<pre><code>cd Desktop/\n</code></pre> <pre><code>npx create-react-app react-app\n</code></pre> <pre><code>cd react-app\n</code></pre> <pre><code>npm start\n</code></pre> <p>Now your React app should run at localhost 3000. Go to the App.js and modify the content by writing some text, you will see the latest changes on the browser. To stop the server, press Ctr + C in the CLI.</p> <p></p>"},{"location":"react/setting_up/#react-boilerplate","title":"React Boilerplate","text":"<p>Let's see the React boilerplate, which has been created by create-react-app. Whenever you create a new project, you run create-react-app and name of the project.</p> <p>In the following React boilerplate, there are three folders: node_modules, public and src. In addition, there are .gitignore, README.md, package.json and yarn.lock. Some of you, instead of yarn.lock, you may have package-lock.json.</p> <p>It is good to know these folders and files.</p> <ul> <li> <p><code>node_modules</code> - stores all the necessary node packages of the React applications.</p> </li> <li> <p><code>/public</code></p> <ul> <li><code>index.html</code> - the only HTML file we have in the entire application</li> <li><code>favicon.ico</code> - an icon file</li> <li><code>manifest.json</code> - is used to make the application a progressive web app</li> <li><code>other images</code> - open graph images(open graph images are images which are visible when a link share on social media)</li> <li><code>robots.txt</code> - information, if the website allows web scraping</li> </ul> </li> <li> <p>/src</p> <ul> <li><code>App.css, index.css</code> - are CSS files</li> <li><code>index.js</code> - a file which allows to connect all the components with index.html</li> <li><code>App.js</code> - A file where we usually import most of the presentational components</li> <li><code>App.test.js</code> - Tests with testing library and jest</li> <li><code>reportWebVitals.js</code>: is useful to collect Web Vitals information</li> <li><code>setupTests.js</code> - to write testing cases</li> <li><code>logo.svg</code> - just a svg file</li> </ul> </li> <li> <p><code>package.json</code> - List of packages the applications uses</p> </li> <li><code>.gitignore</code> - React boilerplate comes with git initiated, and the .gitingore allows files and folders not to be pushed to GitHub</li> <li><code>README.md</code> - Markdown file to write documentation</li> <li><code>yarn.lock</code> or <code>package-lock.json</code> - a means to lock the version of the package</li> </ul>"}]}