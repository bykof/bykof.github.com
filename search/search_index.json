{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome! On this website you will find lectures about: Webengineering React Workshop Go Lectures Go Fundamentals Dependency Injection in Go Build Go Docker images Architecture and Best Practices Design Patterns Or just click in the left upper corner on Javascript Light/Dark Mode Just switch between Light and Dark mode with the switch in the navigation at the top beside the search input field. Feel free to visit my website: https://bykovski.de","title":"Welcome!"},{"location":"#welcome","text":"On this website you will find lectures about: Webengineering React Workshop Go Lectures Go Fundamentals Dependency Injection in Go Build Go Docker images Architecture and Best Practices Design Patterns Or just click in the left upper corner on Javascript","title":"Welcome!"},{"location":"#lightdark-mode","text":"Just switch between Light and Dark mode with the switch in the navigation at the top beside the search input field. Feel free to visit my website: https://bykovski.de","title":"Light/Dark Mode"},{"location":"exercises/","text":"Exercises","title":"Exercises"},{"location":"exercises/#exercises","text":"","title":"Exercises"},{"location":"exercises/browser-api/shop/","text":"Shop Exercise Let's continue with our shopping example in exercise JavaScript Fundamentals - Shop . Now we build an interface for the shop. It will look like this: responsive, mobile-ready, fast as hell \ud83d\udd25! Quickstart Example Use this example to start: index.html Note: Your browser will try to render the index.html, so just download and start to edit it. After downloading the example, try to add a JavaScript file as resource. Lastly just double-click the index.html file to see it in the browser.","title":"Shop Exercise"},{"location":"exercises/browser-api/shop/#shop-exercise","text":"Let's continue with our shopping example in exercise JavaScript Fundamentals - Shop . Now we build an interface for the shop. It will look like this: responsive, mobile-ready, fast as hell \ud83d\udd25!","title":"Shop Exercise"},{"location":"exercises/browser-api/shop/#quickstart-example","text":"Use this example to start: index.html Note: Your browser will try to render the index.html, so just download and start to edit it. After downloading the example, try to add a JavaScript file as resource. Lastly just double-click the index.html file to see it in the browser.","title":"Quickstart Example"},{"location":"exercises/go/projects/product_service/","text":"Product Service Domain Driven Hexagonal Architecture You are the main dev of a big online shop. The old product service is written in an esoteric language, which cannot handle more than 10.000 requests per second. Now you want to try Go, so let's do this! Create a RESTful service with the http web-framework Gin . It has the following endpoints: GET /product - List all articles GET /product/{id} - Get a specific article POST /product - Create a product PUT /product/{id} - Update a product DELETE /product/{id} - Delete a product The product struct uses the package https://pkg.go.dev/github.com/shopspring/decimal for prices: core/domain/product.go 1 2 3 4 5 6 7 8 9 10 import ( \"github.com/shopspring/decimal\" ) type Product struct { ID int64 Name string Category string Price decimal . Decimal } The service should have two possible ways to store products and categories. It should store all data in memory or in json files called products.json . Use interfaces , domain driven hexagonal architecture and dependency injection to built the service properly. Example Requests: Create products Request: POST /products { \"name\": \"iPhone 14 Pro\", \"price\": 99.99, \"category\": \"smartphones\" } Response: POST /products: 200 1 Request: POST /products { \"name\": \"iPhone 12 Pro\", \"price\": 999.99, \"category\": \"smartphones\" } Response: POST /products: 200 2 Request: POST /products { \"price\": 999.99, \"category\": \"smartphones\" } Response: POST /products: 400 { \"error\": \"Key: 'ProductBody.Name' Error:Field validation for 'Name' failed on the 'required' tag\" } Get products Request: GET /products Response: GET /products: 200 [ { \"id\": 1, \"name\": \"iPhone 14 Pro\", \"category\": \"smartphones\", \"price\": \"99.99\" }, { \"id\": 2, \"name\": \"iPhone 13 Pro\", \"category\": \"smartphones\", \"price\": \"999.99\" } ] Get a specific product Request: GET /products/1 Response: GET /products/1: 200 { \"id\": 1, \"name\": \"iPhone 14 Pro\", \"category\": \"smartphones\", \"price\": \"99.99\" } Request: GET /products/999 Response: GET /products/999: 404 { \"error\": \"could not find product with id: 999\" } Update a product Request: PUT /products/1 { \"name\": \"iPhone 11 Pro\", \"category\": \"smartphones\", \"price\": \"999.99\" } Response: PUT /products/1: 200 { \"name\": \"iPhone 11 Pro\", \"category\": \"smartphones\", \"price\": \"999.99\" } Delete a product Request: DELETE /products/1 Response: DELETE /products/1: 204","title":"Product Service"},{"location":"exercises/go/projects/product_service/#product-service","text":"Domain Driven Hexagonal Architecture You are the main dev of a big online shop. The old product service is written in an esoteric language, which cannot handle more than 10.000 requests per second. Now you want to try Go, so let's do this! Create a RESTful service with the http web-framework Gin . It has the following endpoints: GET /product - List all articles GET /product/{id} - Get a specific article POST /product - Create a product PUT /product/{id} - Update a product DELETE /product/{id} - Delete a product The product struct uses the package https://pkg.go.dev/github.com/shopspring/decimal for prices: core/domain/product.go 1 2 3 4 5 6 7 8 9 10 import ( \"github.com/shopspring/decimal\" ) type Product struct { ID int64 Name string Category string Price decimal . Decimal } The service should have two possible ways to store products and categories. It should store all data in memory or in json files called products.json . Use interfaces , domain driven hexagonal architecture and dependency injection to built the service properly. Example Requests:","title":"Product Service"},{"location":"exercises/go/projects/product_service/#create-products","text":"Request: POST /products { \"name\": \"iPhone 14 Pro\", \"price\": 99.99, \"category\": \"smartphones\" } Response: POST /products: 200 1 Request: POST /products { \"name\": \"iPhone 12 Pro\", \"price\": 999.99, \"category\": \"smartphones\" } Response: POST /products: 200 2 Request: POST /products { \"price\": 999.99, \"category\": \"smartphones\" } Response: POST /products: 400 { \"error\": \"Key: 'ProductBody.Name' Error:Field validation for 'Name' failed on the 'required' tag\" }","title":"Create products"},{"location":"exercises/go/projects/product_service/#get-products","text":"Request: GET /products Response: GET /products: 200 [ { \"id\": 1, \"name\": \"iPhone 14 Pro\", \"category\": \"smartphones\", \"price\": \"99.99\" }, { \"id\": 2, \"name\": \"iPhone 13 Pro\", \"category\": \"smartphones\", \"price\": \"999.99\" } ]","title":"Get products"},{"location":"exercises/go/projects/product_service/#get-a-specific-product","text":"Request: GET /products/1 Response: GET /products/1: 200 { \"id\": 1, \"name\": \"iPhone 14 Pro\", \"category\": \"smartphones\", \"price\": \"99.99\" } Request: GET /products/999 Response: GET /products/999: 404 { \"error\": \"could not find product with id: 999\" }","title":"Get a specific product"},{"location":"exercises/go/projects/product_service/#update-a-product","text":"Request: PUT /products/1 { \"name\": \"iPhone 11 Pro\", \"category\": \"smartphones\", \"price\": \"999.99\" } Response: PUT /products/1: 200 { \"name\": \"iPhone 11 Pro\", \"category\": \"smartphones\", \"price\": \"999.99\" }","title":"Update a product"},{"location":"exercises/go/projects/product_service/#delete-a-product","text":"Request: DELETE /products/1 Response: DELETE /products/1: 204","title":"Delete a product"},{"location":"exercises/go/projects/school/","text":"School A school needs a programm, to store pupils, teachers, lessons and classrooms. The program should have a menu to display it: *** School Program *** Choose one of the following options: 1. Add a pupil 2. Add a teacher 3. Add a classroom 4. Add a lesson 5. Add pupils to lesson 6. List all pupils 7. List all teachers 8. List all classrooms 9. List all lessons 10. List lessons of classroom (11. List lessons of pupil) (12. List lessons of teacher) Your choice: Program 11 and 12 are Bonus parts. If you choose menu 1, following should be printed: Add a pupil: > Enter first name: Michael > Enter last name: Bykovsi > Enter grade: 10 > Pupil #1 Michael Bykovski successfully added Add a pupil: > Enter first name: Tanja > Enter last name: Stark > Enter grade: 10 > Pupil #2 Tanja Stark successfully added If you choose menu 2: Add a teacher: > Enter first name: Peter > Enter last name: Lustig > Enter teaching area: Deutsch und Biologie > Teacher #1 Peter Lustig successfully added If you choose menu 3: Add a classroom: > Enter room number: 405 > Enter location: Hauptgeb\u00e4ude > Classroom #1 405 Hauptgeb\u00e4ude successfully added If you choose menu 4 the following input should be Add a lesson: > Enter lesson name: Deutsche Grammatik #2 > Enter semester: SS22 > Enter classroom id: 1 > Enter teacher id: 2 > Teacher with id 2 does not exist, please choose an existing teacher id! > Enter teacher id: 1 > Lesson #1 Deutsche Grammatik #2 successfully added If you choose menu 5: Add pupils to lesson: > Enter lesson id: 1 > Enter pupils separated by comma: 1,2 > Pupils: - #1 Michel Bykovski - #2 Tanja Stark were added to the lesson #1 Deutsche Grammatik #2 If you choose menu 6: List of pupils: #1 Michael Bykovski (10) #2 Tanja Stark (10) If you choose menu 7: List of teachers: #1 Peter Lustig - Teaching Area: Deutsch und Biologie If you choose menu 8: List of classrooms: #1 405 Hauptgeb\u00e4ude If you choose menu 9: List of lessons: #1 Deutsche Grammatik #2 - Semester: SS22 - Classroom: #1 405 Hauptgeb\u00e4ude - Teacher: #1 Peter Lustig If you choose menu 10: > Which classroom you would like to see? > 1 #1 405 Hauptgeb\u00e4ude - #1 Deutsche Grammatik #2 - Teacher: #1 Peter Lustig - Pupils: - #1 Michael Bykovski - #2 Tanja Stark Bonus task: If you choose menu 11: > Which pupil you would like to see? > 2 #2 Tanja Stark - #1 Deutsche Grammatik #2 - Teacher: #1 Peter Lustig - Classroom: #1 405 Hauptgeb\u00e4ude If you choose menu 12: > Which teacher you would like to see? > 1 #1 Peter Lustig - #1 Deutsche Grammatik #2 - Classroom: #1 405 Hauptgeb\u00e4ude Start with this: main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \"bufio\" \"fmt\" \"os\" ) func main () { for { reader := bufio . NewReader ( os . Stdin ) fmt . Printf ( \"Your choice: \" ) command , _ := reader . ReadString ( '\\n' ) fmt . Println ( command ) } }","title":"School"},{"location":"exercises/go/projects/school/#school","text":"A school needs a programm, to store pupils, teachers, lessons and classrooms. The program should have a menu to display it: *** School Program *** Choose one of the following options: 1. Add a pupil 2. Add a teacher 3. Add a classroom 4. Add a lesson 5. Add pupils to lesson 6. List all pupils 7. List all teachers 8. List all classrooms 9. List all lessons 10. List lessons of classroom (11. List lessons of pupil) (12. List lessons of teacher) Your choice: Program 11 and 12 are Bonus parts. If you choose menu 1, following should be printed: Add a pupil: > Enter first name: Michael > Enter last name: Bykovsi > Enter grade: 10 > Pupil #1 Michael Bykovski successfully added Add a pupil: > Enter first name: Tanja > Enter last name: Stark > Enter grade: 10 > Pupil #2 Tanja Stark successfully added If you choose menu 2: Add a teacher: > Enter first name: Peter > Enter last name: Lustig > Enter teaching area: Deutsch und Biologie > Teacher #1 Peter Lustig successfully added If you choose menu 3: Add a classroom: > Enter room number: 405 > Enter location: Hauptgeb\u00e4ude > Classroom #1 405 Hauptgeb\u00e4ude successfully added If you choose menu 4 the following input should be Add a lesson: > Enter lesson name: Deutsche Grammatik #2 > Enter semester: SS22 > Enter classroom id: 1 > Enter teacher id: 2 > Teacher with id 2 does not exist, please choose an existing teacher id! > Enter teacher id: 1 > Lesson #1 Deutsche Grammatik #2 successfully added If you choose menu 5: Add pupils to lesson: > Enter lesson id: 1 > Enter pupils separated by comma: 1,2 > Pupils: - #1 Michel Bykovski - #2 Tanja Stark were added to the lesson #1 Deutsche Grammatik #2 If you choose menu 6: List of pupils: #1 Michael Bykovski (10) #2 Tanja Stark (10) If you choose menu 7: List of teachers: #1 Peter Lustig - Teaching Area: Deutsch und Biologie If you choose menu 8: List of classrooms: #1 405 Hauptgeb\u00e4ude If you choose menu 9: List of lessons: #1 Deutsche Grammatik #2 - Semester: SS22 - Classroom: #1 405 Hauptgeb\u00e4ude - Teacher: #1 Peter Lustig If you choose menu 10: > Which classroom you would like to see? > 1 #1 405 Hauptgeb\u00e4ude - #1 Deutsche Grammatik #2 - Teacher: #1 Peter Lustig - Pupils: - #1 Michael Bykovski - #2 Tanja Stark Bonus task: If you choose menu 11: > Which pupil you would like to see? > 2 #2 Tanja Stark - #1 Deutsche Grammatik #2 - Teacher: #1 Peter Lustig - Classroom: #1 405 Hauptgeb\u00e4ude If you choose menu 12: > Which teacher you would like to see? > 1 #1 Peter Lustig - #1 Deutsche Grammatik #2 - Classroom: #1 405 Hauptgeb\u00e4ude Start with this: main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \"bufio\" \"fmt\" \"os\" ) func main () { for { reader := bufio . NewReader ( os . Stdin ) fmt . Printf ( \"Your choice: \" ) command , _ := reader . ReadString ( '\\n' ) fmt . Println ( command ) } }","title":"School"},{"location":"exercises/go/starter/","text":"Starter For some starter tasks just clone yourself the repository: https://github.com/bykof/golang-workshop-tasks If you want to see the solutions, just switch the branch to: solutions .","title":"Starter"},{"location":"exercises/go/starter/#starter","text":"For some starter tasks just clone yourself the repository: https://github.com/bykof/golang-workshop-tasks If you want to see the solutions, just switch the branch to: solutions .","title":"Starter"},{"location":"exercises/javascript-fundamentals/","text":"Introduction Here you will find some exercises for JavaScript Fundamentals. Starting with the exercises To start with the exercises I can recommend you following steps: install Node.JS Link create a folder: mkdir -p js-exercises/javascript-fundamentals/shop go to the folder: cd js-exercises/javascript-fundamentals/shop init a node package: npm init -y add a new script in the package.json see at the bottom : add an index.js : touch index.js write your code and start the index.js with npm run start package.json { \"name\" : \"shop\" , \"version\" : \"1.0.0\" , \"main\" : \"index.js\" , \"license\" : \"MIT\" , \"devDependencies\" : { \"jest\" : \"^26.5.3\" }, \"scripts\" : { \"start\" : \"node index.js\" } }","title":"Introduction"},{"location":"exercises/javascript-fundamentals/#introduction","text":"Here you will find some exercises for JavaScript Fundamentals.","title":"Introduction"},{"location":"exercises/javascript-fundamentals/#starting-with-the-exercises","text":"To start with the exercises I can recommend you following steps: install Node.JS Link create a folder: mkdir -p js-exercises/javascript-fundamentals/shop go to the folder: cd js-exercises/javascript-fundamentals/shop init a node package: npm init -y add a new script in the package.json see at the bottom : add an index.js : touch index.js write your code and start the index.js with npm run start","title":"Starting with the exercises"},{"location":"exercises/javascript-fundamentals/#packagejson","text":"{ \"name\" : \"shop\" , \"version\" : \"1.0.0\" , \"main\" : \"index.js\" , \"license\" : \"MIT\" , \"devDependencies\" : { \"jest\" : \"^26.5.3\" }, \"scripts\" : { \"start\" : \"node index.js\" } }","title":"package.json"},{"location":"exercises/javascript-fundamentals/shop/","text":"Shopping Exercise Online Shopping has a really heavy impact on all industries around the world. Therefore we try it ourselves and implement a small Node.JS shop, but in offline mode. Let's start! Add customer Add a customer and ask for firstname, lastname, street, city, phone, email and then print out an incrementing customer number. Example *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit > 1 Firstname: Michael Lastname: Tester Street: Shoppingstreet 12 Postal Code: 123456 City: Shop Phone: 0174 123 123 Email: tester@test.com Customer #1 was added! *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit > Add Product Add a product with a product number, name, and a product price in cent amount. If you use a product number, which was already used, just overwrite it. Example *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit > 2 Number: s1 Name: Nintendo Switch Price (in cents): 19999 Product #s1 was added! Errors If the Price in cents is not an integer , let the customer enter an integer until it's correct: Number: 1 Name: Switch Price (in cents): asdf Please reenter a correct price as cents. Price (in cents): Add New Order Create a new order and store the draft order in the current application until the user is able to save it with menu item 8 . Example *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit > 3 Please enter the customer number: 1 1 Order #1 was created *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders 7: Add OrderItem 8: Save order x: Exit Errors If the customer could not be found, let the user reenter the customer number until the correct customer number is entered: Please enter the customer number: f Customer could not be found. Please enter the customer number: Add OrderItem Add an product with a specific amount to the current draft order. Example *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders 7: Add OrderItem 8: Save order x: Exit > 7 Please enter the product number: 1 Please enter the amount: 3 Errors If the product number does not exist, let the user reenter until the product can be found: Please enter the product number: 3 Product could not be found. Please enter the product number: If the amount is not an integer, let the user reenter until it's an integer: Please enter the amount: asd Please enter a number as amount. Please enter the amount: Save order Saving the order just removes the possibility to add OrderItems to the current draft order. Example *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders 7: Add OrderItem 8: Save order x: Exit > 8 Order was saved! *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit Print Customers Just print out all customers. Hint: Use console.table Example *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit > 4 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 (index) \u2502 number \u2502 firstName \u2502 lastName \u2502 street \u2502 city \u2502 postalCode \u2502 email \u2502 phone \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 '1' \u2502 'Test' \u2502 'Tester' \u2502 'Teststreet 12' \u2502 '123456' \u2502 'Testcity' \u2502 'test@test.com' \u2502 '0123456789' \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Print products Print all products. Example > 5 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 (index) \u2502 number \u2502 name \u2502 price \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 's1' \u2502 'Switch' \u2502 Price { amount: 19999 } \u2502 \u2502 1 \u2502 'p1' \u2502 'Playstation 4' \u2502 Price { amount: 39999 } \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Print orders Print all orders Hint: Don't use console.table here! Example > 6 > 6 -------------------------------------------------- Order #1 for 1 - Test Tester ------------------------- 1x #s1 Switch - 199.99 ------------------------- 3x #p1 Playstation 4 - 399.99 Sum: 1399.96 -------------------------------------------------- -------------------------------------------------- Order #2 for 2 - Another Testy ------------------------- 2x #s1 Switch - 199.99 ------------------------- 1x #p1 Playstation 4 - 399.99 Sum: 799.97 --------------------------------------------------","title":"Shopping Exercise"},{"location":"exercises/javascript-fundamentals/shop/#shopping-exercise","text":"Online Shopping has a really heavy impact on all industries around the world. Therefore we try it ourselves and implement a small Node.JS shop, but in offline mode. Let's start!","title":"Shopping Exercise"},{"location":"exercises/javascript-fundamentals/shop/#add-customer","text":"Add a customer and ask for firstname, lastname, street, city, phone, email and then print out an incrementing customer number.","title":"Add customer"},{"location":"exercises/javascript-fundamentals/shop/#example","text":"*** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit > 1 Firstname: Michael Lastname: Tester Street: Shoppingstreet 12 Postal Code: 123456 City: Shop Phone: 0174 123 123 Email: tester@test.com Customer #1 was added! *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit >","title":"Example"},{"location":"exercises/javascript-fundamentals/shop/#add-product","text":"Add a product with a product number, name, and a product price in cent amount. If you use a product number, which was already used, just overwrite it.","title":"Add Product"},{"location":"exercises/javascript-fundamentals/shop/#example_1","text":"*** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit > 2 Number: s1 Name: Nintendo Switch Price (in cents): 19999 Product #s1 was added!","title":"Example"},{"location":"exercises/javascript-fundamentals/shop/#errors","text":"If the Price in cents is not an integer , let the customer enter an integer until it's correct: Number: 1 Name: Switch Price (in cents): asdf Please reenter a correct price as cents. Price (in cents):","title":"Errors"},{"location":"exercises/javascript-fundamentals/shop/#add-new-order","text":"Create a new order and store the draft order in the current application until the user is able to save it with menu item 8 .","title":"Add New Order"},{"location":"exercises/javascript-fundamentals/shop/#example_2","text":"*** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit > 3 Please enter the customer number: 1 1 Order #1 was created *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders 7: Add OrderItem 8: Save order x: Exit","title":"Example"},{"location":"exercises/javascript-fundamentals/shop/#errors_1","text":"If the customer could not be found, let the user reenter the customer number until the correct customer number is entered: Please enter the customer number: f Customer could not be found. Please enter the customer number:","title":"Errors"},{"location":"exercises/javascript-fundamentals/shop/#add-orderitem","text":"Add an product with a specific amount to the current draft order.","title":"Add OrderItem"},{"location":"exercises/javascript-fundamentals/shop/#example_3","text":"*** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders 7: Add OrderItem 8: Save order x: Exit > 7 Please enter the product number: 1 Please enter the amount: 3","title":"Example"},{"location":"exercises/javascript-fundamentals/shop/#errors_2","text":"If the product number does not exist, let the user reenter until the product can be found: Please enter the product number: 3 Product could not be found. Please enter the product number: If the amount is not an integer, let the user reenter until it's an integer: Please enter the amount: asd Please enter a number as amount. Please enter the amount:","title":"Errors"},{"location":"exercises/javascript-fundamentals/shop/#save-order","text":"Saving the order just removes the possibility to add OrderItems to the current draft order.","title":"Save order"},{"location":"exercises/javascript-fundamentals/shop/#example_4","text":"*** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders 7: Add OrderItem 8: Save order x: Exit > 8 Order was saved! *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit","title":"Example"},{"location":"exercises/javascript-fundamentals/shop/#print-customers","text":"Just print out all customers. Hint: Use console.table","title":"Print Customers"},{"location":"exercises/javascript-fundamentals/shop/#example_5","text":"*** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit > 4 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 (index) \u2502 number \u2502 firstName \u2502 lastName \u2502 street \u2502 city \u2502 postalCode \u2502 email \u2502 phone \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 '1' \u2502 'Test' \u2502 'Tester' \u2502 'Teststreet 12' \u2502 '123456' \u2502 'Testcity' \u2502 'test@test.com' \u2502 '0123456789' \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Example"},{"location":"exercises/javascript-fundamentals/shop/#print-products","text":"Print all products.","title":"Print products"},{"location":"exercises/javascript-fundamentals/shop/#example_6","text":"> 5 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 (index) \u2502 number \u2502 name \u2502 price \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 's1' \u2502 'Switch' \u2502 Price { amount: 19999 } \u2502 \u2502 1 \u2502 'p1' \u2502 'Playstation 4' \u2502 Price { amount: 39999 } \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Example"},{"location":"exercises/javascript-fundamentals/shop/#print-orders","text":"Print all orders Hint: Don't use console.table here!","title":"Print orders"},{"location":"exercises/javascript-fundamentals/shop/#example_7","text":"> 6 > 6 -------------------------------------------------- Order #1 for 1 - Test Tester ------------------------- 1x #s1 Switch - 199.99 ------------------------- 3x #p1 Playstation 4 - 399.99 Sum: 1399.96 -------------------------------------------------- -------------------------------------------------- Order #2 for 2 - Another Testy ------------------------- 2x #s1 Switch - 199.99 ------------------------- 1x #p1 Playstation 4 - 399.99 Sum: 799.97 --------------------------------------------------","title":"Example"},{"location":"exercises/react/","text":"","title":"Index"},{"location":"exercises/react/components/","text":"Components / JSX First create a React Project with create-react-app . Take this user information: co nst users = [ { \"firstName\" : \"John\" , \"lastName\" : \"Smith\" , \"email\" : \"john@example.com\" , \"profilePicture\" : \"https://images.pexels.com/photos/6206980/pexels-photo-6206980.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1\" , \"phone\" : \"+1 (123) 456-7890\" , \"address\" : { \"street\" : \"9062 Mertz Plains Apt. 623\" , \"buildingNumber\" : \"410\" , \"city\" : \"Boganside\" , \"zipcode\" : \"71562\" , \"country\" : \"Estonia\" }, \"website\" : \"http://www.johnsmith.com\" }, { \"firstName\" : \"Raegan\" , \"lastName\" : \"Haley\" , \"email\" : \"ustroman@hotmail.com\" , \"profilePicture\" : \"https://images.pexels.com/photos/733872/pexels-photo-733872.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1\" , \"phone\" : \"+5089956276536\" , \"address\" : { \"street\" : \"2922 Retha Plaza\" , \"city\" : \"Lake Gail\" , \"zipcode\" : \"26859-4338\" , \"country\" : \"Mozambique\" }, \"website\" : \"http://zboncak.biz\" } ] And create the following website with React.js by using React components.","title":"Components / JSX"},{"location":"exercises/react/components/#components-jsx","text":"First create a React Project with create-react-app . Take this user information: co nst users = [ { \"firstName\" : \"John\" , \"lastName\" : \"Smith\" , \"email\" : \"john@example.com\" , \"profilePicture\" : \"https://images.pexels.com/photos/6206980/pexels-photo-6206980.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1\" , \"phone\" : \"+1 (123) 456-7890\" , \"address\" : { \"street\" : \"9062 Mertz Plains Apt. 623\" , \"buildingNumber\" : \"410\" , \"city\" : \"Boganside\" , \"zipcode\" : \"71562\" , \"country\" : \"Estonia\" }, \"website\" : \"http://www.johnsmith.com\" }, { \"firstName\" : \"Raegan\" , \"lastName\" : \"Haley\" , \"email\" : \"ustroman@hotmail.com\" , \"profilePicture\" : \"https://images.pexels.com/photos/733872/pexels-photo-733872.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1\" , \"phone\" : \"+5089956276536\" , \"address\" : { \"street\" : \"2922 Retha Plaza\" , \"city\" : \"Lake Gail\" , \"zipcode\" : \"26859-4338\" , \"country\" : \"Mozambique\" }, \"website\" : \"http://zboncak.biz\" } ] And create the following website with React.js by using React components.","title":"Components / JSX"},{"location":"exercises/react/context/","text":"JSX Setup React locally","title":"JSX"},{"location":"exercises/react/context/#jsx","text":"Setup React locally","title":"JSX"},{"location":"exercises/react/forms/","text":"JSX Setup React locally","title":"JSX"},{"location":"exercises/react/forms/#jsx","text":"Setup React locally","title":"JSX"},{"location":"exercises/react/hooks/","text":"Hooks useState Take your solution from the Components / JSX section and add following behaviour: useMemo Improve the code function Component () { const [ state , setState ] = React . useState ( 0 ); const calculate = () => { let a = 0 ; for ( let i = 0 ; i < 10 _000 ; i ++ ) { for ( let j = 0 ; j < 10 _000 ; j ++ ) { a += i + j ; } } return a ; }; return ( < div > < button onClick = {() => setState ( state + 1 )} > Add + 1 < /button> < pre > { state } < /pre> { calculate ()} < /div> ); } export default function App () { return < Component /> ; }","title":"Hooks"},{"location":"exercises/react/hooks/#hooks","text":"","title":"Hooks"},{"location":"exercises/react/hooks/#usestate","text":"Take your solution from the Components / JSX section and add following behaviour:","title":"useState"},{"location":"exercises/react/hooks/#usememo","text":"Improve the code function Component () { const [ state , setState ] = React . useState ( 0 ); const calculate = () => { let a = 0 ; for ( let i = 0 ; i < 10 _000 ; i ++ ) { for ( let j = 0 ; j < 10 _000 ; j ++ ) { a += i + j ; } } return a ; }; return ( < div > < button onClick = {() => setState ( state + 1 )} > Add + 1 < /button> < pre > { state } < /pre> { calculate ()} < /div> ); } export default function App () { return < Component /> ; }","title":"useMemo"},{"location":"exercises/react/mantine/","text":"JSX Setup React locally","title":"JSX"},{"location":"exercises/react/mantine/#jsx","text":"Setup React locally","title":"JSX"},{"location":"exercises/react/requests/","text":"JSX Setup React locally","title":"JSX"},{"location":"exercises/react/requests/#jsx","text":"Setup React locally","title":"JSX"},{"location":"exercises/react/routing/","text":"JSX Setup React locally","title":"JSX"},{"location":"exercises/react/routing/#jsx","text":"Setup React locally","title":"JSX"},{"location":"exercises/react/routing/01_jsx/","text":"JSX Setup React locally","title":"JSX"},{"location":"exercises/react/routing/01_jsx/#jsx","text":"Setup React locally","title":"JSX"},{"location":"golang/","text":"Introduction Welcome to my Golang lectures. On the left side you will find several topics of this lecture.","title":"Introduction"},{"location":"golang/#introduction","text":"Welcome to my Golang lectures. On the left side you will find several topics of this lecture.","title":"Introduction"},{"location":"golang/architecture/","text":"Architecture and Best Practices in Go For best practices written by the Go team check out Effective Go Currently the best architecture for Go applications, in my opinion, is the domain driven hexagonal architecture: Link . It's so suitable because Go provides loosely coupled interface implementation to use dependency injection and packaging makes it clear, which struct belongs to which \"layer\". Two Known Architecture Principles There are two known architecture principles in Go. The \"flat\" architecture and the \"domain driven\" architecture. Let's take a look at two examples: Cobra Go Cache Cobra uses the flat architecture. Go Cache uses the domain driven approach, at least it utilizes packages. Mostly the flat architecture is used, when the Go programm is small and does just one thing. If the Go program becomes more complicated and does several things, I would suggest to use the domain driven hexagonal approach. Getter In Go it's unusual to use Get before a getter. You often just remove the Get in a getter method so that you access it with .Thing() . 1 2 3 4 owner := obj . Owner () if owner != user { obj . SetOwner ( user ) } Interface Names Interface names are often defined with er as suffix. Like Reader , Writer , Closer and so on... CamelCase or snake_case? In Go you normally write CamelCase or how they call it MixedCaps and not snake_case like in Python for example.","title":"Architecture and Best Practices in Go"},{"location":"golang/architecture/#architecture-and-best-practices-in-go","text":"For best practices written by the Go team check out Effective Go Currently the best architecture for Go applications, in my opinion, is the domain driven hexagonal architecture: Link . It's so suitable because Go provides loosely coupled interface implementation to use dependency injection and packaging makes it clear, which struct belongs to which \"layer\".","title":"Architecture and Best Practices in Go"},{"location":"golang/architecture/#two-known-architecture-principles","text":"There are two known architecture principles in Go. The \"flat\" architecture and the \"domain driven\" architecture. Let's take a look at two examples: Cobra Go Cache Cobra uses the flat architecture. Go Cache uses the domain driven approach, at least it utilizes packages. Mostly the flat architecture is used, when the Go programm is small and does just one thing. If the Go program becomes more complicated and does several things, I would suggest to use the domain driven hexagonal approach.","title":"Two Known Architecture Principles"},{"location":"golang/architecture/#getter","text":"In Go it's unusual to use Get before a getter. You often just remove the Get in a getter method so that you access it with .Thing() . 1 2 3 4 owner := obj . Owner () if owner != user { obj . SetOwner ( user ) }","title":"Getter"},{"location":"golang/architecture/#interface-names","text":"Interface names are often defined with er as suffix. Like Reader , Writer , Closer and so on...","title":"Interface Names"},{"location":"golang/architecture/#camelcase-or-snake_case","text":"In Go you normally write CamelCase or how they call it MixedCaps and not snake_case like in Python for example.","title":"CamelCase or snake_case?"},{"location":"golang/dependency_injection/","text":"Dependency Injection in Go Dependency Injection in Go is a really important topic, because the programming language has a perfect basis to do dependency injection. Interfaces and Structs can decouple your application perfectly. Let's say we have a service which just redirects a call from a client to another service. First we define our core logic and values: core/value_objects/ttl_say_body.go 1 2 3 4 5 6 7 8 9 10 11 12 13 package valueobjects type TTSVoiceType string const ( TTSMaleVoice TTSVoiceType = \"male\" TTSFemaleVoid TTSVoiceType = \"female\" ) type TTSSayBody struct { Message string `json:\"message\"` TTSVoiceType TTSVoiceType `json:\"ttsVoiceType\"` } core/value_objects/ttl_say_response.go 1 2 3 4 5 6 package valueobjects type TTSSayResponse struct { Message string Status int } core/ports/ttl_service_port.go 1 2 3 4 5 6 7 package ports import valueobjects \"dependency_injection/core/value_objects\" type TTSServicePort interface { Say ( ttsRequestBody valueobjects . TTSSayBody ) ( valueobjects . TTSSayResponse , error ) } Then we implement the ports: infrastructure/services/real_ttl_service.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package services import ( \"bytes\" \"dependency_injection/core/ports\" valueobjects \"dependency_injection/core/value_objects\" \"encoding/json\" \"fmt\" \"io/ioutil\" \"net/http\" ) type RealTTSService struct { url string } var _ ports . TTSServicePort = RealTTSService {} func ( r RealTTSService ) formatEndpoint ( endpoint string ) string { return fmt . Sprintf ( \"%s/%s\" , r . url , endpoint ) } func ( r RealTTSService ) Say ( ttsRequestBody valueobjects . TTSSayBody ) ( valueobjects . TTSSayResponse , error ) { var ttsSayResponse valueobjects . TTSSayResponse postBody , _ := json . Marshal ( ttsRequestBody ) resp , err := http . Post ( r . formatEndpoint ( \"say\" ), \"application/json\" , bytes . NewBuffer ( postBody )) defer resp . Body . Close () if err != nil { return valueobjects . TTSSayResponse {}, err } responseBody , err := ioutil . ReadAll ( resp . Body ) if err != nil { return valueobjects . TTSSayResponse {}, err } err = json . Unmarshal ( responseBody , & ttsSayResponse ) if err != nil { return valueobjects . TTSSayResponse {}, err } return ttsSayResponse , nil } func NewRealTTSService () * RealTTSService { fmt . Println ( \"Init RealTTSService\" ) return & RealTTSService {} } infrastructure/services/fake_ttl_service.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package services import ( \"dependency_injection/core/ports\" valueobjects \"dependency_injection/core/value_objects\" \"errors\" \"fmt\" ) type FakeTTSService struct { } var _ ports . TTSServicePort = RealTTSService {} func ( f FakeTTSService ) Say ( ttsRequestBody valueobjects . TTSSayBody ) ( valueobjects . TTSSayResponse , error ) { if ttsRequestBody . Message == \"_Error!\" { return valueobjects . TTSSayResponse {}, errors . New ( \"custom error\" ) } return valueobjects . TTSSayResponse { Message : fmt . Sprintf ( \"Said: \\\"%s\\\" with voice %s\" , ttsRequestBody . Message , ttsRequestBody . TTSVoiceType ), Status : 200 , }, nil } func NewFakeTTSService () * FakeTTSService { fmt . Println ( \"Init FakeTTSService\" ) return & FakeTTSService {} } Now we can implement the interfaces for the application. Here we inject the TTSServicePort into the MainController. We execute a specific application functionality and receive a defined struct TTSSayResponse interface/controllers/main_controller.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package controllers import ( \"dependency_injection/core/ports\" valueobjects \"dependency_injection/core/value_objects\" \"encoding/json\" \"io/ioutil\" \"net/http\" ) type MainController struct { ttsService ports . TTSServicePort } func NewMainController ( ttsService ports . TTSServicePort ) * MainController { return & MainController { ttsService : ttsService , } } func ( mc * MainController ) Say ( w http . ResponseWriter , r * http . Request ) { var ttsSayBody valueobjects . TTSSayBody body , err := ioutil . ReadAll ( r . Body ) defer r . Body . Close () if err != nil { _ , _ = w . Write ([] byte ( err . Error ())) return } err = json . Unmarshal ( body , & ttsSayBody ) if err != nil { _ , _ = w . Write ([] byte ( err . Error ())) return } ttsSayResponse , err := mc . ttsService . Say ( ttsSayBody ) if err != nil { _ , _ = w . Write ([] byte ( err . Error ())) return } jsonResponse , err := json . Marshal ( ttsSayResponse ) if err != nil { _ , _ = w . Write ([] byte ( err . Error ())) return } _ , _ = w . Write ( jsonResponse ) return } Now we wrap everything up in our main.go file and inject the dependencies now. Here we inject a specific TTSServicePort depending on the environment variable: main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \"dependency_injection/core/ports\" \"dependency_injection/infrastructure/services\" \"dependency_injection/interface/controllers\" \"log\" \"net/http\" \"os\" ) func main () { var ttsService ports . TTSServicePort if os . Getenv ( \"ENV\" ) == \"prod\" { ttsService = services . NewRealTTSService () } else { ttsService = services . NewFakeTTSService () } mainController := controllers . NewMainController ( ttsService ) http . HandleFunc ( \"/say\" , mainController . Say ) log . Println ( \"Running server on http://localhost:8081\" ) log . Fatal ( http . ListenAndServe ( \":8081\" , nil )) } We have the following structure now: |-- core | |-- ports | | `-- ttl_service_port.go | `-- value_objects | |-- tts_say_body.go | `-- tts_say_response.go |-- go.mod |-- infrastructure | `-- services | |-- fake_tts_service.go | `-- real_tts_service.go |-- interface | `-- controllers | `-- main_controller.go `-- main.go There are teams who use this kind of dependency injection. But if it becomes more complex, its easier to use a tooling like wire. Let's check in the next chapter, how to do this.","title":"Dependency Injection in Go"},{"location":"golang/dependency_injection/#dependency-injection-in-go","text":"Dependency Injection in Go is a really important topic, because the programming language has a perfect basis to do dependency injection. Interfaces and Structs can decouple your application perfectly. Let's say we have a service which just redirects a call from a client to another service. First we define our core logic and values: core/value_objects/ttl_say_body.go 1 2 3 4 5 6 7 8 9 10 11 12 13 package valueobjects type TTSVoiceType string const ( TTSMaleVoice TTSVoiceType = \"male\" TTSFemaleVoid TTSVoiceType = \"female\" ) type TTSSayBody struct { Message string `json:\"message\"` TTSVoiceType TTSVoiceType `json:\"ttsVoiceType\"` } core/value_objects/ttl_say_response.go 1 2 3 4 5 6 package valueobjects type TTSSayResponse struct { Message string Status int } core/ports/ttl_service_port.go 1 2 3 4 5 6 7 package ports import valueobjects \"dependency_injection/core/value_objects\" type TTSServicePort interface { Say ( ttsRequestBody valueobjects . TTSSayBody ) ( valueobjects . TTSSayResponse , error ) } Then we implement the ports: infrastructure/services/real_ttl_service.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package services import ( \"bytes\" \"dependency_injection/core/ports\" valueobjects \"dependency_injection/core/value_objects\" \"encoding/json\" \"fmt\" \"io/ioutil\" \"net/http\" ) type RealTTSService struct { url string } var _ ports . TTSServicePort = RealTTSService {} func ( r RealTTSService ) formatEndpoint ( endpoint string ) string { return fmt . Sprintf ( \"%s/%s\" , r . url , endpoint ) } func ( r RealTTSService ) Say ( ttsRequestBody valueobjects . TTSSayBody ) ( valueobjects . TTSSayResponse , error ) { var ttsSayResponse valueobjects . TTSSayResponse postBody , _ := json . Marshal ( ttsRequestBody ) resp , err := http . Post ( r . formatEndpoint ( \"say\" ), \"application/json\" , bytes . NewBuffer ( postBody )) defer resp . Body . Close () if err != nil { return valueobjects . TTSSayResponse {}, err } responseBody , err := ioutil . ReadAll ( resp . Body ) if err != nil { return valueobjects . TTSSayResponse {}, err } err = json . Unmarshal ( responseBody , & ttsSayResponse ) if err != nil { return valueobjects . TTSSayResponse {}, err } return ttsSayResponse , nil } func NewRealTTSService () * RealTTSService { fmt . Println ( \"Init RealTTSService\" ) return & RealTTSService {} } infrastructure/services/fake_ttl_service.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package services import ( \"dependency_injection/core/ports\" valueobjects \"dependency_injection/core/value_objects\" \"errors\" \"fmt\" ) type FakeTTSService struct { } var _ ports . TTSServicePort = RealTTSService {} func ( f FakeTTSService ) Say ( ttsRequestBody valueobjects . TTSSayBody ) ( valueobjects . TTSSayResponse , error ) { if ttsRequestBody . Message == \"_Error!\" { return valueobjects . TTSSayResponse {}, errors . New ( \"custom error\" ) } return valueobjects . TTSSayResponse { Message : fmt . Sprintf ( \"Said: \\\"%s\\\" with voice %s\" , ttsRequestBody . Message , ttsRequestBody . TTSVoiceType ), Status : 200 , }, nil } func NewFakeTTSService () * FakeTTSService { fmt . Println ( \"Init FakeTTSService\" ) return & FakeTTSService {} } Now we can implement the interfaces for the application. Here we inject the TTSServicePort into the MainController. We execute a specific application functionality and receive a defined struct TTSSayResponse interface/controllers/main_controller.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package controllers import ( \"dependency_injection/core/ports\" valueobjects \"dependency_injection/core/value_objects\" \"encoding/json\" \"io/ioutil\" \"net/http\" ) type MainController struct { ttsService ports . TTSServicePort } func NewMainController ( ttsService ports . TTSServicePort ) * MainController { return & MainController { ttsService : ttsService , } } func ( mc * MainController ) Say ( w http . ResponseWriter , r * http . Request ) { var ttsSayBody valueobjects . TTSSayBody body , err := ioutil . ReadAll ( r . Body ) defer r . Body . Close () if err != nil { _ , _ = w . Write ([] byte ( err . Error ())) return } err = json . Unmarshal ( body , & ttsSayBody ) if err != nil { _ , _ = w . Write ([] byte ( err . Error ())) return } ttsSayResponse , err := mc . ttsService . Say ( ttsSayBody ) if err != nil { _ , _ = w . Write ([] byte ( err . Error ())) return } jsonResponse , err := json . Marshal ( ttsSayResponse ) if err != nil { _ , _ = w . Write ([] byte ( err . Error ())) return } _ , _ = w . Write ( jsonResponse ) return } Now we wrap everything up in our main.go file and inject the dependencies now. Here we inject a specific TTSServicePort depending on the environment variable: main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \"dependency_injection/core/ports\" \"dependency_injection/infrastructure/services\" \"dependency_injection/interface/controllers\" \"log\" \"net/http\" \"os\" ) func main () { var ttsService ports . TTSServicePort if os . Getenv ( \"ENV\" ) == \"prod\" { ttsService = services . NewRealTTSService () } else { ttsService = services . NewFakeTTSService () } mainController := controllers . NewMainController ( ttsService ) http . HandleFunc ( \"/say\" , mainController . Say ) log . Println ( \"Running server on http://localhost:8081\" ) log . Fatal ( http . ListenAndServe ( \":8081\" , nil )) } We have the following structure now: |-- core | |-- ports | | `-- ttl_service_port.go | `-- value_objects | |-- tts_say_body.go | `-- tts_say_response.go |-- go.mod |-- infrastructure | `-- services | |-- fake_tts_service.go | `-- real_tts_service.go |-- interface | `-- controllers | `-- main_controller.go `-- main.go There are teams who use this kind of dependency injection. But if it becomes more complex, its easier to use a tooling like wire. Let's check in the next chapter, how to do this.","title":"Dependency Injection in Go"},{"location":"golang/dependency_injection/wire/","text":"Wire Google's own compile time dependency injection framework is called: Wire . Wire works a little bit different from guice for example. Wire generates code from a file called wire.go to a file called wire_gen.go , which can be used in the main.go file to initialize and start the application. Install wire first: go install github.com/google/wire/cmd/wire@latest Let's take our example from the chapter before. We first just create a file called wire.go : wire.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //go:build wireinject // +build wireinject package main import ( \"dependency_injection/core/ports\" \"dependency_injection/infrastructure/services\" \"dependency_injection/interface/controllers\" \"github.com/google/wire\" \"os\" ) func NewTTSService () ports . TTSServicePort { if os . Getenv ( \"ENV\" ) == \"prod\" { return services . NewRealTTSService () } else { return services . NewFakeTTSService () } } func InitializeMainController () * controllers . MainController { wire . Build ( NewTTSService , controllers . NewMainController ) return & controllers . MainController {} } After that we can run wire to generate a wire_gen.go file: Run in project root wire wire_gen.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // Code generated by Wire. DO NOT EDIT. //go:generate go run github.com/google/wire/cmd/wire //go:build !wireinject // +build !wireinject package main import ( \"dependency_injection/core/ports\" \"dependency_injection/infrastructure/services\" \"dependency_injection/interface/controllers\" \"os\" ) // Injectors from wire.go: func InitializeMainController () * controllers . MainController { ttsServicePort := NewTTSService () mainController := controllers . NewMainController ( ttsServicePort ) return mainController } // wire.go: func NewTTSService () ports . TTSServicePort { if os . Getenv ( \"ENV\" ) == \"prod\" { return services . NewRealTTSService () } else { return services . NewFakeTTSService () } } And now we can adapt the main.go file: main.go 1 2 3 4 5 6 func main () { mainController := InitializeMainController () http . HandleFunc ( \"/say\" , mainController . Say ) log . Println ( \"Running server on http://localhost:8081\" ) log . Fatal ( http . ListenAndServe ( \":8081\" , nil )) } Since we have now two files for the main package, we need to adapt our start line. This is important because otherwise it won't compile properly: go run main.go wire_gen.go","title":"Wire"},{"location":"golang/dependency_injection/wire/#wire","text":"Google's own compile time dependency injection framework is called: Wire . Wire works a little bit different from guice for example. Wire generates code from a file called wire.go to a file called wire_gen.go , which can be used in the main.go file to initialize and start the application. Install wire first: go install github.com/google/wire/cmd/wire@latest Let's take our example from the chapter before. We first just create a file called wire.go : wire.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //go:build wireinject // +build wireinject package main import ( \"dependency_injection/core/ports\" \"dependency_injection/infrastructure/services\" \"dependency_injection/interface/controllers\" \"github.com/google/wire\" \"os\" ) func NewTTSService () ports . TTSServicePort { if os . Getenv ( \"ENV\" ) == \"prod\" { return services . NewRealTTSService () } else { return services . NewFakeTTSService () } } func InitializeMainController () * controllers . MainController { wire . Build ( NewTTSService , controllers . NewMainController ) return & controllers . MainController {} } After that we can run wire to generate a wire_gen.go file: Run in project root wire wire_gen.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // Code generated by Wire. DO NOT EDIT. //go:generate go run github.com/google/wire/cmd/wire //go:build !wireinject // +build !wireinject package main import ( \"dependency_injection/core/ports\" \"dependency_injection/infrastructure/services\" \"dependency_injection/interface/controllers\" \"os\" ) // Injectors from wire.go: func InitializeMainController () * controllers . MainController { ttsServicePort := NewTTSService () mainController := controllers . NewMainController ( ttsServicePort ) return mainController } // wire.go: func NewTTSService () ports . TTSServicePort { if os . Getenv ( \"ENV\" ) == \"prod\" { return services . NewRealTTSService () } else { return services . NewFakeTTSService () } } And now we can adapt the main.go file: main.go 1 2 3 4 5 6 func main () { mainController := InitializeMainController () http . HandleFunc ( \"/say\" , mainController . Say ) log . Println ( \"Running server on http://localhost:8081\" ) log . Fatal ( http . ListenAndServe ( \":8081\" , nil )) } Since we have now two files for the main package, we need to adapt our start line. This is important because otherwise it won't compile properly: go run main.go wire_gen.go","title":"Wire"},{"location":"golang/design_patterns/","text":"Design Patterns in Go In this chapter we will look at some design patterns in Go. All code example are taken from here: https://refactoring.guru/design-patterns/go Singleton Just hold a package variable, which is a pointer to your preferred struct. Then expose a function SingleInstance to retrieve the singleton. Note to use sync.Mutex to lock the creation for the singleInstance, otherwise you could create multiple instances within several goroutines. single.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import ( \"fmt\" \"sync\" ) var lock = & sync . Mutex {} type single struct { } var singleInstance * single func SingleInstance () * single { if singleInstance == nil { lock . Lock () defer lock . Unlock () if singleInstance == nil { fmt . Println ( \"Creating single instance now.\" ) singleInstance = & single {} } else { fmt . Println ( \"Single instance already created.\" ) } } else { fmt . Println ( \"Single instance already created.\" ) } return singleInstance } Decorator The decorator pattern allows adding new behaviours to objects dynamically. Let's see how we can do that by creating a pizza decorator pattern: First we create the decorator functionality pizza.go 1 2 3 type Pricer interface { getPrice () int } then we create create a concrete component: 1 2 3 4 5 type Pizza struct {} func ( p Pizza ) getPrice () int { return 3 } now we create some decorators: toppings.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type Cheese struct { pricer Pricer } func ( c Cheese ) getPrice () int { return c . pricer . getPrice () + 2 } type Tomato struct { pricer Pricer } func ( t Tomato ) getPrice () int { return t . pricer . getPrice () + 1 } and now we stack the decorators: main.go 1 2 3 4 5 6 7 8 func main () { price := Cheese { pricer : Tomato { pricer : Pizza {}, }, }. getPrice () fmt . Println ( price ) }","title":"Design Patterns in Go"},{"location":"golang/design_patterns/#design-patterns-in-go","text":"In this chapter we will look at some design patterns in Go. All code example are taken from here: https://refactoring.guru/design-patterns/go","title":"Design Patterns in Go"},{"location":"golang/design_patterns/#singleton","text":"Just hold a package variable, which is a pointer to your preferred struct. Then expose a function SingleInstance to retrieve the singleton. Note to use sync.Mutex to lock the creation for the singleInstance, otherwise you could create multiple instances within several goroutines. single.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import ( \"fmt\" \"sync\" ) var lock = & sync . Mutex {} type single struct { } var singleInstance * single func SingleInstance () * single { if singleInstance == nil { lock . Lock () defer lock . Unlock () if singleInstance == nil { fmt . Println ( \"Creating single instance now.\" ) singleInstance = & single {} } else { fmt . Println ( \"Single instance already created.\" ) } } else { fmt . Println ( \"Single instance already created.\" ) } return singleInstance }","title":"Singleton"},{"location":"golang/design_patterns/#decorator","text":"The decorator pattern allows adding new behaviours to objects dynamically. Let's see how we can do that by creating a pizza decorator pattern: First we create the decorator functionality pizza.go 1 2 3 type Pricer interface { getPrice () int } then we create create a concrete component: 1 2 3 4 5 type Pizza struct {} func ( p Pizza ) getPrice () int { return 3 } now we create some decorators: toppings.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type Cheese struct { pricer Pricer } func ( c Cheese ) getPrice () int { return c . pricer . getPrice () + 2 } type Tomato struct { pricer Pricer } func ( t Tomato ) getPrice () int { return t . pricer . getPrice () + 1 } and now we stack the decorators: main.go 1 2 3 4 5 6 7 8 func main () { price := Cheese { pricer : Tomato { pricer : Pizza {}, }, }. getPrice () fmt . Println ( price ) }","title":"Decorator"},{"location":"golang/docker/","text":"Docker Images for Go Surprisingly Docker was built with the programming language Go. Go Application Let's start with a simple Go webserver and init a go application: go mod init go-webserver Now we write the main.go file. main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \"fmt\" \"html\" \"log\" \"net/http\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { fmt . Fprintf ( w , \"Hello, %q\" , html . EscapeString ( r . URL . Path )) }) http . HandleFunc ( \"/hi\" , func ( w http . ResponseWriter , r * http . Request ){ fmt . Fprintf ( w , \"Hi\" ) }) log . Fatal ( http . ListenAndServe ( \":8081\" , nil )) } If we run it with go run main.go and access the URL with http://localhost:8081/go we get Hello, \"/go\" as response. Writing the Dockerfile We have a working Go application, now let's start to build it as a Docker image. For that we need first a Dockerfile in the same location, where the main.go file is located. Let's create a Dockerfile for that to build images: Dockerfile FROM golang:1.18.1-alpine RUN mkdir /app WORKDIR /app COPY . . RUN go build -o main . CMD [ \"/app/main\" ] Build the image Now we have a Dockerfile and can build the image: docker build . -t go-webserver:latest Start or push the image From that point we can start the image or push it onto an image repository. Here is a demonstration, how to start the image: docker run --rm -it -p 8081 :8081 go-webserver Now we can access again the browser: http://localhost:8081/go and the response should be Hello, \"/go\" . Smaller images Since we compile the go application, we actually don't need the Go files anymore in the image. To save some space we can build the image in two stages (multistage). Here is an example to do that: Dockerfile FROM golang:1.18.1-alpine AS BUILDER WORKDIR /app COPY . . RUN go build -o app main.go FROM alpine:latest WORKDIR /app COPY --from = BUILDER /app ./ CMD [ \"./app\" ] Since we built the Go application on an alpine, we can use instead of golang:alpine just alpine , which is a smaller image.\\ We built and start the image: docker build . -t go-webserver-alpine docker run --rm -it -p 8081 :8081 go-webserver-alpine If we compare those two images, there is a significant difference: go-webserver-alpine latest 4fe92b6799b2 38 seconds ago 11.4MB go-webserver latest c67bfbfc1bba 7 minutes ago 332MB","title":"Docker Images for Go"},{"location":"golang/docker/#docker-images-for-go","text":"Surprisingly Docker was built with the programming language Go.","title":"Docker Images for Go"},{"location":"golang/docker/#go-application","text":"Let's start with a simple Go webserver and init a go application: go mod init go-webserver Now we write the main.go file. main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \"fmt\" \"html\" \"log\" \"net/http\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { fmt . Fprintf ( w , \"Hello, %q\" , html . EscapeString ( r . URL . Path )) }) http . HandleFunc ( \"/hi\" , func ( w http . ResponseWriter , r * http . Request ){ fmt . Fprintf ( w , \"Hi\" ) }) log . Fatal ( http . ListenAndServe ( \":8081\" , nil )) } If we run it with go run main.go and access the URL with http://localhost:8081/go we get Hello, \"/go\" as response.","title":"Go Application"},{"location":"golang/docker/#writing-the-dockerfile","text":"We have a working Go application, now let's start to build it as a Docker image. For that we need first a Dockerfile in the same location, where the main.go file is located. Let's create a Dockerfile for that to build images: Dockerfile FROM golang:1.18.1-alpine RUN mkdir /app WORKDIR /app COPY . . RUN go build -o main . CMD [ \"/app/main\" ]","title":"Writing the Dockerfile"},{"location":"golang/docker/#build-the-image","text":"Now we have a Dockerfile and can build the image: docker build . -t go-webserver:latest","title":"Build the image"},{"location":"golang/docker/#start-or-push-the-image","text":"From that point we can start the image or push it onto an image repository. Here is a demonstration, how to start the image: docker run --rm -it -p 8081 :8081 go-webserver Now we can access again the browser: http://localhost:8081/go and the response should be Hello, \"/go\" .","title":"Start or push the image"},{"location":"golang/docker/#smaller-images","text":"Since we compile the go application, we actually don't need the Go files anymore in the image. To save some space we can build the image in two stages (multistage). Here is an example to do that: Dockerfile FROM golang:1.18.1-alpine AS BUILDER WORKDIR /app COPY . . RUN go build -o app main.go FROM alpine:latest WORKDIR /app COPY --from = BUILDER /app ./ CMD [ \"./app\" ] Since we built the Go application on an alpine, we can use instead of golang:alpine just alpine , which is a smaller image.\\ We built and start the image: docker build . -t go-webserver-alpine docker run --rm -it -p 8081 :8081 go-webserver-alpine If we compare those two images, there is a significant difference: go-webserver-alpine latest 4fe92b6799b2 38 seconds ago 11.4MB go-webserver latest c67bfbfc1bba 7 minutes ago 332MB","title":"Smaller images"},{"location":"golang/golang-fundamentals/composite_types/","text":"Composite Types Composite types in Go contain more functionality than the primitive types. There are builtin functions in Go to support composite types. Let's see how to use them and what are the best practices. Comparable Types This types are comparable: Boolean Numeric String, Pointer Channel Interface types Structs \u2013 if all it\u2019s field type is comparable Array \u2013 if the type of value of array element is comparable This are not comparable types: Slice Map Function Arrays Arrays aren't used directly. Normally Go developers use Slices, we will see why in the next chapter, but let's first check what Arrays are and how to use them. First we look at the declaration of an array: 1 var x [ 3 ] int This creates an array of three ints ( x[0] , x[1] , x[2] ), each initialized to a zero value ( 0 ). If you want to define the values for all array elements use the array literal: 1 var x = [ 3 ] int { 1 , 2 , 3 } If can specify the indices of a new array: 1 2 3 4 5 var x = [ 10 ] int { 1 : 1 , 3 : 2 , 5 : 3 , } This will create the following array: [0 1 0 2 0 3 0 0 0 0] If you want to initialize an array with a dynamic number of values use the variadic keyword ... . 1 2 3 4 5 6 var x = [ ... ] int { 1 : 1 , 3 : 2 , 5 : 3 , } fmt . Println ( x ) This will create the following array: [0 1 0 2 0 3] You can also define multi-dimensional arrays: 1 var x [ 2 ][ 3 ] int An array can be compared to other arrays with the same type: 1 2 3 var x = [ 3 ] int { 1 , 2 , 3 } var y = [ ... ] int { 1 , 2 , 3 } fmt . Println ( x == y ) // true Use the known bracket syntax to access array indices: 1 2 3 var x = [ 3 ] int { 1 , 2 , 3 } x [ 0 ] = 5 fmt . Println ( x [ 2 ]) Note You cannot read or write past an array or use negative indices. If you do it, this will result in a compile time error. An out-of-bound read or write during the execution time will result in a panic . We will talk about that later. The builtin function len gives us the length of an array: 1 2 var x = [ 3 ] int { 1 , 2 , 3 } fmt . Println ( len ( x )) will output: 3 Array are used rarely and explcitly. If you define an array with the size [3]int another array with the size [4]int is a different type. This means you cannot use a variable to specify the size, because Go resolves the size at compile time. You cannot use type conversion to convert arrays. For example this won't work: Failure 1 2 3 4 5 6 7 8 9 10 package main import \"fmt\" func main () { var x [ 3 ] int var y = [ 4 ] int ( x ) fmt . Println ( x ) fmt . Println ( y ) } will result in: ./prog.go:7:16: cannot convert x (variable of type [3]int) to type [4]int Therefore you should use arrays only, if you really know the exact length of your array. Slices If you want to use arrays and you do not have a fixed size of elements, use slices. The length is not part of a slice. 1 var x = [] int { 1 , 2 , 3 } Note Using [...] makes arrays, using [] makes slices. Also use the same syntax for slices as for arrays just without the size specifier: 1 2 var x = [] int { 1 : 1 , 3 : 2 , 5 : 3 } var y [][] int You can read and write slices with the bracket syntax. Read or write past a slice or using negative syntax is not allowed: 1 2 x [ 0 ] = 20 fmt . Println ( x [ 1 ]) If you declare a slice without initializing it the zero value for a slice is nil . So if you want to check if a slice has been initialized use: 1 2 var x [] int fmt . Println ( x != nil ) // -> false A slice is not a comparable. You can use following built-in functions for slices: len append cap make As for arrays you can use len to get the length of a slice: 1 2 var x [] int fmt . Println ( len ( x )) // 0 The built-in append function can add elements to slices: 1 2 var x [] int x = append ( x , 1 ) The append function takes at least two parameters, a slice of any type and a value of that type. It returns a new slice of the same type and the appended element at the end. You can append more than one value: 1 2 var x = [] int { 0 } x = append ( x , 1 , 2 , 3 ) You can also append one slice to another by using variadic symbol: 1 2 3 4 var x = [] int { 1 , 2 , 3 } var y = [] int { 4 , 5 , 6 } x = append ( x , y ... ) fmt . Println ( x ) output: [1 2 3 4 5 6] If you do not assign the return value of an append call, it will result in a compile time error: Failure 1 2 3 4 var x = [] int { 1 , 2 , 3 } var y = [] int { 4 , 5 , 6 } append ( x , y ... ) fmt . Println ( x ) will result in: append(x, y...) (value of type []int) is not used Go is a call by value language, therefore Go makes a copy of the slice that you pass in, adds an element and return the new copy. Capacity With capacity you retrieve the reserved consecutive memory locations. This can be larger than the length of a slice. Each time you append to a slice Go checks if the capacity is reached and allocates more memory for your slice. It takes some time, if you append to a slice which has reached it's capacity and Go allocates a new bigger slice, copies the values to the new slice and garbage collects the old slice. Therefore has following rule for handling with capacities: from 0 to 1024 Go doubles the sizes of the current capacity from 1024 to maximum default integer of the target built (32bit or 64bit) increase by 25% cap returns the current capacity of a slice. Let's see how append and cap changes: 1 2 3 4 5 6 7 8 9 10 11 12 var x [] int fmt . Println ( x , len ( x ), cap ( x )) x = append ( x , 1 ) fmt . Println ( x , len ( x ), cap ( x )) x = append ( x , 2 ) fmt . Println ( x , len ( x ), cap ( x )) x = append ( x , 3 ) fmt . Println ( x , len ( x ), cap ( x )) x = append ( x , 4 ) fmt . Println ( x , len ( x ), cap ( x )) x = append ( x , 5 ) fmt . Println ( x , len ( x ), cap ( x )) output: [] 0 0 [1] 1 1 [1 2] 2 2 [1 2 3] 3 4 [1 2 3 4] 4 4 [1 2 3 4 5] 5 8 This is just a syntactic sugar, to not care about sizes. But if you need to make the code more efficient and especially work with big data inside your slices use make . With make you create a slice with a defined length : x := make([]int, 5) This creates a slice with an initial length of 5. x is not nil and is already initialized with zero values from index 0 to 4. If you try to use append , because you want to start to fill the slice, it can be a mistake: 1 2 x := make ([] int , 5 ) x = append ( x , 1 ) would append to an initialized slice, which would have 5 int zero values and an appended element: [0, 0, 0, 0, 0, 1] With the cap function you can also optionally specify the capacity of a slice. 1 x := make ([] int , 5 , 10 ) This would create a slice of length 5 and a capacity of 10. If you want to initial the slice with append just make a slice if the initial length of 0 and a preferred capacity: 1 2 3 4 5 x := make ([] int , 0 , 4 ) x = append ( x , 1 ) x = append ( x , 2 ) x = append ( x , 3 , 4 ) fmt . Println ( x ) output: [1 2 3 4] Slicing You can use slicing with slices to define a \"from\" \"to\" (excluded) range. If you do not the \"from\" range 0 will be assumed, as for \"to\". 1 2 3 4 5 x := [] int { 1 , 2 , 3 , 4 } fmt . Println ( x [: 2 ]) fmt . Println ( x [ 1 :]) fmt . Println ( x [ 1 : 2 ]) fmt . Println ( x [:]) output: [1 2] [2 3 4] [2] [1 2 3 4] Note You will not make a copy of a slice, if you use slicing. Slicings of a slice share the same memory and can be modified. Let's see how we modify the sliced slice to the original slice: 1 2 3 4 x := [] int { 1 , 2 , 3 , 4 } y := x [: 1 ] y [ 0 ] = 9 fmt . Println ( x ) output: [9 2 3 4] If you have arrays, you can convert them to a slice by using slicing. 1 2 3 4 5 x := [ 4 ] int { 1 , 2 , 3 , 4 } y := x [:] y = append ( y , 1 ) fmt . Println ( x ) fmt . Println ( y ) Output: [1 2 3 4] [1 2 3 4 1] If you want to copy a slice you can use the built-in function. It copies all values from a source slice into a destination slice, but consider that the parameters are swapped: copy(destination, source) . copy is limited to the length of the smaller slice (the capacity doesn't matter). So for example: 1 2 3 4 x := [] int { 1 , 2 , 3 , 4 } y := make ([] int , 2 ) num := copy ( x , y ) fmt . Println ( num , y ) output: 2 [1 2] Maps Maps are key-value variables. Maps are not comparable. Let's see how to declare one: 1 2 3 var myMap map [ string ] int fmt . Println ( myMap == nil ) // -> true If you want to create a map you have several options: 1 2 3 4 5 6 7 8 classes := map [ string ][] string { \"Class 1\" : [] string { \"Sarah\" , \"Peter\" , \"Justin\" , }, \"Class 2\" : [] string { \"Fred\" , \"Ralph\" , \"Lea\" , }, } or use the built-int make function. This will create a 10 length key-value pair map. But, other than slices, it will have a length of 0. 1 classes := make ( map [ string ] int , 10 ) The key of a slice can be a comparable type . Reading and writing to a map is similar to reading and writing to slices: 1 2 3 4 5 6 7 8 9 10 11 12 13 class1 := \"Class 1\" class2 := \"Class 2\" classes := map [ string ][] string { class1 : [] string { \"Sarah\" , \"Peter\" , \"Justin\" , }, class2 : [] string { \"Fred\" , \"Ralph\" , \"Lea\" , }, } fmt . Println ( classes ) classes [ class1 ] = append ( classes [ class1 ], \"Christian\" ) fmt . Println ( classes [ class1 ]) output: map[Class 1:[Sarah Peter Justin] Class 2:[Fred Ralph Lea]] [Sarah Peter Justin Christian] If you access a key which is not assigned to the map, it will return the zero value to that type: 1 2 3 4 5 6 7 8 9 10 11 classes := map [ string ][] string { \"Class 1\" : [] string { \"Sarah\" , \"Peter\" , \"Justin\" }, } fmt . Println ( classes [ \"Not exist\" ]) fmt . Println ( classes [ \"Not exist\" ] == nil ) ages := map [ string ] int { \"Tester\" : 31 , } fmt . Println ( ages [ \"Not exist\" ]) fmt . Println ( ages [ \"Not exist\" ] == 0 ) output: [] true 0 true variable, ok := idiom Sometimes you don't want to explicitly check for the zero value like \"\" for strings or 0 for numeric values. There is a syntactic sugar, which helps to do that properly: 1 2 3 4 5 6 7 8 9 10 example := map [ string ] int { \"Hello\" : 119 , \"World\" : 312 , } value , ok := example [ \"Hello\" ] fmt . Println ( value , ok ) value , ok = example [ \"NotExist\" ] fmt . Println ( value , ok ) output: 119 true 0 false If the key is present it will return the value as first return value and a boolean true in the second return value. If the key is not preset it will return the zero value as first return value and a boolean false in the second return value. If you need to delete from maps you can use the built-in delete function. The delete function takes a map and the key. If the key is not present or the map is nil nothing happens. The delete function does not return any value. 1 2 3 4 5 6 example := map [ string ] int { \"Hello\" : 119 , \"World\" : 312 , } delete ( example , \"Hello\" ) delete ( example , \"Test\" ) Structs With maps you can define dynamic data, but they have limitations. All values have to have the same type and you cannot define which keys are public or private. If you know already what classes are, this is probably what you are searching for: a struct Here is a struct: 1 2 3 4 5 type person struct { firstName string lastName string age int } You can define structs inside or outside functions (respecting the scopes). If you declared a struct type, you can use it: 1 var michael person The variable gets the zero value of a struct which the nil value. If you want to initialize a struct use {} , this will initialize the struct with zero values for all fields. 1 2 3 4 5 var michael = person { \"Michael\" , \"Bykovski\" , 28 , } alternatively you can use the field names to make it explicit: 1 2 3 4 5 var michael = person { firstName : \"Michael\" , lastName : \"Bykovski\" , age : 28 , } Access a struct field by punctuation: 1 2 3 4 5 6 7 var michael = person { firstName : \"Michael\" , lastName : \"Bykovski\" , age : 28 , } michael . age ++ fmt . Println ( michael ) output: {Michael Bykovski 29} Anonymous structs An anonymous struct is a struct without a name. Let's look at an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 var person struct { firstName string lastName string age int } pet := struct { name string kind string } { name : \"Jukes\" , kind : \"cat\" , } Anonymous structs are useful if you want to serialize and deserialize data, which is called \"marshal\" and \"unmarshal\" in Go. Comparing and Converting Structs If you want to compare structs, Go only compares structs if the fields of a given struct are all comparable . So if you have a list or a map in a struct, it becomes not comparable. If you want to have a custom compare function, you can write your own method. If you compare two different type structs Go will falsify it. But you can do a type conversion between two type structs if they have the same field signatures . Let's first look at a successful type conversion but failed comparison. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 type firstPet struct { name string kind string } type secondPet struct { name string kind string } pet := firstPet { name : \"Jukes\" , kind : \"cat\" , } var pet2 secondPet pet2 = secondPet ( pet ) fmt . Println ( pet2 ) //fmt.Println(pet2 == pet) Type conversion on line 16 would work. But it would fail on line 18 because invalid operation: pet2 == pet (mismatched types secondPet and firstPet) Now let's look at failed type conversions and therefore failed comparisons. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 type firstPet struct { name string kind string } // wrong order type thirdPet struct { kind string name string } // wrong name type fourthPet struct { name string race string } // wrong signatures type fifthPet struct { name string kind string age int } pet := firstPet { name : \"Jukes\" , kind : \"cat\" , } var pet3 thirdPet var pet4 fourthPet var pet5 fifthPet pet3 = thirdPet ( pet ) pet4 = fourthPet ( pet ) pet5 = fifthPet ( pet ) Cannot type convert to any type, because all field signatures are wrong: ./prog.go:41:17: cannot convert pet (variable of type firstPet) to type thirdPet ./prog.go:42:18: cannot convert pet (variable of type firstPet) to type fourthPet ./prog.go:43:17: cannot convert pet (variable of type firstPet) to type fifthPet Now we look at a successfull type conversion and comparison: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type firstPet struct { name string kind string } var anonymousPet struct { name string kind string } pet := firstPet { name : \"Jukes\" , kind : \"cat\" , } anonymousPet = pet fmt . Println ( pet , anonymousPet , anonymousPet == pet ) output: {Jukes cat} {Jukes cat} true","title":"Composite Types"},{"location":"golang/golang-fundamentals/composite_types/#composite-types","text":"Composite types in Go contain more functionality than the primitive types. There are builtin functions in Go to support composite types. Let's see how to use them and what are the best practices.","title":"Composite Types"},{"location":"golang/golang-fundamentals/composite_types/#comparable-types","text":"This types are comparable: Boolean Numeric String, Pointer Channel Interface types Structs \u2013 if all it\u2019s field type is comparable Array \u2013 if the type of value of array element is comparable This are not comparable types: Slice Map Function","title":"Comparable Types"},{"location":"golang/golang-fundamentals/composite_types/#arrays","text":"Arrays aren't used directly. Normally Go developers use Slices, we will see why in the next chapter, but let's first check what Arrays are and how to use them. First we look at the declaration of an array: 1 var x [ 3 ] int This creates an array of three ints ( x[0] , x[1] , x[2] ), each initialized to a zero value ( 0 ). If you want to define the values for all array elements use the array literal: 1 var x = [ 3 ] int { 1 , 2 , 3 } If can specify the indices of a new array: 1 2 3 4 5 var x = [ 10 ] int { 1 : 1 , 3 : 2 , 5 : 3 , } This will create the following array: [0 1 0 2 0 3 0 0 0 0] If you want to initialize an array with a dynamic number of values use the variadic keyword ... . 1 2 3 4 5 6 var x = [ ... ] int { 1 : 1 , 3 : 2 , 5 : 3 , } fmt . Println ( x ) This will create the following array: [0 1 0 2 0 3] You can also define multi-dimensional arrays: 1 var x [ 2 ][ 3 ] int An array can be compared to other arrays with the same type: 1 2 3 var x = [ 3 ] int { 1 , 2 , 3 } var y = [ ... ] int { 1 , 2 , 3 } fmt . Println ( x == y ) // true Use the known bracket syntax to access array indices: 1 2 3 var x = [ 3 ] int { 1 , 2 , 3 } x [ 0 ] = 5 fmt . Println ( x [ 2 ]) Note You cannot read or write past an array or use negative indices. If you do it, this will result in a compile time error. An out-of-bound read or write during the execution time will result in a panic . We will talk about that later. The builtin function len gives us the length of an array: 1 2 var x = [ 3 ] int { 1 , 2 , 3 } fmt . Println ( len ( x )) will output: 3 Array are used rarely and explcitly. If you define an array with the size [3]int another array with the size [4]int is a different type. This means you cannot use a variable to specify the size, because Go resolves the size at compile time. You cannot use type conversion to convert arrays. For example this won't work: Failure 1 2 3 4 5 6 7 8 9 10 package main import \"fmt\" func main () { var x [ 3 ] int var y = [ 4 ] int ( x ) fmt . Println ( x ) fmt . Println ( y ) } will result in: ./prog.go:7:16: cannot convert x (variable of type [3]int) to type [4]int Therefore you should use arrays only, if you really know the exact length of your array.","title":"Arrays"},{"location":"golang/golang-fundamentals/composite_types/#slices","text":"If you want to use arrays and you do not have a fixed size of elements, use slices. The length is not part of a slice. 1 var x = [] int { 1 , 2 , 3 } Note Using [...] makes arrays, using [] makes slices. Also use the same syntax for slices as for arrays just without the size specifier: 1 2 var x = [] int { 1 : 1 , 3 : 2 , 5 : 3 } var y [][] int You can read and write slices with the bracket syntax. Read or write past a slice or using negative syntax is not allowed: 1 2 x [ 0 ] = 20 fmt . Println ( x [ 1 ]) If you declare a slice without initializing it the zero value for a slice is nil . So if you want to check if a slice has been initialized use: 1 2 var x [] int fmt . Println ( x != nil ) // -> false A slice is not a comparable. You can use following built-in functions for slices: len append cap make As for arrays you can use len to get the length of a slice: 1 2 var x [] int fmt . Println ( len ( x )) // 0 The built-in append function can add elements to slices: 1 2 var x [] int x = append ( x , 1 ) The append function takes at least two parameters, a slice of any type and a value of that type. It returns a new slice of the same type and the appended element at the end. You can append more than one value: 1 2 var x = [] int { 0 } x = append ( x , 1 , 2 , 3 ) You can also append one slice to another by using variadic symbol: 1 2 3 4 var x = [] int { 1 , 2 , 3 } var y = [] int { 4 , 5 , 6 } x = append ( x , y ... ) fmt . Println ( x ) output: [1 2 3 4 5 6] If you do not assign the return value of an append call, it will result in a compile time error: Failure 1 2 3 4 var x = [] int { 1 , 2 , 3 } var y = [] int { 4 , 5 , 6 } append ( x , y ... ) fmt . Println ( x ) will result in: append(x, y...) (value of type []int) is not used Go is a call by value language, therefore Go makes a copy of the slice that you pass in, adds an element and return the new copy.","title":"Slices"},{"location":"golang/golang-fundamentals/composite_types/#capacity","text":"With capacity you retrieve the reserved consecutive memory locations. This can be larger than the length of a slice. Each time you append to a slice Go checks if the capacity is reached and allocates more memory for your slice. It takes some time, if you append to a slice which has reached it's capacity and Go allocates a new bigger slice, copies the values to the new slice and garbage collects the old slice. Therefore has following rule for handling with capacities: from 0 to 1024 Go doubles the sizes of the current capacity from 1024 to maximum default integer of the target built (32bit or 64bit) increase by 25% cap returns the current capacity of a slice. Let's see how append and cap changes: 1 2 3 4 5 6 7 8 9 10 11 12 var x [] int fmt . Println ( x , len ( x ), cap ( x )) x = append ( x , 1 ) fmt . Println ( x , len ( x ), cap ( x )) x = append ( x , 2 ) fmt . Println ( x , len ( x ), cap ( x )) x = append ( x , 3 ) fmt . Println ( x , len ( x ), cap ( x )) x = append ( x , 4 ) fmt . Println ( x , len ( x ), cap ( x )) x = append ( x , 5 ) fmt . Println ( x , len ( x ), cap ( x )) output: [] 0 0 [1] 1 1 [1 2] 2 2 [1 2 3] 3 4 [1 2 3 4] 4 4 [1 2 3 4 5] 5 8 This is just a syntactic sugar, to not care about sizes. But if you need to make the code more efficient and especially work with big data inside your slices use make . With make you create a slice with a defined length : x := make([]int, 5) This creates a slice with an initial length of 5. x is not nil and is already initialized with zero values from index 0 to 4. If you try to use append , because you want to start to fill the slice, it can be a mistake: 1 2 x := make ([] int , 5 ) x = append ( x , 1 ) would append to an initialized slice, which would have 5 int zero values and an appended element: [0, 0, 0, 0, 0, 1] With the cap function you can also optionally specify the capacity of a slice. 1 x := make ([] int , 5 , 10 ) This would create a slice of length 5 and a capacity of 10. If you want to initial the slice with append just make a slice if the initial length of 0 and a preferred capacity: 1 2 3 4 5 x := make ([] int , 0 , 4 ) x = append ( x , 1 ) x = append ( x , 2 ) x = append ( x , 3 , 4 ) fmt . Println ( x ) output: [1 2 3 4]","title":"Capacity"},{"location":"golang/golang-fundamentals/composite_types/#slicing","text":"You can use slicing with slices to define a \"from\" \"to\" (excluded) range. If you do not the \"from\" range 0 will be assumed, as for \"to\". 1 2 3 4 5 x := [] int { 1 , 2 , 3 , 4 } fmt . Println ( x [: 2 ]) fmt . Println ( x [ 1 :]) fmt . Println ( x [ 1 : 2 ]) fmt . Println ( x [:]) output: [1 2] [2 3 4] [2] [1 2 3 4] Note You will not make a copy of a slice, if you use slicing. Slicings of a slice share the same memory and can be modified. Let's see how we modify the sliced slice to the original slice: 1 2 3 4 x := [] int { 1 , 2 , 3 , 4 } y := x [: 1 ] y [ 0 ] = 9 fmt . Println ( x ) output: [9 2 3 4] If you have arrays, you can convert them to a slice by using slicing. 1 2 3 4 5 x := [ 4 ] int { 1 , 2 , 3 , 4 } y := x [:] y = append ( y , 1 ) fmt . Println ( x ) fmt . Println ( y ) Output: [1 2 3 4] [1 2 3 4 1] If you want to copy a slice you can use the built-in function. It copies all values from a source slice into a destination slice, but consider that the parameters are swapped: copy(destination, source) . copy is limited to the length of the smaller slice (the capacity doesn't matter). So for example: 1 2 3 4 x := [] int { 1 , 2 , 3 , 4 } y := make ([] int , 2 ) num := copy ( x , y ) fmt . Println ( num , y ) output: 2 [1 2]","title":"Slicing"},{"location":"golang/golang-fundamentals/composite_types/#maps","text":"Maps are key-value variables. Maps are not comparable. Let's see how to declare one: 1 2 3 var myMap map [ string ] int fmt . Println ( myMap == nil ) // -> true If you want to create a map you have several options: 1 2 3 4 5 6 7 8 classes := map [ string ][] string { \"Class 1\" : [] string { \"Sarah\" , \"Peter\" , \"Justin\" , }, \"Class 2\" : [] string { \"Fred\" , \"Ralph\" , \"Lea\" , }, } or use the built-int make function. This will create a 10 length key-value pair map. But, other than slices, it will have a length of 0. 1 classes := make ( map [ string ] int , 10 ) The key of a slice can be a comparable type . Reading and writing to a map is similar to reading and writing to slices: 1 2 3 4 5 6 7 8 9 10 11 12 13 class1 := \"Class 1\" class2 := \"Class 2\" classes := map [ string ][] string { class1 : [] string { \"Sarah\" , \"Peter\" , \"Justin\" , }, class2 : [] string { \"Fred\" , \"Ralph\" , \"Lea\" , }, } fmt . Println ( classes ) classes [ class1 ] = append ( classes [ class1 ], \"Christian\" ) fmt . Println ( classes [ class1 ]) output: map[Class 1:[Sarah Peter Justin] Class 2:[Fred Ralph Lea]] [Sarah Peter Justin Christian] If you access a key which is not assigned to the map, it will return the zero value to that type: 1 2 3 4 5 6 7 8 9 10 11 classes := map [ string ][] string { \"Class 1\" : [] string { \"Sarah\" , \"Peter\" , \"Justin\" }, } fmt . Println ( classes [ \"Not exist\" ]) fmt . Println ( classes [ \"Not exist\" ] == nil ) ages := map [ string ] int { \"Tester\" : 31 , } fmt . Println ( ages [ \"Not exist\" ]) fmt . Println ( ages [ \"Not exist\" ] == 0 ) output: [] true 0 true","title":"Maps"},{"location":"golang/golang-fundamentals/composite_types/#variable-ok-idiom","text":"Sometimes you don't want to explicitly check for the zero value like \"\" for strings or 0 for numeric values. There is a syntactic sugar, which helps to do that properly: 1 2 3 4 5 6 7 8 9 10 example := map [ string ] int { \"Hello\" : 119 , \"World\" : 312 , } value , ok := example [ \"Hello\" ] fmt . Println ( value , ok ) value , ok = example [ \"NotExist\" ] fmt . Println ( value , ok ) output: 119 true 0 false If the key is present it will return the value as first return value and a boolean true in the second return value. If the key is not preset it will return the zero value as first return value and a boolean false in the second return value. If you need to delete from maps you can use the built-in delete function. The delete function takes a map and the key. If the key is not present or the map is nil nothing happens. The delete function does not return any value. 1 2 3 4 5 6 example := map [ string ] int { \"Hello\" : 119 , \"World\" : 312 , } delete ( example , \"Hello\" ) delete ( example , \"Test\" )","title":"variable, ok := idiom"},{"location":"golang/golang-fundamentals/composite_types/#structs","text":"With maps you can define dynamic data, but they have limitations. All values have to have the same type and you cannot define which keys are public or private. If you know already what classes are, this is probably what you are searching for: a struct Here is a struct: 1 2 3 4 5 type person struct { firstName string lastName string age int } You can define structs inside or outside functions (respecting the scopes). If you declared a struct type, you can use it: 1 var michael person The variable gets the zero value of a struct which the nil value. If you want to initialize a struct use {} , this will initialize the struct with zero values for all fields. 1 2 3 4 5 var michael = person { \"Michael\" , \"Bykovski\" , 28 , } alternatively you can use the field names to make it explicit: 1 2 3 4 5 var michael = person { firstName : \"Michael\" , lastName : \"Bykovski\" , age : 28 , } Access a struct field by punctuation: 1 2 3 4 5 6 7 var michael = person { firstName : \"Michael\" , lastName : \"Bykovski\" , age : 28 , } michael . age ++ fmt . Println ( michael ) output: {Michael Bykovski 29}","title":"Structs"},{"location":"golang/golang-fundamentals/composite_types/#anonymous-structs","text":"An anonymous struct is a struct without a name. Let's look at an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 var person struct { firstName string lastName string age int } pet := struct { name string kind string } { name : \"Jukes\" , kind : \"cat\" , } Anonymous structs are useful if you want to serialize and deserialize data, which is called \"marshal\" and \"unmarshal\" in Go.","title":"Anonymous structs"},{"location":"golang/golang-fundamentals/composite_types/#comparing-and-converting-structs","text":"If you want to compare structs, Go only compares structs if the fields of a given struct are all comparable . So if you have a list or a map in a struct, it becomes not comparable. If you want to have a custom compare function, you can write your own method. If you compare two different type structs Go will falsify it. But you can do a type conversion between two type structs if they have the same field signatures . Let's first look at a successful type conversion but failed comparison. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 type firstPet struct { name string kind string } type secondPet struct { name string kind string } pet := firstPet { name : \"Jukes\" , kind : \"cat\" , } var pet2 secondPet pet2 = secondPet ( pet ) fmt . Println ( pet2 ) //fmt.Println(pet2 == pet) Type conversion on line 16 would work. But it would fail on line 18 because invalid operation: pet2 == pet (mismatched types secondPet and firstPet) Now let's look at failed type conversions and therefore failed comparisons. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 type firstPet struct { name string kind string } // wrong order type thirdPet struct { kind string name string } // wrong name type fourthPet struct { name string race string } // wrong signatures type fifthPet struct { name string kind string age int } pet := firstPet { name : \"Jukes\" , kind : \"cat\" , } var pet3 thirdPet var pet4 fourthPet var pet5 fifthPet pet3 = thirdPet ( pet ) pet4 = fourthPet ( pet ) pet5 = fifthPet ( pet ) Cannot type convert to any type, because all field signatures are wrong: ./prog.go:41:17: cannot convert pet (variable of type firstPet) to type thirdPet ./prog.go:42:18: cannot convert pet (variable of type firstPet) to type fourthPet ./prog.go:43:17: cannot convert pet (variable of type firstPet) to type fifthPet Now we look at a successfull type conversion and comparison: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type firstPet struct { name string kind string } var anonymousPet struct { name string kind string } pet := firstPet { name : \"Jukes\" , kind : \"cat\" , } anonymousPet = pet fmt . Println ( pet , anonymousPet , anonymousPet == pet ) output: {Jukes cat} {Jukes cat} true","title":"Comparing and Converting Structs"},{"location":"golang/golang-fundamentals/concurrency/","text":"Concurrency When to use concurrency More Concurrency != More Speed Concurrency != Parallelism Concurrency is doing a lot of things at once, Parallelism is doing a lot of things at the same time. Generalizing on that a bit, any producer-consumer problem is a natural fit for 2 goroutines using a channel to pass outputs from the producer to the consumer. Another good use for concurrency is interacting with multiple input/output sources (disks, network, terminal, etc.). Your program should be able to wake up and do some work whenever a result comes from any of these sources. It is possible to do this with one thread and a system call like poll(2) or select(2). When your thread wakes up, it must figure out which result came in, find where it left off in the relevant task, and pick up from there. That's a lot of code you need to write. Writing that code is much easier using one goroutine per task. Then the state of that task is captured implicitly in the goroutine, and picking up where it left off is as simple as waking up and running. Source Go Concurrency Guide Scheduler Every programm gets executed as a process and every process has one or many threads. The scheduler of an operating system decides which process (and the threads within a process) gets a specific amount of time to calculate. Go has it's own scheduler which creates some threads at the start of your Go application. The main function is actually the first Goroutine running in your Go application. Go schedules and assigns Goroutines to the created threads so that the system-overhead can be minimized. There are some benefits by doing that: Goroutines are created faster than usual system threads Goroutines stack sizes are smaller than usual system threads Switching between Goroutines is faster than switching betweens system threads because it happens within the Go programm (process), avoiding system calls The Go scheduler can optimize goroutines by themselves, because it's part of the Go process. It can decide to pause and resume a goroutine because it could have a blocking go operation (channel, mutex) or a blocking system call (ntework, IO, garbage collection). By implementing an own scheduler, this allows to spawn more than ten thousand of simultaneous goroutines. Try so spawn ten thousand system threads, this would result in a mess. Goroutines Goroutines are executed by the keyword go before a function invocation. Don't see it as a async/await, it's more a \"go and never come back\" execution. If you want to return values from your goroutine don't use return, use it with Channels . 1 2 3 4 5 6 7 8 9 10 func Compute () { for i := 0 ; i < 10 _000_000_000 ; i ++ {} fmt . Println ( \"Done\" ) } func main () { fmt . Println ( \"Starting\" ) go Compute () fmt . Println ( \"After Compute\" ) } output: Starting After Compute Channels Channels are like slices and maps, they are a built-in type and can be created using the make function. 1 ch := make ( chan int ) Channels are referenced, this means that channels are actually pointers. The zero value for channels are nil . Reading, Writing Channels The <- operator is used to read or write from channels. If you want to read from a channel, place the operator on the left side; writing on the right side. 1 2 val := <- ch // reading ch <- 3 // writing Values written to a channel can be read only once. If multiple goroutines try to read from a channel, only one will get the value. If you pass a channel into a function, indicate if the function will read or write from the channel. By doing this, you tell the compiler to check, if you only read or write to a channel. Usually a function read from one channel and writes into another. 1 2 3 4 5 6 7 8 func execute ( in <- chan int , out chan <- int ) { go func () { for val := range in { result := process ( val ) out <- result } }() } Go uses unbuffered channels by default. Every write to an open, unbuffered channel causes the writing goroutine to pause until another goroutine reads from this channel. Every read to an open, unbuffered channel causes the reading goroutine to pause until another goroutine writes from this channel. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import ( \"fmt\" \"time\" ) func hello ( done chan bool ) { fmt . Println ( \"Hello world goroutine\" ) time . Sleep ( 5 * time . Second ) done <- true } func main () { done := make ( chan bool ) go hello ( done ) fmt . Println ( \"waiting...\" ) <- done fmt . Println ( \"main function\" ) } will output: waiting... Hello world goroutine main function Buffered Channels Go has buffered channels. This means, that those channels have a limited number of writes without blocking. If the buffer fills before the channel was read from a goroutine, it will block until the channel is read. Reading from an empty buffer blocks also. Creating a buffered channel works the same way as creating an unbuffered channels, but you enter a capacity: 1 ch := make ( chan int , 10 ) len can be used to check, how many values are currently in the channel. cap ca be used to find out the maximum buffer size. Looping over a channel You can use the for-range loop. The loop loops until the channel is closed, until a break or return inside of the loop. 1 2 3 for v := range ch { fmt . Println ( v ) } Closing a channel Close a channel if you are done writing to it: 1 close ( ch ) If you attempt to write or try to close the channel again, Go will panic. Reading from a closed channel works, it will return the zero value of the channels type. When we can always read from a channel, how we can tell if the channel is closed or open and we just read a zero value? We can use the comma ok idiom to check if the channel is closed. If the channel is closed, ok is false; true otherwise: 1 v , ok := <- ch The responsibility to close a channel lies with the goroutine that writes to a channel. Closing is only required, if another goroutine waits for new inputs. This example would result in a deadlock: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import ( \"fmt\" \"time\" ) func hello ( done chan bool ) { fmt . Println ( \"Hello world goroutine\" ) fmt . Println ( \"Waiting 1 seconds\" ) time . Sleep ( 1 * time . Second ) done <- true fmt . Println ( \"Waiting 1 seconds\" ) time . Sleep ( 1 * time . Second ) done <- true } func main () { done := make ( chan bool ) go hello ( done ) for value := range done { fmt . Println ( value ) } } output: Hello world goroutine Waiting 1 seconds true Waiting 1 seconds true fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan receive]: main.main() /Users/michaelbykovski/workspace/daimler/golang_workshop/goroutines_sleep/main.go:21 +0xd0 exit status 2 Because the main function would wait for a new value which cannot be filled by any \"active\" goroutine. To fix that you should close the channel, so that the for-range loop stops: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import ( \"fmt\" \"time\" ) func hello ( done chan bool ) { fmt . Println ( \"Hello world goroutine\" ) fmt . Println ( \"Waiting 1 seconds\" ) time . Sleep ( 1 * time . Second ) done <- true fmt . Println ( \"Waiting 1 seconds\" ) time . Sleep ( 1 * time . Second ) done <- true close ( done ) } func main () { done := make ( chan bool ) go hello ( done ) for value := range done { fmt . Println ( value ) } } output: Hello world goroutine Waiting 1 seconds Waiting 1 seconds true true Select Select statements can be used, to wait for multiple channels simultaneously. Select blocks until one of it's cases fulfills. If multiple cases are ready, it chooses one randomly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import ( \"fmt\" \"time\" ) func main () { one := make ( chan string ) two := make ( chan string ) go func () { time . Sleep ( time . Second * 1 ) one <- \"One\" }() go func () { time . Sleep ( time . Second * 1 ) two <- \"Two\" }() select { case result := <- one : fmt . Println ( \"Received:\" , result ) case result := <- two : fmt . Println ( \"Received:\" , result ) } close ( one ) close ( two ) } This will output sometime two and sometimes one . output: Received: One The done channel pattern Sometimes you have multiple goroutines started, but you wait for only one to resolve and then you need to stop all the others. Then you need the done channel pattern: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import ( \"fmt\" \"math/rand\" \"time\" ) type searcherFunc func ( string ) string func searchData ( s string , searchers [] searcherFunc ) string { done := make ( chan bool ) result := make ( chan string ) for _ , searcher := range searchers { go func ( searcher searcherFunc ) { select { case result <- searcher ( s ): case <- done : } }( searcher ) } r := <- result close ( done ) return r } func RandomBetween ( min int , max int ) int { return rand . Intn ( max - min ) + min } func main () { rand . Seed ( time . Now (). Unix ()) searchers := [] searcherFunc { func ( s string ) string { sleepSeconds := time . Second * time . Duration ( RandomBetween ( 1 , 10 )) time . Sleep ( sleepSeconds ) return \"First!\" }, func ( s string ) string { sleepSeconds := time . Second * time . Duration ( RandomBetween ( 1 , 10 )) time . Sleep ( sleepSeconds ) return \"Second!\" }, func ( s string ) string { sleepSeconds := time . Second * time . Duration ( RandomBetween ( 1 , 10 )) time . Sleep ( sleepSeconds ) return \"Third!\" }, } data := searchData ( \"test\" , searchers ) fmt . Println ( data ) } WaitGroups WaitGroups are handy if you have multiple goroutines and you want to wait for all to finish. The sync package provides the WaitGroup struct. It has the following functions: Add(int) Done() Wait() Let's see the WaitGroup in practice: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import ( \"fmt\" \"sync\" ) func work ( wg * sync . WaitGroup ) { defer wg . Done () fmt . Println ( \"working...\" ) } func main () { var wg sync . WaitGroup wg . Add ( 4 ) go work ( & wg ) go work ( & wg ) go work ( & wg ) go work ( & wg ) fmt . Println ( \"Now lets wait for all to finish\" ) wg . Wait () fmt . Println ( \"All finished\" ) } output: Now lets wait for all to finish working... working... working... working... All finished Mutexes Mutexes are also located in the sync library. Mutexes help to Lock and Unlock critical sections, to prevent race conditions. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \"fmt\" \"sync\" ) type Counter struct { value int } func ( c * Counter ) Update ( n int , wg * sync . WaitGroup ) { value := c . value defer wg . Done () fmt . Printf ( \"Adding %d to %d\\n\" , n , value ) c . value = value + n } func main () { var wg sync . WaitGroup c := Counter {} wg . Add ( 4 ) go c . Update ( 10 , & wg ) go c . Update ( - 5 , & wg ) go c . Update ( 25 , & wg ) go c . Update ( 19 , & wg ) wg . Wait () fmt . Println ( c . value ) } c.Update() works on the c.value variable and since they are all running concurrent, you never now, which value is currently in c.value . output: Adding 19 to 0 Adding -5 to 0 Adding 10 to 0 Adding 25 to 0 25 You can fix that by using Mutex : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 type Counter struct { m sync . Mutex value int } func ( c * Counter ) Update ( n int , wg * sync . WaitGroup ) { c . m . Lock () defer wg . Done () fmt . Printf ( \"Adding %d to %d\\n\" , n , c . value ) c . value += n c . m . Unlock () } func main () { var wg sync . WaitGroup c := Counter {} wg . Add ( 4 ) go c . Update ( 10 , & wg ) go c . Update ( - 5 , & wg ) go c . Update ( 25 , & wg ) go c . Update ( 19 , & wg ) wg . Wait () fmt . Println ( c . value ) } Now the output is correct, because we Lock the critical section c.value and only one goroutine is allowed to work on it until it Unlock the Mutex again. Adding 19 to 0 Adding 10 to 19 Adding -5 to 29 Adding 25 to 24 49 Concurrency in Go Concurrency can be very frustrating, because a lot of things happen at the same time in your application and it can be very hard to predict or even debug, what is happening. For this there is a very good book by Katherine Cox-Buday it's called Concurrency in Go .","title":"Concurrency"},{"location":"golang/golang-fundamentals/concurrency/#concurrency","text":"","title":"Concurrency"},{"location":"golang/golang-fundamentals/concurrency/#when-to-use-concurrency","text":"More Concurrency != More Speed Concurrency != Parallelism Concurrency is doing a lot of things at once, Parallelism is doing a lot of things at the same time. Generalizing on that a bit, any producer-consumer problem is a natural fit for 2 goroutines using a channel to pass outputs from the producer to the consumer. Another good use for concurrency is interacting with multiple input/output sources (disks, network, terminal, etc.). Your program should be able to wake up and do some work whenever a result comes from any of these sources. It is possible to do this with one thread and a system call like poll(2) or select(2). When your thread wakes up, it must figure out which result came in, find where it left off in the relevant task, and pick up from there. That's a lot of code you need to write. Writing that code is much easier using one goroutine per task. Then the state of that task is captured implicitly in the goroutine, and picking up where it left off is as simple as waking up and running. Source Go Concurrency Guide","title":"When to use concurrency"},{"location":"golang/golang-fundamentals/concurrency/#scheduler","text":"Every programm gets executed as a process and every process has one or many threads. The scheduler of an operating system decides which process (and the threads within a process) gets a specific amount of time to calculate. Go has it's own scheduler which creates some threads at the start of your Go application. The main function is actually the first Goroutine running in your Go application. Go schedules and assigns Goroutines to the created threads so that the system-overhead can be minimized. There are some benefits by doing that: Goroutines are created faster than usual system threads Goroutines stack sizes are smaller than usual system threads Switching between Goroutines is faster than switching betweens system threads because it happens within the Go programm (process), avoiding system calls The Go scheduler can optimize goroutines by themselves, because it's part of the Go process. It can decide to pause and resume a goroutine because it could have a blocking go operation (channel, mutex) or a blocking system call (ntework, IO, garbage collection). By implementing an own scheduler, this allows to spawn more than ten thousand of simultaneous goroutines. Try so spawn ten thousand system threads, this would result in a mess.","title":"Scheduler"},{"location":"golang/golang-fundamentals/concurrency/#goroutines","text":"Goroutines are executed by the keyword go before a function invocation. Don't see it as a async/await, it's more a \"go and never come back\" execution. If you want to return values from your goroutine don't use return, use it with Channels . 1 2 3 4 5 6 7 8 9 10 func Compute () { for i := 0 ; i < 10 _000_000_000 ; i ++ {} fmt . Println ( \"Done\" ) } func main () { fmt . Println ( \"Starting\" ) go Compute () fmt . Println ( \"After Compute\" ) } output: Starting After Compute","title":"Goroutines"},{"location":"golang/golang-fundamentals/concurrency/#channels","text":"Channels are like slices and maps, they are a built-in type and can be created using the make function. 1 ch := make ( chan int ) Channels are referenced, this means that channels are actually pointers. The zero value for channels are nil .","title":"Channels"},{"location":"golang/golang-fundamentals/concurrency/#reading-writing-channels","text":"The <- operator is used to read or write from channels. If you want to read from a channel, place the operator on the left side; writing on the right side. 1 2 val := <- ch // reading ch <- 3 // writing Values written to a channel can be read only once. If multiple goroutines try to read from a channel, only one will get the value. If you pass a channel into a function, indicate if the function will read or write from the channel. By doing this, you tell the compiler to check, if you only read or write to a channel. Usually a function read from one channel and writes into another. 1 2 3 4 5 6 7 8 func execute ( in <- chan int , out chan <- int ) { go func () { for val := range in { result := process ( val ) out <- result } }() } Go uses unbuffered channels by default. Every write to an open, unbuffered channel causes the writing goroutine to pause until another goroutine reads from this channel. Every read to an open, unbuffered channel causes the reading goroutine to pause until another goroutine writes from this channel. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import ( \"fmt\" \"time\" ) func hello ( done chan bool ) { fmt . Println ( \"Hello world goroutine\" ) time . Sleep ( 5 * time . Second ) done <- true } func main () { done := make ( chan bool ) go hello ( done ) fmt . Println ( \"waiting...\" ) <- done fmt . Println ( \"main function\" ) } will output: waiting... Hello world goroutine main function","title":"Reading, Writing Channels"},{"location":"golang/golang-fundamentals/concurrency/#buffered-channels","text":"Go has buffered channels. This means, that those channels have a limited number of writes without blocking. If the buffer fills before the channel was read from a goroutine, it will block until the channel is read. Reading from an empty buffer blocks also. Creating a buffered channel works the same way as creating an unbuffered channels, but you enter a capacity: 1 ch := make ( chan int , 10 ) len can be used to check, how many values are currently in the channel. cap ca be used to find out the maximum buffer size.","title":"Buffered Channels"},{"location":"golang/golang-fundamentals/concurrency/#looping-over-a-channel","text":"You can use the for-range loop. The loop loops until the channel is closed, until a break or return inside of the loop. 1 2 3 for v := range ch { fmt . Println ( v ) }","title":"Looping over a channel"},{"location":"golang/golang-fundamentals/concurrency/#closing-a-channel","text":"Close a channel if you are done writing to it: 1 close ( ch ) If you attempt to write or try to close the channel again, Go will panic. Reading from a closed channel works, it will return the zero value of the channels type. When we can always read from a channel, how we can tell if the channel is closed or open and we just read a zero value? We can use the comma ok idiom to check if the channel is closed. If the channel is closed, ok is false; true otherwise: 1 v , ok := <- ch The responsibility to close a channel lies with the goroutine that writes to a channel. Closing is only required, if another goroutine waits for new inputs. This example would result in a deadlock: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import ( \"fmt\" \"time\" ) func hello ( done chan bool ) { fmt . Println ( \"Hello world goroutine\" ) fmt . Println ( \"Waiting 1 seconds\" ) time . Sleep ( 1 * time . Second ) done <- true fmt . Println ( \"Waiting 1 seconds\" ) time . Sleep ( 1 * time . Second ) done <- true } func main () { done := make ( chan bool ) go hello ( done ) for value := range done { fmt . Println ( value ) } } output: Hello world goroutine Waiting 1 seconds true Waiting 1 seconds true fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan receive]: main.main() /Users/michaelbykovski/workspace/daimler/golang_workshop/goroutines_sleep/main.go:21 +0xd0 exit status 2 Because the main function would wait for a new value which cannot be filled by any \"active\" goroutine. To fix that you should close the channel, so that the for-range loop stops: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import ( \"fmt\" \"time\" ) func hello ( done chan bool ) { fmt . Println ( \"Hello world goroutine\" ) fmt . Println ( \"Waiting 1 seconds\" ) time . Sleep ( 1 * time . Second ) done <- true fmt . Println ( \"Waiting 1 seconds\" ) time . Sleep ( 1 * time . Second ) done <- true close ( done ) } func main () { done := make ( chan bool ) go hello ( done ) for value := range done { fmt . Println ( value ) } } output: Hello world goroutine Waiting 1 seconds Waiting 1 seconds true true","title":"Closing a channel"},{"location":"golang/golang-fundamentals/concurrency/#select","text":"Select statements can be used, to wait for multiple channels simultaneously. Select blocks until one of it's cases fulfills. If multiple cases are ready, it chooses one randomly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import ( \"fmt\" \"time\" ) func main () { one := make ( chan string ) two := make ( chan string ) go func () { time . Sleep ( time . Second * 1 ) one <- \"One\" }() go func () { time . Sleep ( time . Second * 1 ) two <- \"Two\" }() select { case result := <- one : fmt . Println ( \"Received:\" , result ) case result := <- two : fmt . Println ( \"Received:\" , result ) } close ( one ) close ( two ) } This will output sometime two and sometimes one . output: Received: One","title":"Select"},{"location":"golang/golang-fundamentals/concurrency/#the-done-channel-pattern","text":"Sometimes you have multiple goroutines started, but you wait for only one to resolve and then you need to stop all the others. Then you need the done channel pattern: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import ( \"fmt\" \"math/rand\" \"time\" ) type searcherFunc func ( string ) string func searchData ( s string , searchers [] searcherFunc ) string { done := make ( chan bool ) result := make ( chan string ) for _ , searcher := range searchers { go func ( searcher searcherFunc ) { select { case result <- searcher ( s ): case <- done : } }( searcher ) } r := <- result close ( done ) return r } func RandomBetween ( min int , max int ) int { return rand . Intn ( max - min ) + min } func main () { rand . Seed ( time . Now (). Unix ()) searchers := [] searcherFunc { func ( s string ) string { sleepSeconds := time . Second * time . Duration ( RandomBetween ( 1 , 10 )) time . Sleep ( sleepSeconds ) return \"First!\" }, func ( s string ) string { sleepSeconds := time . Second * time . Duration ( RandomBetween ( 1 , 10 )) time . Sleep ( sleepSeconds ) return \"Second!\" }, func ( s string ) string { sleepSeconds := time . Second * time . Duration ( RandomBetween ( 1 , 10 )) time . Sleep ( sleepSeconds ) return \"Third!\" }, } data := searchData ( \"test\" , searchers ) fmt . Println ( data ) }","title":"The done channel pattern"},{"location":"golang/golang-fundamentals/concurrency/#waitgroups","text":"WaitGroups are handy if you have multiple goroutines and you want to wait for all to finish. The sync package provides the WaitGroup struct. It has the following functions: Add(int) Done() Wait() Let's see the WaitGroup in practice: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import ( \"fmt\" \"sync\" ) func work ( wg * sync . WaitGroup ) { defer wg . Done () fmt . Println ( \"working...\" ) } func main () { var wg sync . WaitGroup wg . Add ( 4 ) go work ( & wg ) go work ( & wg ) go work ( & wg ) go work ( & wg ) fmt . Println ( \"Now lets wait for all to finish\" ) wg . Wait () fmt . Println ( \"All finished\" ) } output: Now lets wait for all to finish working... working... working... working... All finished","title":"WaitGroups"},{"location":"golang/golang-fundamentals/concurrency/#mutexes","text":"Mutexes are also located in the sync library. Mutexes help to Lock and Unlock critical sections, to prevent race conditions. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \"fmt\" \"sync\" ) type Counter struct { value int } func ( c * Counter ) Update ( n int , wg * sync . WaitGroup ) { value := c . value defer wg . Done () fmt . Printf ( \"Adding %d to %d\\n\" , n , value ) c . value = value + n } func main () { var wg sync . WaitGroup c := Counter {} wg . Add ( 4 ) go c . Update ( 10 , & wg ) go c . Update ( - 5 , & wg ) go c . Update ( 25 , & wg ) go c . Update ( 19 , & wg ) wg . Wait () fmt . Println ( c . value ) } c.Update() works on the c.value variable and since they are all running concurrent, you never now, which value is currently in c.value . output: Adding 19 to 0 Adding -5 to 0 Adding 10 to 0 Adding 25 to 0 25 You can fix that by using Mutex : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 type Counter struct { m sync . Mutex value int } func ( c * Counter ) Update ( n int , wg * sync . WaitGroup ) { c . m . Lock () defer wg . Done () fmt . Printf ( \"Adding %d to %d\\n\" , n , c . value ) c . value += n c . m . Unlock () } func main () { var wg sync . WaitGroup c := Counter {} wg . Add ( 4 ) go c . Update ( 10 , & wg ) go c . Update ( - 5 , & wg ) go c . Update ( 25 , & wg ) go c . Update ( 19 , & wg ) wg . Wait () fmt . Println ( c . value ) } Now the output is correct, because we Lock the critical section c.value and only one goroutine is allowed to work on it until it Unlock the Mutex again. Adding 19 to 0 Adding 10 to 19 Adding -5 to 29 Adding 25 to 24 49","title":"Mutexes"},{"location":"golang/golang-fundamentals/concurrency/#concurrency-in-go","text":"Concurrency can be very frustrating, because a lot of things happen at the same time in your application and it can be very hard to predict or even debug, what is happening. For this there is a very good book by Katherine Cox-Buday it's called Concurrency in Go .","title":"Concurrency in Go"},{"location":"golang/golang-fundamentals/context/","text":"Context Context is the idea to have a request scoped value storage ( Source ). Let's start by taking a look at the context interface: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // A Context carries a deadline, cancellation signal, and request-scoped values // across API boundaries. Its methods are safe for simultaneous use by multiple // goroutines. type Context interface { // Done returns a channel that is closed when this Context is canceled // or times out. Done () <- chan struct {} // Err indicates why this context was canceled, after the Done channel // is closed. Err () error // Deadline returns the time when this Context will be canceled, if any. Deadline () ( deadline time . Time , ok bool ) // Value returns the value associated with key or nil if none. Value ( key interface {}) interface {} } Mostly Context is used to set values within a request and to cancel long running requests. Let's first take a look a simple example: main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func process ( ctx context . Context ) { fmt . Println ( \"Processing user id: \" , ctx . Value ( \"user_id\" )) select { case <- time . After ( 10 * time . Second ): fmt . Println ( \"Processing finished\" ) case <- ctx . Done (): fmt . Println ( \"Processing cancelled\" ) } } func hello ( w http . ResponseWriter , req * http . Request ) { ctx := req . Context () _ , cancelFunc := context . WithCancel ( ctx ) ctx = context . WithValue ( ctx , \"user_id\" , 123 ) go process ( ctx ) select { case <- time . After ( 3 * time . Second ): cancelFunc () fmt . Fprint ( w , \"Cancelled\" ) case <- ctx . Done (): err := ctx . Err () fmt . Println ( \"server:\" , err ) internalError := http . StatusInternalServerError http . Error ( w , err . Error (), internalError ) } } func main () { http . HandleFunc ( \"/hello\" , hello ) http . ListenAndServe ( \":8080\" , nil ) } If you are not in a request-response loop, you can use the built-in functions to create a context for other purposes: main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import ( \"context\" \"fmt\" \"time\" ) func fastRequest ( ctx context . Context , result chan <- string ) { select { case <- ctx . Done (): return case <- time . After ( 5 * time . Second ): result <- \"fast\" return } } func slowRequest ( ctx context . Context , result chan <- string ) { select { case <- ctx . Done (): return case <- time . After ( 30 * time . Second ): result <- \"slow\" return } } func main () { ctx := context . Background () ctx , _ = context . WithDeadline ( ctx , time . Now (). Add ( 7 * time . Second )) data := make ( chan string ) fmt . Println ( \"Startig fast request\" ) go fastRequest ( ctx , data ) fmt . Println ( \"Startig slow request\" ) go slowRequest ( ctx , data ) for { select { case <- ctx . Done (): fmt . Println ( \"Canceled context, quiting\" ) return case result := <- data : fmt . Println ( result ) return } } } output is: Startig fast request Startig slow request fast","title":"Context"},{"location":"golang/golang-fundamentals/context/#context","text":"Context is the idea to have a request scoped value storage ( Source ). Let's start by taking a look at the context interface: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // A Context carries a deadline, cancellation signal, and request-scoped values // across API boundaries. Its methods are safe for simultaneous use by multiple // goroutines. type Context interface { // Done returns a channel that is closed when this Context is canceled // or times out. Done () <- chan struct {} // Err indicates why this context was canceled, after the Done channel // is closed. Err () error // Deadline returns the time when this Context will be canceled, if any. Deadline () ( deadline time . Time , ok bool ) // Value returns the value associated with key or nil if none. Value ( key interface {}) interface {} } Mostly Context is used to set values within a request and to cancel long running requests. Let's first take a look a simple example: main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func process ( ctx context . Context ) { fmt . Println ( \"Processing user id: \" , ctx . Value ( \"user_id\" )) select { case <- time . After ( 10 * time . Second ): fmt . Println ( \"Processing finished\" ) case <- ctx . Done (): fmt . Println ( \"Processing cancelled\" ) } } func hello ( w http . ResponseWriter , req * http . Request ) { ctx := req . Context () _ , cancelFunc := context . WithCancel ( ctx ) ctx = context . WithValue ( ctx , \"user_id\" , 123 ) go process ( ctx ) select { case <- time . After ( 3 * time . Second ): cancelFunc () fmt . Fprint ( w , \"Cancelled\" ) case <- ctx . Done (): err := ctx . Err () fmt . Println ( \"server:\" , err ) internalError := http . StatusInternalServerError http . Error ( w , err . Error (), internalError ) } } func main () { http . HandleFunc ( \"/hello\" , hello ) http . ListenAndServe ( \":8080\" , nil ) } If you are not in a request-response loop, you can use the built-in functions to create a context for other purposes: main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import ( \"context\" \"fmt\" \"time\" ) func fastRequest ( ctx context . Context , result chan <- string ) { select { case <- ctx . Done (): return case <- time . After ( 5 * time . Second ): result <- \"fast\" return } } func slowRequest ( ctx context . Context , result chan <- string ) { select { case <- ctx . Done (): return case <- time . After ( 30 * time . Second ): result <- \"slow\" return } } func main () { ctx := context . Background () ctx , _ = context . WithDeadline ( ctx , time . Now (). Add ( 7 * time . Second )) data := make ( chan string ) fmt . Println ( \"Startig fast request\" ) go fastRequest ( ctx , data ) fmt . Println ( \"Startig slow request\" ) go slowRequest ( ctx , data ) for { select { case <- ctx . Done (): fmt . Println ( \"Canceled context, quiting\" ) return case result := <- data : fmt . Println ( result ) return } } } output is: Startig fast request Startig slow request fast","title":"Context"},{"location":"golang/golang-fundamentals/control_structures/","text":"Control Structures We studied the grammar, primitive types and composite types. Now we are able to work with variables, but they are nothing without \"algorithms\" (without control structures). Let's dive in and see how we do what in Go. Blocks Blocks define the scope of constants, variables, functions and types. Therefore there are several blocks, where one of these can exist. There is a package , file , function , and {} block. All constants, variables, functions and types declared outside of a function are in a package block . All imported constants, variables, functions and types are called file block . All constants, variables, functions and types (parameters included) declared in a function are in a function block . All constants, variables, functions and types declared in curly braces in a function are in a {} block . Shadowing variables Shadowing variables is setting the variable value shortly in a {} block inside of a function block. It only works if you use the same name of the \"shadow\" variable. Here is an example: 1 2 3 4 5 6 7 8 9 func main () { x := 20 if x > 0 { fmt . Println ( x ) x := 5 fmt . Println ( x ) } fmt . Println ( x ) } the output is: 20 5 20 That's why it is so problematic to use := , we can shadow variables in inner scopes of a function, which makes it harder to really define, which value a variable has. Danger You can shadow imported package names. This can break your scope and you should never ever do this: 1 2 3 4 5 6 7 8 9 10 11 package main import ( \"fmt\" ) func main () { x := \"Hello World\" fmt := 20 fmt . Println ( x ) } will output: ./prog.go:10:6: fmt.Println undefined (type int has no field or method Println) Universe Block Golang has only 25 keywords (var, for, switch). Types (int, string), Constants (true, false) and Functions(make, close) are not included in the keyword list. They were defined in a universe block . This is the most outside block. Because they are defined in the most outside block, they can be shadowed. Danger 1 2 3 4 5 6 7 8 9 10 11 package main import ( \"fmt\" ) func main () { fmt . Println ( true ) true := 12 fmt . Println ( true ) } true will be shadowed and can result in big misbehaviour of the code. If If is actually pretty easy and works in the same way as in other programming languages. 1 2 3 4 5 6 7 8 n := 12 if n == 0 { fmt . Println ( \"N is 0\" ) } else if n > 0 { fmt . Println ( \"N is bigger than 0\" ) } else { fmt . Println ( \"N is lower than 0\" ) } Scoping variables in if statements If you want to declare a variable while checking for it's value you can declare a variable directly in an if statement. Variables defined as a scoped variable only exist in the defined scope. 1 2 3 4 5 6 7 if n := 12 ; n == 0 { fmt . Println ( \"N is 0\" ) } else if n > 0 { fmt . Println ( \"N is bigger than 0\" ) } else { fmt . Println ( \"N is lower than 0\" ) } For There is only one looping keywod called for . With for you can define 4 different formats in Go: C-style for Condition for Infinite for for-range C-style for This is probably known to you. The only thing to mention is that you can't use var keyword to define i. 1 2 3 for i := 0 ; i < 10 ; i ++ { fmt . Println ( i ) } Condition for Go has the ability to run a go loop forever until a certain variable because false . This pattern is known as while loops in other programming languages: 1 2 3 4 5 i := 1 for i < 10 { i ++ fmt . Println ( i ) } Infinite for The infinite for works the same way as for the condition for, you just have to leave the condition. This would force the for loop to run forever. 1 2 3 for { fmt . Println ( \"Run forever\" ) } break and continue break helps you to stop a for loop. continue helps you to skip the rest of the scope and start a new loop 1 2 3 4 5 6 for { ... if ! condition { break } } 1 2 3 4 5 6 7 8 9 for { ... if ! condition { ... continue } fmt . Println ( \"This is skipped when condition is false\" ) } for-range for-range loops are designed to make a foreach loop in Go. You can use strings, arrays, slices and maps with foreach loops. Later on we will talk about Channels wher for-range loops can be handy too. 1 2 3 4 values := [] int { 1 , 3 , 5 , 7 , 9 } for i , v := range values { fmt . Println ( i , v ) } output: 0 1 1 3 2 5 3 7 4 9 In a for-range loop you always get two variables. The first one is the index (strings, arrays, slices) or key (maps). The second one is the actual value. If you don't need the key or value in a for-range loop, you can use _ to let Go know, that it should ignore this variable. 1 2 3 4 values := [] int { 1 , 3 , 5 , 7 , 9 } for _ , v := range values { fmt . Println ( v ) } output: 1 3 5 7 9 If you just want the key, you can use the first variable and leave the second not declared. 1 2 3 4 values := [] int { 1 , 3 , 5 , 7 , 9 } for i := range values { fmt . Println ( i ) } for-range variables are copies Go iterates over copies of your variable. Therefore modifying the for-range variables directly is useless. You have to overwrite outer scopes variables: 1 2 3 4 5 6 7 8 9 10 11 12 values := [] int { 1 , 3 , 5 , 7 , 9 } for _ , v := range values { v ++ fmt . Println ( v ) } fmt . Println ( values ) for i := range values { values [ i ] ++ fmt . Println ( values [ i ]) } fmt . Println ( values ) output: 2 4 6 8 10 [1 3 5 7 9] 2 4 6 8 10 [2 4 6 8 10] Labeling for statements You can break or continue in for loops by using labels . This example continues the outer for loop. You will find labeled for loops very rare in the Go ecosystem. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main () { values := [] string { \"hello\" , \"world\" } outer : for _ , value := range values { for i , r := range value { fmt . Println ( i , r , string ( r )) if r == 'l' { continue outer } } fmt . Println ( \"\\n\" ) } } output: 0 104 h 1 101 e 2 108 l 0 119 w 1 111 o 2 114 r 3 108 l switch Switch statements in Go are very useful though in other languages they are more avoided. Let's see an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 words := [] string { \"a\" , \"hello\" , \"gopher\" , \"go\" , \"github\" , \"javascript\" } for _ , word := range words { switch size := len ( word ); size { case 1 , 2 , 3 , 4 : fmt . Println ( word , \"is less than 5 characters long\" ) case 5 : fmt . Println ( word , \"is 5 characters long\" ) case 6 , 7 , 8 , 9 : default : fmt . Println ( word , \"is more than 5 characters long\" ) } } output: a is less than 5 characters long hello is 5 characters long go is less than 5 characters long javascript is more than 5 characters long Duplicate cases You cannot define multiple cases: 1 2 3 4 5 6 7 8 for _ , word := range words { switch size := len ( word ); size { case 1 , 2 , 3 , 4 : fmt . Println ( word , \"is less than 5 characters long\" ) case 1 : fmt . Println ( word , \"\" ) } } Break switch in for loop Sometimes you have to break a for loop. But break inside a switch would result in breaking the switch scope and not the for loop. In that case you can use labels to break explicitly the loop. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func main () { for i := 0 ; i < 10 ; i ++ { switch { case i % 2 == 0 : fmt . Println ( i , \"is even\" ) case i % 3 == 0 : fmt . Println ( i , \"is divisible by 3\" ) case i % 7 == 0 : fmt . Println ( \"exit\" ) break default : fmt . Println ( \"don't know what to do\" ) } } } output: 0 is even don't know what to do 2 is even 3 is divisible by 3 4 is even don't know what to do 6 is even exit 8 is even 9 is divisible by 3 We can fix that by using labeled for loops: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main () { outer : for i := 0 ; i < 10 ; i ++ { switch { case i % 2 == 0 : fmt . Println ( i , \"is even\" ) case i % 3 == 0 : fmt . Println ( i , \"is divisible by 3\" ) case i % 7 == 0 : fmt . Println ( \"exit\" ) break outer default : fmt . Println ( \"don't know what to do\" ) } } } output: 0 is even don't know what to do 2 is even 3 is divisible by 3 4 is even don't know what to do 6 is even exit Blank Switches You can use a variable to switch on the value of it or use a blank switch to switch for boolean expression: 1 2 3 4 5 6 7 8 n := 2 switch n { case 2 : fmt . Println ( \"n is two\" ) default : fmt . Println ( \"n is not two\" ) } 1 2 3 4 5 6 7 8 n := 2 switch { case n == 2 : fmt . Println ( \"n is two\" ) default : fmt . Println ( \"n is not two\" ) } Surely the first one is more explicit. goto Go has the support to use goto statements. You will probably never use goto, but I will show an example here anyway: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func main () { a := 10 goto skip b := 20 skip : c := 30 fmt . Println ( a , b , c ) if c > a { goto inner } if a < b { inner : fmt . Println ( \"a is less than b\" ) } } output: ./prog.go:9:10: goto skip jumps over declaration of b at ./prog.go:10:7 ./prog.go:18:14: goto inner jumps into block starting at ./prog.go:21:14","title":"Control Structures"},{"location":"golang/golang-fundamentals/control_structures/#control-structures","text":"We studied the grammar, primitive types and composite types. Now we are able to work with variables, but they are nothing without \"algorithms\" (without control structures). Let's dive in and see how we do what in Go.","title":"Control Structures"},{"location":"golang/golang-fundamentals/control_structures/#blocks","text":"Blocks define the scope of constants, variables, functions and types. Therefore there are several blocks, where one of these can exist. There is a package , file , function , and {} block. All constants, variables, functions and types declared outside of a function are in a package block . All imported constants, variables, functions and types are called file block . All constants, variables, functions and types (parameters included) declared in a function are in a function block . All constants, variables, functions and types declared in curly braces in a function are in a {} block .","title":"Blocks"},{"location":"golang/golang-fundamentals/control_structures/#shadowing-variables","text":"Shadowing variables is setting the variable value shortly in a {} block inside of a function block. It only works if you use the same name of the \"shadow\" variable. Here is an example: 1 2 3 4 5 6 7 8 9 func main () { x := 20 if x > 0 { fmt . Println ( x ) x := 5 fmt . Println ( x ) } fmt . Println ( x ) } the output is: 20 5 20 That's why it is so problematic to use := , we can shadow variables in inner scopes of a function, which makes it harder to really define, which value a variable has. Danger You can shadow imported package names. This can break your scope and you should never ever do this: 1 2 3 4 5 6 7 8 9 10 11 package main import ( \"fmt\" ) func main () { x := \"Hello World\" fmt := 20 fmt . Println ( x ) } will output: ./prog.go:10:6: fmt.Println undefined (type int has no field or method Println)","title":"Shadowing variables"},{"location":"golang/golang-fundamentals/control_structures/#universe-block","text":"Golang has only 25 keywords (var, for, switch). Types (int, string), Constants (true, false) and Functions(make, close) are not included in the keyword list. They were defined in a universe block . This is the most outside block. Because they are defined in the most outside block, they can be shadowed. Danger 1 2 3 4 5 6 7 8 9 10 11 package main import ( \"fmt\" ) func main () { fmt . Println ( true ) true := 12 fmt . Println ( true ) } true will be shadowed and can result in big misbehaviour of the code.","title":"Universe Block"},{"location":"golang/golang-fundamentals/control_structures/#if","text":"If is actually pretty easy and works in the same way as in other programming languages. 1 2 3 4 5 6 7 8 n := 12 if n == 0 { fmt . Println ( \"N is 0\" ) } else if n > 0 { fmt . Println ( \"N is bigger than 0\" ) } else { fmt . Println ( \"N is lower than 0\" ) }","title":"If"},{"location":"golang/golang-fundamentals/control_structures/#scoping-variables-in-if-statements","text":"If you want to declare a variable while checking for it's value you can declare a variable directly in an if statement. Variables defined as a scoped variable only exist in the defined scope. 1 2 3 4 5 6 7 if n := 12 ; n == 0 { fmt . Println ( \"N is 0\" ) } else if n > 0 { fmt . Println ( \"N is bigger than 0\" ) } else { fmt . Println ( \"N is lower than 0\" ) }","title":"Scoping variables in if statements"},{"location":"golang/golang-fundamentals/control_structures/#for","text":"There is only one looping keywod called for . With for you can define 4 different formats in Go: C-style for Condition for Infinite for for-range","title":"For"},{"location":"golang/golang-fundamentals/control_structures/#c-style-for","text":"This is probably known to you. The only thing to mention is that you can't use var keyword to define i. 1 2 3 for i := 0 ; i < 10 ; i ++ { fmt . Println ( i ) }","title":"C-style for"},{"location":"golang/golang-fundamentals/control_structures/#condition-for","text":"Go has the ability to run a go loop forever until a certain variable because false . This pattern is known as while loops in other programming languages: 1 2 3 4 5 i := 1 for i < 10 { i ++ fmt . Println ( i ) }","title":"Condition for"},{"location":"golang/golang-fundamentals/control_structures/#infinite-for","text":"The infinite for works the same way as for the condition for, you just have to leave the condition. This would force the for loop to run forever. 1 2 3 for { fmt . Println ( \"Run forever\" ) }","title":"Infinite for"},{"location":"golang/golang-fundamentals/control_structures/#break-and-continue","text":"break helps you to stop a for loop. continue helps you to skip the rest of the scope and start a new loop 1 2 3 4 5 6 for { ... if ! condition { break } } 1 2 3 4 5 6 7 8 9 for { ... if ! condition { ... continue } fmt . Println ( \"This is skipped when condition is false\" ) }","title":"break and continue"},{"location":"golang/golang-fundamentals/control_structures/#for-range","text":"for-range loops are designed to make a foreach loop in Go. You can use strings, arrays, slices and maps with foreach loops. Later on we will talk about Channels wher for-range loops can be handy too. 1 2 3 4 values := [] int { 1 , 3 , 5 , 7 , 9 } for i , v := range values { fmt . Println ( i , v ) } output: 0 1 1 3 2 5 3 7 4 9 In a for-range loop you always get two variables. The first one is the index (strings, arrays, slices) or key (maps). The second one is the actual value. If you don't need the key or value in a for-range loop, you can use _ to let Go know, that it should ignore this variable. 1 2 3 4 values := [] int { 1 , 3 , 5 , 7 , 9 } for _ , v := range values { fmt . Println ( v ) } output: 1 3 5 7 9 If you just want the key, you can use the first variable and leave the second not declared. 1 2 3 4 values := [] int { 1 , 3 , 5 , 7 , 9 } for i := range values { fmt . Println ( i ) }","title":"for-range"},{"location":"golang/golang-fundamentals/control_structures/#for-range-variables-are-copies","text":"Go iterates over copies of your variable. Therefore modifying the for-range variables directly is useless. You have to overwrite outer scopes variables: 1 2 3 4 5 6 7 8 9 10 11 12 values := [] int { 1 , 3 , 5 , 7 , 9 } for _ , v := range values { v ++ fmt . Println ( v ) } fmt . Println ( values ) for i := range values { values [ i ] ++ fmt . Println ( values [ i ]) } fmt . Println ( values ) output: 2 4 6 8 10 [1 3 5 7 9] 2 4 6 8 10 [2 4 6 8 10]","title":"for-range variables are copies"},{"location":"golang/golang-fundamentals/control_structures/#labeling-for-statements","text":"You can break or continue in for loops by using labels . This example continues the outer for loop. You will find labeled for loops very rare in the Go ecosystem. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main () { values := [] string { \"hello\" , \"world\" } outer : for _ , value := range values { for i , r := range value { fmt . Println ( i , r , string ( r )) if r == 'l' { continue outer } } fmt . Println ( \"\\n\" ) } } output: 0 104 h 1 101 e 2 108 l 0 119 w 1 111 o 2 114 r 3 108 l","title":"Labeling for statements"},{"location":"golang/golang-fundamentals/control_structures/#switch","text":"Switch statements in Go are very useful though in other languages they are more avoided. Let's see an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 words := [] string { \"a\" , \"hello\" , \"gopher\" , \"go\" , \"github\" , \"javascript\" } for _ , word := range words { switch size := len ( word ); size { case 1 , 2 , 3 , 4 : fmt . Println ( word , \"is less than 5 characters long\" ) case 5 : fmt . Println ( word , \"is 5 characters long\" ) case 6 , 7 , 8 , 9 : default : fmt . Println ( word , \"is more than 5 characters long\" ) } } output: a is less than 5 characters long hello is 5 characters long go is less than 5 characters long javascript is more than 5 characters long","title":"switch"},{"location":"golang/golang-fundamentals/control_structures/#duplicate-cases","text":"You cannot define multiple cases: 1 2 3 4 5 6 7 8 for _ , word := range words { switch size := len ( word ); size { case 1 , 2 , 3 , 4 : fmt . Println ( word , \"is less than 5 characters long\" ) case 1 : fmt . Println ( word , \"\" ) } }","title":"Duplicate cases"},{"location":"golang/golang-fundamentals/control_structures/#break-switch-in-for-loop","text":"Sometimes you have to break a for loop. But break inside a switch would result in breaking the switch scope and not the for loop. In that case you can use labels to break explicitly the loop. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func main () { for i := 0 ; i < 10 ; i ++ { switch { case i % 2 == 0 : fmt . Println ( i , \"is even\" ) case i % 3 == 0 : fmt . Println ( i , \"is divisible by 3\" ) case i % 7 == 0 : fmt . Println ( \"exit\" ) break default : fmt . Println ( \"don't know what to do\" ) } } } output: 0 is even don't know what to do 2 is even 3 is divisible by 3 4 is even don't know what to do 6 is even exit 8 is even 9 is divisible by 3 We can fix that by using labeled for loops: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main () { outer : for i := 0 ; i < 10 ; i ++ { switch { case i % 2 == 0 : fmt . Println ( i , \"is even\" ) case i % 3 == 0 : fmt . Println ( i , \"is divisible by 3\" ) case i % 7 == 0 : fmt . Println ( \"exit\" ) break outer default : fmt . Println ( \"don't know what to do\" ) } } } output: 0 is even don't know what to do 2 is even 3 is divisible by 3 4 is even don't know what to do 6 is even exit","title":"Break switch in for loop"},{"location":"golang/golang-fundamentals/control_structures/#blank-switches","text":"You can use a variable to switch on the value of it or use a blank switch to switch for boolean expression: 1 2 3 4 5 6 7 8 n := 2 switch n { case 2 : fmt . Println ( \"n is two\" ) default : fmt . Println ( \"n is not two\" ) } 1 2 3 4 5 6 7 8 n := 2 switch { case n == 2 : fmt . Println ( \"n is two\" ) default : fmt . Println ( \"n is not two\" ) } Surely the first one is more explicit.","title":"Blank Switches"},{"location":"golang/golang-fundamentals/control_structures/#goto","text":"Go has the support to use goto statements. You will probably never use goto, but I will show an example here anyway: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func main () { a := 10 goto skip b := 20 skip : c := 30 fmt . Println ( a , b , c ) if c > a { goto inner } if a < b { inner : fmt . Println ( \"a is less than b\" ) } } output: ./prog.go:9:10: goto skip jumps over declaration of b at ./prog.go:10:7 ./prog.go:18:14: goto inner jumps into block starting at ./prog.go:21:14","title":"goto"},{"location":"golang/golang-fundamentals/errors/","text":"Errors Handling errors in Go can lead to a strange feeling, the concepts in Go are pretty well-thought. A lot of programmers might Handling Errors If a programm calculates an error or comes in an error state, the specific function should return an error. It is absolute convention to return the error as last return value and let it nil, if there is no error. Use the package errors to create new errors or wrap them. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import ( \"errors\" \"fmt\" ) func divide ( dividend float64 , divisor float64 ) ( float64 , error ) { if divisor == 0 { return 0 , errors . New ( \"divisor is 0\" ) } return dividend / divisor , nil } func main () { result , err := divide ( 12 , 0 ) if err != nil { fmt . Println ( err ) return } fmt . Println ( result ) } The error interface error is a built-in interface which is quiet simple ( link ): 1 2 3 type error interface { Error () string } That's why we can return nil for an error, because it's an interface type. Simple Errors: Strings In Go you can create errors with two built-in libraries: error and fmt . Here is an example: 1 2 3 4 5 6 7 8 import \"errors\" func divide ( dividend float64 , divisor float64 ) ( float64 , error ) { if divisor == 0 { return 0 , errors . New ( \"divisor is 0\" ) } return dividend / divisor , nil } or if you need some data in the error string: 1 2 3 4 5 6 7 8 import \"fmt\" func divide ( dividend float64 , divisor float64 ) ( float64 , error ) { if divisor == 0 { return 0 , fmt . Errorf ( \"divisor is %d\" , divisor ) } return dividend / divisor , nil } Sentinel Errors Sentinel Errors are constants defined for a whole package (we will talk about packages later). It's convention to start the name with Err . Let's see an example: 1 2 3 4 5 6 7 8 9 10 type CustomError string func ( ce CustomerError ) Error () string { return string ( ce ) } const ( ErrFileNotFound CustomError ( \"File was not found\" ) ErrFileCorrupted CustomError ( \"File is corrupted\" ) ) Errors with data Since error is an interface, you can create your own struct to hold more data than just a string. Please mark, that you always return error type and do not specifiy a specific type StatusError because this would minimize abstraction. Let's look at following example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 type Status int const ( InvalidLogin Status = iota + 1 NotFound ) type StatusError struct { Status Status Message string } func ( se StatusError ) Error () string { return se . Message } func Login ( username string , password string ) User , error { loginService := LoginService {} userService := UserService {} id , err := loginService . login ( username , password ) if err != nil { return User {}, StatusError { Status : InvalidLogin , Message : err . Error (), } } user , err := userService . User ( id ) if err != nil { return User {}, StatusError { Status : NotFound , Message : err . Error (), } } return user , nil } Wrapping Errors Sometimes you want to add additional information to an error, for example the location where the error happened. There is a builtin function called fmt.Errorf with the special verb %w to add an error into an error string. With another built-in library you can 'unwrap' the error from another one. It's called errors.Unwrap . It will return an error if it unwraps an error, otherwise nil . Let's see an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \"errors\" \"fmt\" \"os\" ) func fileChecker ( name string ) error { f , err := os . Open ( name ) if err != nil { return fmt . Errorf ( \"in fileChecker: %w\" , err ) } f . Close () return nil } func main () { err := fileChecker ( \"doesNotExist.txt\" ) if err != nil { fmt . Println ( err ) if wrappedErr := errors . Unwrap ( err ); wrappedErr != nil { fmt . Println ( wrappedErr ) } } } output: in fileChecker: open doesNotExist.txt: no such file or directory open doesNotExist.txt: no such file or directory Error Is, Error As Multiple Wrapped Errors \"hide\" the errors they wrapped. There is a solution to check, if an error variable wrapped another error. Let's use our fileChecker example again: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \"errors\" \"fmt\" \"os\" ) func fileChecker ( name string ) error { f , err := os . Open ( name ) if err != nil { return fmt . Errorf ( \"in fileChecker: %w\" , err ) } f . Close () return nil } func main () { err := fileChecker ( \"doesNotExist.txt\" ) if err != nil { fmt . Println ( err ) if errors . Is ( err , os . ErrNotExist ) { fmt . Println ( \"The file does not exist\" ) } } } With errors.As you can check, if an error has a custom error type: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import ( \"errors\" \"fmt\" \"os\" ) type FileCheckerError struct { name string err error } func ( fce FileCheckerError ) Error () string { return fmt . Sprintf ( \"FileCheckerError %s: %s\" , fce . name , fce . err ) } func fileChecker ( name string ) error { f , err := os . Open ( name ) if err != nil { return FileCheckerError { name : name , err : err , } } f . Close () return nil } func main () { err := fileChecker ( \"doesNotExist.txt\" ) if err != nil { var fileCheckerError FileCheckerError if errors . As ( err , & fileCheckerError ) { fmt . Println ( fileCheckerError ) } else { fmt . Println ( err ) } } } output: FileCheckerError doesNotExist.txt: open doesNotExist.txt: no such file or directory panic and recover Go programms run into panic when there is a state, where the Go programm does not know how to handle it. For example if the programm runs out of memory or if you accessed a slice past it's index. Let's check an example: 1 2 3 4 5 6 7 func doPanic ( msg string ) { panic ( msg ) } func main () { doPanic ( \"What is happening?\" ) } output: panic: What is happening? goroutine 1 [running]: main.doPanic(...) /tmp/sandbox1809318792/prog.go:4 main.main() /tmp/sandbox1809318792/prog.go:8 +0x34 Program exited. You can recover from a panic. Call recover in a defer function, if recover returns the value of the given panic value, then you can handle the panic and the programm proceeds normaly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func div60 ( i int ) { defer func () { if v := recover (); v != nil { fmt . Println ( v ) } }() fmt . Println ( 60 / i ) } func main () { for _ , val := range [] int { 1 , 2 , 0 , 6 } { div60 ( val ) } } output is: 60 30 runtime error: integer divide by zero 10 Panic and Recover look like exception handling, but they are not. A panic indicates a really problematical state and should'nt be abused. Therefore use panic and especially recover if you really know what you are doing! Stacktrace from Errors Sometimes you want to see, where your error happened. For that you can just print out the error with the verb %+v . Here is an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 func divide ( dividend float64 , divisor float64 ) ( float64 , error ) { if divisor == 0 { return 0 , fmt . Errorf ( \"divisor is %d\" , divisor ) } return dividend / divisor , nil } func main () { err := divide ( 10 , 0 ) if err != nil { fmt . Printf ( \"%+v\" , err ) } } the output would be: ./prog.go:13:9: assignment mismatch: 1 variable but divide returns 2 values","title":"Errors"},{"location":"golang/golang-fundamentals/errors/#errors","text":"Handling errors in Go can lead to a strange feeling, the concepts in Go are pretty well-thought. A lot of programmers might","title":"Errors"},{"location":"golang/golang-fundamentals/errors/#handling-errors","text":"If a programm calculates an error or comes in an error state, the specific function should return an error. It is absolute convention to return the error as last return value and let it nil, if there is no error. Use the package errors to create new errors or wrap them. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import ( \"errors\" \"fmt\" ) func divide ( dividend float64 , divisor float64 ) ( float64 , error ) { if divisor == 0 { return 0 , errors . New ( \"divisor is 0\" ) } return dividend / divisor , nil } func main () { result , err := divide ( 12 , 0 ) if err != nil { fmt . Println ( err ) return } fmt . Println ( result ) }","title":"Handling Errors"},{"location":"golang/golang-fundamentals/errors/#the-error-interface","text":"error is a built-in interface which is quiet simple ( link ): 1 2 3 type error interface { Error () string } That's why we can return nil for an error, because it's an interface type.","title":"The error interface"},{"location":"golang/golang-fundamentals/errors/#simple-errors-strings","text":"In Go you can create errors with two built-in libraries: error and fmt . Here is an example: 1 2 3 4 5 6 7 8 import \"errors\" func divide ( dividend float64 , divisor float64 ) ( float64 , error ) { if divisor == 0 { return 0 , errors . New ( \"divisor is 0\" ) } return dividend / divisor , nil } or if you need some data in the error string: 1 2 3 4 5 6 7 8 import \"fmt\" func divide ( dividend float64 , divisor float64 ) ( float64 , error ) { if divisor == 0 { return 0 , fmt . Errorf ( \"divisor is %d\" , divisor ) } return dividend / divisor , nil }","title":"Simple Errors: Strings"},{"location":"golang/golang-fundamentals/errors/#sentinel-errors","text":"Sentinel Errors are constants defined for a whole package (we will talk about packages later). It's convention to start the name with Err . Let's see an example: 1 2 3 4 5 6 7 8 9 10 type CustomError string func ( ce CustomerError ) Error () string { return string ( ce ) } const ( ErrFileNotFound CustomError ( \"File was not found\" ) ErrFileCorrupted CustomError ( \"File is corrupted\" ) )","title":"Sentinel Errors"},{"location":"golang/golang-fundamentals/errors/#errors-with-data","text":"Since error is an interface, you can create your own struct to hold more data than just a string. Please mark, that you always return error type and do not specifiy a specific type StatusError because this would minimize abstraction. Let's look at following example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 type Status int const ( InvalidLogin Status = iota + 1 NotFound ) type StatusError struct { Status Status Message string } func ( se StatusError ) Error () string { return se . Message } func Login ( username string , password string ) User , error { loginService := LoginService {} userService := UserService {} id , err := loginService . login ( username , password ) if err != nil { return User {}, StatusError { Status : InvalidLogin , Message : err . Error (), } } user , err := userService . User ( id ) if err != nil { return User {}, StatusError { Status : NotFound , Message : err . Error (), } } return user , nil }","title":"Errors with data"},{"location":"golang/golang-fundamentals/errors/#wrapping-errors","text":"Sometimes you want to add additional information to an error, for example the location where the error happened. There is a builtin function called fmt.Errorf with the special verb %w to add an error into an error string. With another built-in library you can 'unwrap' the error from another one. It's called errors.Unwrap . It will return an error if it unwraps an error, otherwise nil . Let's see an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \"errors\" \"fmt\" \"os\" ) func fileChecker ( name string ) error { f , err := os . Open ( name ) if err != nil { return fmt . Errorf ( \"in fileChecker: %w\" , err ) } f . Close () return nil } func main () { err := fileChecker ( \"doesNotExist.txt\" ) if err != nil { fmt . Println ( err ) if wrappedErr := errors . Unwrap ( err ); wrappedErr != nil { fmt . Println ( wrappedErr ) } } } output: in fileChecker: open doesNotExist.txt: no such file or directory open doesNotExist.txt: no such file or directory","title":"Wrapping Errors"},{"location":"golang/golang-fundamentals/errors/#error-is-error-as","text":"Multiple Wrapped Errors \"hide\" the errors they wrapped. There is a solution to check, if an error variable wrapped another error. Let's use our fileChecker example again: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \"errors\" \"fmt\" \"os\" ) func fileChecker ( name string ) error { f , err := os . Open ( name ) if err != nil { return fmt . Errorf ( \"in fileChecker: %w\" , err ) } f . Close () return nil } func main () { err := fileChecker ( \"doesNotExist.txt\" ) if err != nil { fmt . Println ( err ) if errors . Is ( err , os . ErrNotExist ) { fmt . Println ( \"The file does not exist\" ) } } } With errors.As you can check, if an error has a custom error type: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import ( \"errors\" \"fmt\" \"os\" ) type FileCheckerError struct { name string err error } func ( fce FileCheckerError ) Error () string { return fmt . Sprintf ( \"FileCheckerError %s: %s\" , fce . name , fce . err ) } func fileChecker ( name string ) error { f , err := os . Open ( name ) if err != nil { return FileCheckerError { name : name , err : err , } } f . Close () return nil } func main () { err := fileChecker ( \"doesNotExist.txt\" ) if err != nil { var fileCheckerError FileCheckerError if errors . As ( err , & fileCheckerError ) { fmt . Println ( fileCheckerError ) } else { fmt . Println ( err ) } } } output: FileCheckerError doesNotExist.txt: open doesNotExist.txt: no such file or directory","title":"Error Is, Error As"},{"location":"golang/golang-fundamentals/errors/#panic-and-recover","text":"Go programms run into panic when there is a state, where the Go programm does not know how to handle it. For example if the programm runs out of memory or if you accessed a slice past it's index. Let's check an example: 1 2 3 4 5 6 7 func doPanic ( msg string ) { panic ( msg ) } func main () { doPanic ( \"What is happening?\" ) } output: panic: What is happening? goroutine 1 [running]: main.doPanic(...) /tmp/sandbox1809318792/prog.go:4 main.main() /tmp/sandbox1809318792/prog.go:8 +0x34 Program exited. You can recover from a panic. Call recover in a defer function, if recover returns the value of the given panic value, then you can handle the panic and the programm proceeds normaly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func div60 ( i int ) { defer func () { if v := recover (); v != nil { fmt . Println ( v ) } }() fmt . Println ( 60 / i ) } func main () { for _ , val := range [] int { 1 , 2 , 0 , 6 } { div60 ( val ) } } output is: 60 30 runtime error: integer divide by zero 10 Panic and Recover look like exception handling, but they are not. A panic indicates a really problematical state and should'nt be abused. Therefore use panic and especially recover if you really know what you are doing!","title":"panic and recover"},{"location":"golang/golang-fundamentals/errors/#stacktrace-from-errors","text":"Sometimes you want to see, where your error happened. For that you can just print out the error with the verb %+v . Here is an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 func divide ( dividend float64 , divisor float64 ) ( float64 , error ) { if divisor == 0 { return 0 , fmt . Errorf ( \"divisor is %d\" , divisor ) } return dividend / divisor , nil } func main () { err := divide ( 10 , 0 ) if err != nil { fmt . Printf ( \"%+v\" , err ) } } the output would be: ./prog.go:13:9: assignment mismatch: 1 variable but divide returns 2 values","title":"Stacktrace from Errors"},{"location":"golang/golang-fundamentals/functions/","text":"Functions Functions are defined with the func keyword, then the function name, input parameters and their types and the return types. 1 2 3 func sum ( a int , b int ) int { return a + b } There can be also functions without parameters and return types like the main function: 1 2 3 func main () { fmt . Println ( \"Hello World\" ) } Named and Optional Parameters Go doesn't have named and optional parameters. If you want to simulate such a feature, you have create a struct for that. When you want to explicitly set a value to nil, you should use Pointers (Zero Value vs. No Value) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type Options struct { a int b int } func sum ( options Options ) int { return options . a + options . b } func main () { fmt . Println ( sum ( Options { a : 1 })) fmt . Println ( sum ( Options { b : 2 })) fmt . Println ( sum ( Options { a : 1 , b : 2 })) } output: 1 2 3 Variadic Input Parameters and Slices Go supports variadic parametes. Which means, that you can pass an undefined number of parameters of the same type into a function and it will be stored as a slice of the specified parameter type. Let's have a look at variadic functions: 1 2 3 4 5 6 7 func sum ( values ... int ) int { var result int for _ , value := range values { result += value } return result } Multiple Return Values Go allows multiple return values. It works nearly the same way as in Python. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func divAndRemainder ( numerator int , denominator int ) ( int , int , error ) { if denominator == 0 { return 0 , 0 , errors . New ( \"cannot divide by zero\" ) } return numerator / denominator , numerator % denominator , nil } func main () { result , remainder , err := divAndRemainder ( 7 , 4 ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } fmt . Println ( result , remainder ) } Danger You cannot assign multiple return values to one variable. 1 2 3 4 5 6 7 8 9 10 11 func divAndRemainder ( numerator int , denominator int ) ( int , int , error ) { if denominator == 0 { return 0 , 0 , errors . New ( \"cannot divide by zero\" ) } return numerator / denominator , numerator % denominator , nil } func main () { results := divAndRemainder ( 7 , 4 ) } output: ./prog.go:18:13: assignment mismatch: 1 variable but divAndRemainder returns 3 values Ignoring Return Values Surely you can use _ to ignore are value as in variable declarations: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func divAndRemainder ( numerator int , denominator int ) ( int , int , error ) { if denominator == 0 { return 0 , 0 , errors . New ( \"cannot divide by zero\" ) } return numerator / denominator , numerator % denominator , nil } func main () { result , _ , err := divAndRemainder ( 7 , 4 ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } fmt . Println ( result ) } Named Return Values You can use named return values to predeclare variables, which can be used inside of the function to return them later. Those variables will be initialized with zero values, therefore you can return them directly without overwriting the value. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func divAndRemainder ( numerator int , denominator int ) ( result int , remainder int , err error ) { if denominator == 0 { err = errors . New ( \"cannot divide by zero\" ) return result , remainder , err } result = numerator / denominator remainder = numerator % denominator return result , remainder , err } func main () { result , _ , err := divAndRemainder ( 7 , 4 ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } fmt . Println ( result ) } You don't have to return the specified named return values but be careful. If you specified named return values, then you can use return , but you should never ever do this. Functions are values As in other languages functions are values. Therefore you can store functions in variables and work with them. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package main import ( \"fmt\" \"strconv\" ) func add ( i int , j int ) int { return i + j } func sub ( i int , j int ) int { return i - j } func mult ( i int , j int ) int { return i * j } func div ( i int , j int ) int { return i / j } var operatorMap = map [ string ] func ( int , int ) int { \"+\" : add , \"-\" : sub , \"*\" : mult , \"/\" : div , } func main () { operations := [][] string {{ \"2\" , \"+\" , \"4\" }, { \"43\" , \"-\" , \"17\" }} for _ , operation := range operations { n1 , err := strconv . Atoi ( operation [ 0 ]) if err != nil { fmt . Println ( err ) continue } operatorFunc , ok := operatorMap [ operation [ 1 ]] if ! ok { fmt . Println ( \"unsupported operator: \" , operation [ 1 ]) continue } n2 , err := strconv . Atoi ( operation [ 2 ]) if err != nil { fmt . Println ( err ) continue } result := operatorFunc ( n1 , n2 ) fmt . Println ( result ) } } output: 6 26 Function Type Declarations As we see in Functions are values you can use functions in variables. But to use a function as variable you have to define the type of the function. In Go you can define a function as type. Let's look at the following example: 1 2 3 4 5 6 7 8 type operatorFunction func ( int , int ) int var operatorMap = map [ string ] operatorFunction { \"+\" : add , \"-\" : sub , \"*\" : mult , \"/\" : div , } Anonymous functions Anonymous functions can be declared right in the middle of you code. You can declare and call the function directly. Let's face an example: 1 2 3 4 5 6 7 8 func main () { a := 1 b := 3 sum := func ( a int , b int ) int { return a + b }( a , b ) fmt . Println ( sum ) } Passing Functions as Parameters Anonymous functions can be passed as parameters. The interesting thing is here, that those functions inside of a function create a closure . Which means, that the inner anonymous function can access and modify variables in the outer function. Let's see an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type Cat struct { Name string Age int } cats := [] Cat { { \"Mitsu\" , 2 }, { \"Yuki\" , 1 }, { \"Fred\" , 12 }, { \"Bob\" , 8 }, } fmt . Println ( cats ) sort . Slice ( cats , func ( i int , j int ) bool { return cats [ i ]. Age < cats [ j ]. Age }) fmt . Println ( cats ) output: [{Mitsu 2} {Yuki 1} {Fred 12} {Bob 8}] [{Yuki 1} {Mitsu 2} {Bob 8} {Fred 12}] defer Since Go has no try-catch-finally keywords, we need some kind of functionality, to \"cleanup\" things or to run commands, even when everything breaks. In Go you use defer and pass a function call : 1 2 3 4 5 6 7 8 9 10 11 12 13 import ( \"fmt\" ) func main () { defer func () { fmt . Println ( \"Closing\" ) }() a := 1 b := 2 fmt . Println ( \"Sum is: \" , a + b ) } Most of the time, you will use defer cleanup open sockets, file handlers or similar. Since defer can be a anonymous function, you can use it to read or set variables after the outer function has been executed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import ( \"fmt\" ) func outer ( a int , b int ) ( result int ) { defer func () { a = 10 result = a + b fmt . Println ( \"Closing function\" ) }() return result } func main () { result := outer ( 1 , 2 ) fmt . Println ( \"Sum is: \" , result ) } output would be: Closing function Sum is: 12 There is a pattern in Go, which you will find quiet often. A function that allocates a resource and returns a \"cleanup\" function, to free the resource again: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func getFile ( name string ) ( * os . File , func (), error ) { file , err := os . Open ( name ) if err != nil { return nil , nil , err } return file , func () { file . Close () }, nil } f , closer , err := getFile ( os . Args [ 1 ]) if err != nil { log . Fatal ( err ) } defer closer () Go is Call by Value Go is call by value. If you pass a variable into a function and modify it within the function it will modify a copied value and not the passed in value itself. Let's check: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 type person struct { age int name string } func modify ( number int , value string , person person ) { number = 123 value = \"Blah\" person . name = \"Test\" } func main () { number := 321 value := \"Test\" person := person { age : 28 , name : \"Michael\" , } fmt . Println ( number , value , person ) modify ( number , value , person ) fmt . Println ( number , value , person ) }","title":"Functions"},{"location":"golang/golang-fundamentals/functions/#functions","text":"Functions are defined with the func keyword, then the function name, input parameters and their types and the return types. 1 2 3 func sum ( a int , b int ) int { return a + b } There can be also functions without parameters and return types like the main function: 1 2 3 func main () { fmt . Println ( \"Hello World\" ) }","title":"Functions"},{"location":"golang/golang-fundamentals/functions/#named-and-optional-parameters","text":"Go doesn't have named and optional parameters. If you want to simulate such a feature, you have create a struct for that. When you want to explicitly set a value to nil, you should use Pointers (Zero Value vs. No Value) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type Options struct { a int b int } func sum ( options Options ) int { return options . a + options . b } func main () { fmt . Println ( sum ( Options { a : 1 })) fmt . Println ( sum ( Options { b : 2 })) fmt . Println ( sum ( Options { a : 1 , b : 2 })) } output: 1 2 3","title":"Named and Optional Parameters"},{"location":"golang/golang-fundamentals/functions/#variadic-input-parameters-and-slices","text":"Go supports variadic parametes. Which means, that you can pass an undefined number of parameters of the same type into a function and it will be stored as a slice of the specified parameter type. Let's have a look at variadic functions: 1 2 3 4 5 6 7 func sum ( values ... int ) int { var result int for _ , value := range values { result += value } return result }","title":"Variadic Input Parameters and Slices"},{"location":"golang/golang-fundamentals/functions/#multiple-return-values","text":"Go allows multiple return values. It works nearly the same way as in Python. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func divAndRemainder ( numerator int , denominator int ) ( int , int , error ) { if denominator == 0 { return 0 , 0 , errors . New ( \"cannot divide by zero\" ) } return numerator / denominator , numerator % denominator , nil } func main () { result , remainder , err := divAndRemainder ( 7 , 4 ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } fmt . Println ( result , remainder ) } Danger You cannot assign multiple return values to one variable. 1 2 3 4 5 6 7 8 9 10 11 func divAndRemainder ( numerator int , denominator int ) ( int , int , error ) { if denominator == 0 { return 0 , 0 , errors . New ( \"cannot divide by zero\" ) } return numerator / denominator , numerator % denominator , nil } func main () { results := divAndRemainder ( 7 , 4 ) } output: ./prog.go:18:13: assignment mismatch: 1 variable but divAndRemainder returns 3 values","title":"Multiple Return Values"},{"location":"golang/golang-fundamentals/functions/#ignoring-return-values","text":"Surely you can use _ to ignore are value as in variable declarations: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func divAndRemainder ( numerator int , denominator int ) ( int , int , error ) { if denominator == 0 { return 0 , 0 , errors . New ( \"cannot divide by zero\" ) } return numerator / denominator , numerator % denominator , nil } func main () { result , _ , err := divAndRemainder ( 7 , 4 ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } fmt . Println ( result ) }","title":"Ignoring Return Values"},{"location":"golang/golang-fundamentals/functions/#named-return-values","text":"You can use named return values to predeclare variables, which can be used inside of the function to return them later. Those variables will be initialized with zero values, therefore you can return them directly without overwriting the value. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func divAndRemainder ( numerator int , denominator int ) ( result int , remainder int , err error ) { if denominator == 0 { err = errors . New ( \"cannot divide by zero\" ) return result , remainder , err } result = numerator / denominator remainder = numerator % denominator return result , remainder , err } func main () { result , _ , err := divAndRemainder ( 7 , 4 ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } fmt . Println ( result ) } You don't have to return the specified named return values but be careful. If you specified named return values, then you can use return , but you should never ever do this.","title":"Named Return Values"},{"location":"golang/golang-fundamentals/functions/#functions-are-values","text":"As in other languages functions are values. Therefore you can store functions in variables and work with them. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package main import ( \"fmt\" \"strconv\" ) func add ( i int , j int ) int { return i + j } func sub ( i int , j int ) int { return i - j } func mult ( i int , j int ) int { return i * j } func div ( i int , j int ) int { return i / j } var operatorMap = map [ string ] func ( int , int ) int { \"+\" : add , \"-\" : sub , \"*\" : mult , \"/\" : div , } func main () { operations := [][] string {{ \"2\" , \"+\" , \"4\" }, { \"43\" , \"-\" , \"17\" }} for _ , operation := range operations { n1 , err := strconv . Atoi ( operation [ 0 ]) if err != nil { fmt . Println ( err ) continue } operatorFunc , ok := operatorMap [ operation [ 1 ]] if ! ok { fmt . Println ( \"unsupported operator: \" , operation [ 1 ]) continue } n2 , err := strconv . Atoi ( operation [ 2 ]) if err != nil { fmt . Println ( err ) continue } result := operatorFunc ( n1 , n2 ) fmt . Println ( result ) } } output: 6 26","title":"Functions are values"},{"location":"golang/golang-fundamentals/functions/#function-type-declarations","text":"As we see in Functions are values you can use functions in variables. But to use a function as variable you have to define the type of the function. In Go you can define a function as type. Let's look at the following example: 1 2 3 4 5 6 7 8 type operatorFunction func ( int , int ) int var operatorMap = map [ string ] operatorFunction { \"+\" : add , \"-\" : sub , \"*\" : mult , \"/\" : div , }","title":"Function Type Declarations"},{"location":"golang/golang-fundamentals/functions/#anonymous-functions","text":"Anonymous functions can be declared right in the middle of you code. You can declare and call the function directly. Let's face an example: 1 2 3 4 5 6 7 8 func main () { a := 1 b := 3 sum := func ( a int , b int ) int { return a + b }( a , b ) fmt . Println ( sum ) }","title":"Anonymous functions"},{"location":"golang/golang-fundamentals/functions/#passing-functions-as-parameters","text":"Anonymous functions can be passed as parameters. The interesting thing is here, that those functions inside of a function create a closure . Which means, that the inner anonymous function can access and modify variables in the outer function. Let's see an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type Cat struct { Name string Age int } cats := [] Cat { { \"Mitsu\" , 2 }, { \"Yuki\" , 1 }, { \"Fred\" , 12 }, { \"Bob\" , 8 }, } fmt . Println ( cats ) sort . Slice ( cats , func ( i int , j int ) bool { return cats [ i ]. Age < cats [ j ]. Age }) fmt . Println ( cats ) output: [{Mitsu 2} {Yuki 1} {Fred 12} {Bob 8}] [{Yuki 1} {Mitsu 2} {Bob 8} {Fred 12}]","title":"Passing Functions as Parameters"},{"location":"golang/golang-fundamentals/functions/#defer","text":"Since Go has no try-catch-finally keywords, we need some kind of functionality, to \"cleanup\" things or to run commands, even when everything breaks. In Go you use defer and pass a function call : 1 2 3 4 5 6 7 8 9 10 11 12 13 import ( \"fmt\" ) func main () { defer func () { fmt . Println ( \"Closing\" ) }() a := 1 b := 2 fmt . Println ( \"Sum is: \" , a + b ) } Most of the time, you will use defer cleanup open sockets, file handlers or similar. Since defer can be a anonymous function, you can use it to read or set variables after the outer function has been executed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import ( \"fmt\" ) func outer ( a int , b int ) ( result int ) { defer func () { a = 10 result = a + b fmt . Println ( \"Closing function\" ) }() return result } func main () { result := outer ( 1 , 2 ) fmt . Println ( \"Sum is: \" , result ) } output would be: Closing function Sum is: 12 There is a pattern in Go, which you will find quiet often. A function that allocates a resource and returns a \"cleanup\" function, to free the resource again: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func getFile ( name string ) ( * os . File , func (), error ) { file , err := os . Open ( name ) if err != nil { return nil , nil , err } return file , func () { file . Close () }, nil } f , closer , err := getFile ( os . Args [ 1 ]) if err != nil { log . Fatal ( err ) } defer closer ()","title":"defer"},{"location":"golang/golang-fundamentals/functions/#go-is-call-by-value","text":"Go is call by value. If you pass a variable into a function and modify it within the function it will modify a copied value and not the passed in value itself. Let's check: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 type person struct { age int name string } func modify ( number int , value string , person person ) { number = 123 value = \"Blah\" person . name = \"Test\" } func main () { number := 321 value := \"Test\" person := person { age : 28 , name : \"Michael\" , } fmt . Println ( number , value , person ) modify ( number , value , person ) fmt . Println ( number , value , person ) }","title":"Go is Call by Value"},{"location":"golang/golang-fundamentals/generics/","text":"Generics Generics can be used, if you want to do similar operations with the same function, but you have different variable types. Let's check an example first: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // SumInts adds together the values of m. func SumInts ( m map [ string ] int64 ) int64 { var s int64 for _ , v := range m { s += v } return s } // SumFloats adds together the values of m. func SumFloats ( m map [ string ] float64 ) float64 { var s float64 for _ , v := range m { s += v } return s } func main () { // Initialize a map for the integer values ints := map [ string ] int64 { \"first\" : 34 , \"second\" : 12 , } // Initialize a map for the float values floats := map [ string ] float64 { \"first\" : 35.98 , \"second\" : 26.99 , } fmt . Printf ( \"Non-Generic Sums: %v and %v\\n\" , SumInts ( ints ), SumFloats ( floats )) } output: Non-Generic Sums: 46 and 62.97 Now let's transform the function into a generic one: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func SumIntsOrFloats [ K comparable , V int64 | float64 ]( m map [ K ] V ) V { var s V for _ , v := range m { s += v } return s } func main () { // Initialize a map for the integer values ints := map [ string ] int64 { \"first\" : 34 , \"second\" : 12 , } // Initialize a map for the float values floats := map [ string ] float64 { \"first\" : 35.98 , \"second\" : 26.99 , } fmt . Printf ( \"Generic Sums: %v and %v\\n\" , SumIntsOrFloats ( ints ), SumIntsOrFloats ( floats )) } output: Generic Sums: 46 and 62.97 Type Constraints We can define type constraints by defining new interfaces and use interface embedding . For example we define: 1 2 3 type Number interface { int64 | float64 } now we can use: 1 2 3 4 5 6 7 func SumNumbers [ K comparable , V Number ]( m map [ K ] V ) V { var s V for _ , v := range m { s += v } return s } Underlying Types Sometimes you define a user-defined type, but don't want to add your type to a generic function, which takes in just primitive types. Therefore just use underlying types: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type Number interface { int | int8 | int16 | int32 | int64 } type MySpecialNumber int32 func Sum [ V Number ]( a V , b V ) V { return a + b } func main () { var a MySpecialNumber = 1 var b MySpecialNumber = 2 fmt . Println ( Sum ( a , b )) } makes the error: MySpecialNumber does not implement Number (possibly missing ~ for int32 in constraint Number) So what you need here is underlying types so that you allow any user-defined types, which use the underlying type. Use ~ to make the type underlying. Here is a fixed example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type Number interface { ~ int | ~ int8 | ~ int16 | ~ int32 | ~ int64 } type MySpecialNumber int32 func Sum [ V Number ]( a V , b V ) V { return a + b } func main () { var a MySpecialNumber = 1 var b MySpecialNumber = 2 fmt . Println ( Sum ( a , b )) } Warning You cannot use underlying types with user-defined types. You have to use a primitive type! Which Types? You can use built-in types for generics, but also interfaces: 1 2 3 4 5 6 7 8 9 10 11 type Stringer interface { String () string } func Join [ E Stringer ]( things [] E ) string { var result string for _ , value := range things { result += value . String () } return result } There are also new keywords invented for generics like: any and comparable Constraints Package The constraints package provides some useful interfaces to use for Generics. For example User defined generic types We can also define user-defined generic types. Check the example here: 1 2 3 type Bunch [ E any ] [] E var myBunch := Bunch [ int ]{ 1 , 2 , 3 } Also you can use the Bunch now as parameter type: 1 2 3 4 5 6 7 8 9 type Bunch [ E any ] [] E func PrintBunch [ E any ]( bunch Bunch [ E ]) { //... } func [ b Bunch [ E ]] Print () { // ... } or as a struct: 1 2 3 4 5 6 7 8 9 type List [ T any ] struct { next * List [ T ] value T } func main () { myList := List [ int ]{ value : 2 } fmt . Println ( myList ) }","title":"Generics"},{"location":"golang/golang-fundamentals/generics/#generics","text":"Generics can be used, if you want to do similar operations with the same function, but you have different variable types. Let's check an example first: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // SumInts adds together the values of m. func SumInts ( m map [ string ] int64 ) int64 { var s int64 for _ , v := range m { s += v } return s } // SumFloats adds together the values of m. func SumFloats ( m map [ string ] float64 ) float64 { var s float64 for _ , v := range m { s += v } return s } func main () { // Initialize a map for the integer values ints := map [ string ] int64 { \"first\" : 34 , \"second\" : 12 , } // Initialize a map for the float values floats := map [ string ] float64 { \"first\" : 35.98 , \"second\" : 26.99 , } fmt . Printf ( \"Non-Generic Sums: %v and %v\\n\" , SumInts ( ints ), SumFloats ( floats )) } output: Non-Generic Sums: 46 and 62.97 Now let's transform the function into a generic one: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func SumIntsOrFloats [ K comparable , V int64 | float64 ]( m map [ K ] V ) V { var s V for _ , v := range m { s += v } return s } func main () { // Initialize a map for the integer values ints := map [ string ] int64 { \"first\" : 34 , \"second\" : 12 , } // Initialize a map for the float values floats := map [ string ] float64 { \"first\" : 35.98 , \"second\" : 26.99 , } fmt . Printf ( \"Generic Sums: %v and %v\\n\" , SumIntsOrFloats ( ints ), SumIntsOrFloats ( floats )) } output: Generic Sums: 46 and 62.97","title":"Generics"},{"location":"golang/golang-fundamentals/generics/#type-constraints","text":"We can define type constraints by defining new interfaces and use interface embedding . For example we define: 1 2 3 type Number interface { int64 | float64 } now we can use: 1 2 3 4 5 6 7 func SumNumbers [ K comparable , V Number ]( m map [ K ] V ) V { var s V for _ , v := range m { s += v } return s }","title":"Type Constraints"},{"location":"golang/golang-fundamentals/generics/#underlying-types","text":"Sometimes you define a user-defined type, but don't want to add your type to a generic function, which takes in just primitive types. Therefore just use underlying types: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type Number interface { int | int8 | int16 | int32 | int64 } type MySpecialNumber int32 func Sum [ V Number ]( a V , b V ) V { return a + b } func main () { var a MySpecialNumber = 1 var b MySpecialNumber = 2 fmt . Println ( Sum ( a , b )) } makes the error: MySpecialNumber does not implement Number (possibly missing ~ for int32 in constraint Number) So what you need here is underlying types so that you allow any user-defined types, which use the underlying type. Use ~ to make the type underlying. Here is a fixed example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type Number interface { ~ int | ~ int8 | ~ int16 | ~ int32 | ~ int64 } type MySpecialNumber int32 func Sum [ V Number ]( a V , b V ) V { return a + b } func main () { var a MySpecialNumber = 1 var b MySpecialNumber = 2 fmt . Println ( Sum ( a , b )) } Warning You cannot use underlying types with user-defined types. You have to use a primitive type!","title":"Underlying Types"},{"location":"golang/golang-fundamentals/generics/#which-types","text":"You can use built-in types for generics, but also interfaces: 1 2 3 4 5 6 7 8 9 10 11 type Stringer interface { String () string } func Join [ E Stringer ]( things [] E ) string { var result string for _ , value := range things { result += value . String () } return result } There are also new keywords invented for generics like: any and comparable","title":"Which Types?"},{"location":"golang/golang-fundamentals/generics/#constraints-package","text":"The constraints package provides some useful interfaces to use for Generics. For example","title":"Constraints Package"},{"location":"golang/golang-fundamentals/generics/#user-defined-generic-types","text":"We can also define user-defined generic types. Check the example here: 1 2 3 type Bunch [ E any ] [] E var myBunch := Bunch [ int ]{ 1 , 2 , 3 } Also you can use the Bunch now as parameter type: 1 2 3 4 5 6 7 8 9 type Bunch [ E any ] [] E func PrintBunch [ E any ]( bunch Bunch [ E ]) { //... } func [ b Bunch [ E ]] Print () { // ... } or as a struct: 1 2 3 4 5 6 7 8 9 type List [ T any ] struct { next * List [ T ] value T } func main () { myList := List [ int ]{ value : 2 } fmt . Println ( myList ) }","title":"User defined generic types"},{"location":"golang/golang-fundamentals/grammar/","text":"Grammar Introduction Comments Line comments start with the character sequence // and stop at the end of the line. General comments start with the character sequence /* and stop with the first subsequent character sequence */ . A comment cannot start inside a rune or string literal, or inside a comment. A general comment containing no newlines acts like a space. Any other comment acts like a newline. 1 2 3 4 5 6 7 8 9 10 11 12 package main import \"fmt\" func main () { /* This is a multi line comment. You can type within this section */ fmt . Println ( \"Go!\" ) // single line comment fmt . Println ( \"Lang!\" ) } Semicolons Semicolons in Go are added automatically by the compiler in Go. They are added between the following token and a newline: An identifier (includes words like int, float64) A basic literal (a number or a string constant) One of the tokens: break , continue , fallthrough , return , ++ , -- , ) or } This rule makes it easy to check if a code works imaginary. Check the following code: 1 2 3 4 func main () { fmt . Println ( \"Hello World!\" ) } With the rules from above it would prerpend a semicolon to the ) at the end of line 1. 1 2 3 4 func main (); { fmt . Println ( \"Hello World!\" ); } This is not valid Go code and would result in in a compiler error. Identifiers Identifiers name program entities such as variables and types. An identifier is a sequence of one or more letters and digits. The first character in an identifier must be a letter. identifier = letter { letter | unicode_digit } . a _x9 ThisVariableIsExported \u03b1\u03b2 Blank Identifier There is one special identifier called the blank identifier . This identifier let's you assign every value to it, but you can never read from it: 1 var _ = 2 It's often used to \"throw away\" values or to test a specific type over another. You will see in the next chapters, why we need this. Some identifiers are predeclared, you will find them in the next chapter Keywords . Keywords The following keywords are reserved and may not be used as identifiers. break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var Types any bool byte comparable complex64 complex128 error float32 float64 int int8 int16 int32 int64 rune string uint uint8 uint16 uint32 uint64 uintptr Constants true false iota Zero value: nil Functions append cap close complex copy delete imag len make new panic print println real recover Operators and punctuation Following operators, assignment operators and puctuation is defined in Go. + & += &= && == != ( ) - | -= |= || < <= [ ] * ^ *= ^= <- > >= { } / << /= <<= ++ = := , ; % >> %= >>= -- ! ... . : &^ &^= ~ Integer literals An integer literal is a sequence of digits representing an integer constant. An optional prefix sets a non-decimal base: 0b or 0B for binary, 0, 0o, or 0O for octal, and 0x or 0X for hexadecimal. A single 0 is considered a decimal zero. In hexadecimal literals, letters a through f and A through F represent values 10 through 15. For readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal's value. int_lit = decimal_lit | binary_lit | octal_lit | hex_lit . decimal_lit = \"0\" | ( \"1\" \u2026 \"9\" ) [ [ \"_\" ] decimal_digits ] . binary_lit = \"0\" ( \"b\" | \"B\" ) [ \"_\" ] binary_digits . octal_lit = \"0\" [ \"o\" | \"O\" ] [ \"_\" ] octal_digits . hex_lit = \"0\" ( \"x\" | \"X\" ) [ \"_\" ] hex_digits . decimal_digits = decimal_digit { [ \"_\" ] decimal_digit } . binary_digits = binary_digit { [ \"_\" ] binary_digit } . octal_digits = octal_digit { [ \"_\" ] octal_digit } . hex_digits = hex_digit { [ \"_\" ] hex_digit } . 42 4_2 0600 0_600 0o600 0O600 // second character is capital letter 'O' 0xBadFace 0xBad_Face 0x_67_7a_2f_cc_40_c6 170141183460469231731687303715884105727 170_141183_460469_231731_687303_715884_105727 _42 // an identifier, not an integer literal 42_ // invalid: _ must separate successive digits 4__2 // invalid: only one _ at a time 0_xBadFace // invalid: _ must separate successive digits Floating-point literals A floating-point literal is a decimal or hexadecimal representation of a floating-point constant. A decimal floating-point literal consists of an integer part (decimal digits), a decimal point, a fractional part (decimal digits), and an exponent part (e or E followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; one of the decimal point or the exponent part may be elided. An exponent value exp scales the mantissa (integer and fractional part) by 10exp. A hexadecimal floating-point literal consists of a 0x or 0X prefix, an integer part (hexadecimal digits), a radix point, a fractional part (hexadecimal digits), and an exponent part (p or P followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; the radix point may be elided as well, but the exponent part is required. (This syntax matches the one given in IEEE 754-2008 \u00a75.12.3.) An exponent value exp scales the mantissa (integer and fractional part) by 2exp. For readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal value. float_lit = decimal_float_lit | hex_float_lit . decimal_float_lit = decimal_digits \".\" [ decimal_digits ] [ decimal_exponent ] | decimal_digits decimal_exponent | \".\" decimal_digits [ decimal_exponent ] . decimal_exponent = ( \"e\" | \"E\" ) [ \"+\" | \"-\" ] decimal_digits . hex_float_lit = \"0\" ( \"x\" | \"X\" ) hex_mantissa hex_exponent . hex_mantissa = [ \"_\" ] hex_digits \".\" [ hex_digits ] | [ \"_\" ] hex_digits | \".\" hex_digits . hex_exponent = ( \"p\" | \"P\" ) [ \"+\" | \"-\" ] decimal_digits . 0. 72.40 072.40 // == 72.40 2.71828 1.e+0 6.67428e-11 1E6 .25 .12345E+5 1_5. // == 15.0 0.15e+0_2 // == 15.0 0x1p-2 // == 0.25 0x2.p10 // == 2048.0 0x1.Fp+0 // == 1.9375 0X.8p-0 // == 0.5 0X_1FFFP-16 // == 0.1249847412109375 0x15e-2 // == 0x15e - 2 (integer subtraction) 0x.p1 // invalid: mantissa has no digits 1p-2 // invalid: p exponent requires hexadecimal mantissa 0x1.5e-2 // invalid: hexadecimal mantissa requires p exponent 1_.5 // invalid: _ must separate successive digits 1._5 // invalid: _ must separate successive digits 1.5_e1 // invalid: _ must separate successive digits 1.5e_1 // invalid: _ must separate successive digits 1.5e1_ // invalid: _ must separate successive digits Imaginary literals An imaginary literal represents the imaginary part of a complex constant. It consists of an integer or floating-point literal followed by the lower-case letter i. The value of an imaginary literal is the value of the respective integer or floating-point literal multiplied by the imaginary unit i. imaginary_lit = (decimal_digits | int_lit | float_lit) \"i\" . For backward compatibility, an imaginary literal's integer part consisting entirely of decimal digits (and possibly underscores) is considered a decimal integer, even if it starts with a leading 0 . 0i 0123i // == 123i for backward-compatibility 0o123i // == 0o123 * 1i == 83i 0xabci // == 0xabc * 1i == 2748i 0.i 2.71828i 1.e+0i 6.67428e-11i 1E6i .25i .12345E+5i 0x1p-2i // == 0x1p-2 * Rune literals A rune literal represents a rune constant, an integer value identifying a Unicode code point. A rune literal is expressed as one or more characters enclosed in single quotes, as in 'x' or '\\n'. Within the quotes, any character may appear except newline and unescaped single quote. A single quoted character represents the Unicode value of the character itself, while multi-character sequences beginning with a backslash encode values in various formats. The simplest form represents the single character within the quotes; since Go source text is Unicode characters encoded in UTF-8, multiple UTF-8-encoded bytes may represent a single integer value. For instance, the literal 'a' holds a single byte representing a literal a, Unicode U+0061, value 0x61, while '\u00e4' holds two bytes (0xc3 0xa4) representing a literal a-dieresis, U+00E4, value 0xe4. Several backslash escapes allow arbitrary values to be encoded as ASCII text. There are four ways to represent the integer value as a numeric constant: \\x followed by exactly two hexadecimal digits; \\u followed by exactly four hexadecimal digits; \\U followed by exactly eight hexadecimal digits, and a plain backslash \\ followed by exactly three octal digits. In each case the value of the literal is the value represented by the digits in the corresponding base. Although these representations all result in an integer, they have different valid ranges. Octal escapes must represent a value between 0 and 255 inclusive. Hexadecimal escapes satisfy this condition by construction. The escapes \\u and \\U represent Unicode code points so within them some values are illegal, in particular those above 0x10FFFF and surrogate halves. After a backslash, certain single-character escapes represent special values: \\a U+0007 alert or bell \\b U+0008 backspace \\f U+000C form feed \\n U+000A line feed or newline \\r U+000D carriage return \\t U+0009 horizontal tab \\v U+000B vertical tab \\\\ U+005C backslash \\' U+0027 single quote (valid escape only within rune literals) \\\" U+0022 double quote (valid escape only within string literals) All other sequences starting with a backslash are illegal inside rune literals. rune_lit = \"'\" ( unicode_value | byte_value ) \"'\" . unicode_value = unicode_char | little_u_value | big_u_value | escaped_char . byte_value = octal_byte_value | hex_byte_value . octal_byte_value = `\\` octal_digit octal_digit octal_digit . hex_byte_value = `\\` \"x\" hex_digit hex_digit . little_u_value = `\\` \"u\" hex_digit hex_digit hex_digit hex_digit . big_u_value = `\\` \"U\" hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit . escaped_char = `\\` ( \"a\" | \"b\" | \"f\" | \"n\" | \"r\" | \"t\" | \"v\" | `\\` | \"'\" | `\"` ) . 'a' '\u00e4' '\u672c' '\\t' '\\000' '\\007' '\\377' '\\x07' '\\xff' '\\u12e4' '\\U00101234' '\\'' // rune literal containing single quote character 'aa' // illegal: too many characters '\\xa' // illegal: too few hexadecimal digits '\\0' // illegal: too few octal digits '\\uDFFF' // illegal: surrogate half '\\U00110000' // illegal: invalid Unicode code point String literals A string literal represents a string constant obtained from concatenating a sequence of characters. There are two forms: raw string literals and interpreted string literals. Raw string literals are character sequences between back quotes, as in foo . Within the quotes, any character may appear except back quote. The value of a raw string literal is the string composed of the uninterpreted (implicitly UTF-8-encoded) characters between the quotes; in particular, backslashes have no special meaning and the string may contain newlines. Carriage return characters ('\\r') inside raw string literals are discarded from the raw string value. Interpreted string literals are character sequences between double quotes, as in \"bar\". Within the quotes, any character may appear except newline and unescaped double quote. The text between the quotes forms the value of the literal, with backslash escapes interpreted as they are in rune literals (except that \\' is illegal and \\\" is legal), with the same restrictions. The three-digit octal (\\nnn) and two-digit hexadecimal (\\xnn) escapes represent individual bytes of the resulting string; all other escapes represent the (possibly multi-byte) UTF-8 encoding of individual characters. Thus inside a string literal \\377 and \\xFF represent a single byte of value 0xFF=255, while \u00ff, \\u00FF, \\U000000FF and \\xc3\\xbf represent the two bytes 0xc3 0xbf of the UTF-8 encoding of character U+00FF. string_lit = raw_string_lit | interpreted_string_lit . raw_string_lit = \"`\" { unicode_char | newline } \"`\" . interpreted_string_lit = `\"` { unicode_value | byte_value } `\"` . `abc` // same as \"abc\" `\\n \\n` // same as \"\\\\n\\n\\\\n\" \"\\n\" \"\\\"\" // same as `\"` \"Hello, world!\\n\" \"\u65e5\u672c\u8a9e\" \"\\u65e5\u672c\\U00008a9e\" \"\\xff\\u00FF\" \"\\uD800\" // illegal: surrogate half \"\\U00110000\" // illegal: invalid Unicode code point These examples all represent the same string: \"\u65e5\u672c\u8a9e\" // UTF-8 input text `\u65e5\u672c\u8a9e` // UTF-8 input text as a raw literal \"\\u65e5\\u672c\\u8a9e\" // the explicit Unicode code points \"\\U000065e5\\U0000672c\\U00008a9e\" // the explicit Unicode code points \"\\xe6\\x97\\xa5\\xe6\\x9c\\xac\\xe8\\xaa\\x9e\" // the explicit UTF-8 bytes If the source code represents a character as two code points, such as a combining form involving an accent and a letter, the result will be an error if placed in a rune literal (it is not a single code point), and will appear as two code points if placed in a string literal.","title":"Grammar"},{"location":"golang/golang-fundamentals/grammar/#grammar","text":"","title":"Grammar"},{"location":"golang/golang-fundamentals/grammar/#introduction","text":"","title":"Introduction"},{"location":"golang/golang-fundamentals/grammar/#comments","text":"Line comments start with the character sequence // and stop at the end of the line. General comments start with the character sequence /* and stop with the first subsequent character sequence */ . A comment cannot start inside a rune or string literal, or inside a comment. A general comment containing no newlines acts like a space. Any other comment acts like a newline. 1 2 3 4 5 6 7 8 9 10 11 12 package main import \"fmt\" func main () { /* This is a multi line comment. You can type within this section */ fmt . Println ( \"Go!\" ) // single line comment fmt . Println ( \"Lang!\" ) }","title":"Comments"},{"location":"golang/golang-fundamentals/grammar/#semicolons","text":"Semicolons in Go are added automatically by the compiler in Go. They are added between the following token and a newline: An identifier (includes words like int, float64) A basic literal (a number or a string constant) One of the tokens: break , continue , fallthrough , return , ++ , -- , ) or } This rule makes it easy to check if a code works imaginary. Check the following code: 1 2 3 4 func main () { fmt . Println ( \"Hello World!\" ) } With the rules from above it would prerpend a semicolon to the ) at the end of line 1. 1 2 3 4 func main (); { fmt . Println ( \"Hello World!\" ); } This is not valid Go code and would result in in a compiler error.","title":"Semicolons"},{"location":"golang/golang-fundamentals/grammar/#identifiers","text":"Identifiers name program entities such as variables and types. An identifier is a sequence of one or more letters and digits. The first character in an identifier must be a letter. identifier = letter { letter | unicode_digit } . a _x9 ThisVariableIsExported \u03b1\u03b2","title":"Identifiers"},{"location":"golang/golang-fundamentals/grammar/#blank-identifier","text":"There is one special identifier called the blank identifier . This identifier let's you assign every value to it, but you can never read from it: 1 var _ = 2 It's often used to \"throw away\" values or to test a specific type over another. You will see in the next chapters, why we need this. Some identifiers are predeclared, you will find them in the next chapter Keywords .","title":"Blank Identifier"},{"location":"golang/golang-fundamentals/grammar/#keywords","text":"The following keywords are reserved and may not be used as identifiers. break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var","title":"Keywords"},{"location":"golang/golang-fundamentals/grammar/#types","text":"any bool byte comparable complex64 complex128 error float32 float64 int int8 int16 int32 int64 rune string uint uint8 uint16 uint32 uint64 uintptr","title":"Types"},{"location":"golang/golang-fundamentals/grammar/#constants","text":"true false iota Zero value: nil","title":"Constants"},{"location":"golang/golang-fundamentals/grammar/#functions","text":"append cap close complex copy delete imag len make new panic print println real recover","title":"Functions"},{"location":"golang/golang-fundamentals/grammar/#operators-and-punctuation","text":"Following operators, assignment operators and puctuation is defined in Go. + & += &= && == != ( ) - | -= |= || < <= [ ] * ^ *= ^= <- > >= { } / << /= <<= ++ = := , ; % >> %= >>= -- ! ... . : &^ &^= ~","title":"Operators and punctuation"},{"location":"golang/golang-fundamentals/grammar/#integer-literals","text":"An integer literal is a sequence of digits representing an integer constant. An optional prefix sets a non-decimal base: 0b or 0B for binary, 0, 0o, or 0O for octal, and 0x or 0X for hexadecimal. A single 0 is considered a decimal zero. In hexadecimal literals, letters a through f and A through F represent values 10 through 15. For readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal's value. int_lit = decimal_lit | binary_lit | octal_lit | hex_lit . decimal_lit = \"0\" | ( \"1\" \u2026 \"9\" ) [ [ \"_\" ] decimal_digits ] . binary_lit = \"0\" ( \"b\" | \"B\" ) [ \"_\" ] binary_digits . octal_lit = \"0\" [ \"o\" | \"O\" ] [ \"_\" ] octal_digits . hex_lit = \"0\" ( \"x\" | \"X\" ) [ \"_\" ] hex_digits . decimal_digits = decimal_digit { [ \"_\" ] decimal_digit } . binary_digits = binary_digit { [ \"_\" ] binary_digit } . octal_digits = octal_digit { [ \"_\" ] octal_digit } . hex_digits = hex_digit { [ \"_\" ] hex_digit } . 42 4_2 0600 0_600 0o600 0O600 // second character is capital letter 'O' 0xBadFace 0xBad_Face 0x_67_7a_2f_cc_40_c6 170141183460469231731687303715884105727 170_141183_460469_231731_687303_715884_105727 _42 // an identifier, not an integer literal 42_ // invalid: _ must separate successive digits 4__2 // invalid: only one _ at a time 0_xBadFace // invalid: _ must separate successive digits","title":"Integer literals"},{"location":"golang/golang-fundamentals/grammar/#floating-point-literals","text":"A floating-point literal is a decimal or hexadecimal representation of a floating-point constant. A decimal floating-point literal consists of an integer part (decimal digits), a decimal point, a fractional part (decimal digits), and an exponent part (e or E followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; one of the decimal point or the exponent part may be elided. An exponent value exp scales the mantissa (integer and fractional part) by 10exp. A hexadecimal floating-point literal consists of a 0x or 0X prefix, an integer part (hexadecimal digits), a radix point, a fractional part (hexadecimal digits), and an exponent part (p or P followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; the radix point may be elided as well, but the exponent part is required. (This syntax matches the one given in IEEE 754-2008 \u00a75.12.3.) An exponent value exp scales the mantissa (integer and fractional part) by 2exp. For readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal value. float_lit = decimal_float_lit | hex_float_lit . decimal_float_lit = decimal_digits \".\" [ decimal_digits ] [ decimal_exponent ] | decimal_digits decimal_exponent | \".\" decimal_digits [ decimal_exponent ] . decimal_exponent = ( \"e\" | \"E\" ) [ \"+\" | \"-\" ] decimal_digits . hex_float_lit = \"0\" ( \"x\" | \"X\" ) hex_mantissa hex_exponent . hex_mantissa = [ \"_\" ] hex_digits \".\" [ hex_digits ] | [ \"_\" ] hex_digits | \".\" hex_digits . hex_exponent = ( \"p\" | \"P\" ) [ \"+\" | \"-\" ] decimal_digits . 0. 72.40 072.40 // == 72.40 2.71828 1.e+0 6.67428e-11 1E6 .25 .12345E+5 1_5. // == 15.0 0.15e+0_2 // == 15.0 0x1p-2 // == 0.25 0x2.p10 // == 2048.0 0x1.Fp+0 // == 1.9375 0X.8p-0 // == 0.5 0X_1FFFP-16 // == 0.1249847412109375 0x15e-2 // == 0x15e - 2 (integer subtraction) 0x.p1 // invalid: mantissa has no digits 1p-2 // invalid: p exponent requires hexadecimal mantissa 0x1.5e-2 // invalid: hexadecimal mantissa requires p exponent 1_.5 // invalid: _ must separate successive digits 1._5 // invalid: _ must separate successive digits 1.5_e1 // invalid: _ must separate successive digits 1.5e_1 // invalid: _ must separate successive digits 1.5e1_ // invalid: _ must separate successive digits","title":"Floating-point literals"},{"location":"golang/golang-fundamentals/grammar/#imaginary-literals","text":"An imaginary literal represents the imaginary part of a complex constant. It consists of an integer or floating-point literal followed by the lower-case letter i. The value of an imaginary literal is the value of the respective integer or floating-point literal multiplied by the imaginary unit i. imaginary_lit = (decimal_digits | int_lit | float_lit) \"i\" . For backward compatibility, an imaginary literal's integer part consisting entirely of decimal digits (and possibly underscores) is considered a decimal integer, even if it starts with a leading 0 . 0i 0123i // == 123i for backward-compatibility 0o123i // == 0o123 * 1i == 83i 0xabci // == 0xabc * 1i == 2748i 0.i 2.71828i 1.e+0i 6.67428e-11i 1E6i .25i .12345E+5i 0x1p-2i // == 0x1p-2 *","title":"Imaginary literals"},{"location":"golang/golang-fundamentals/grammar/#rune-literals","text":"A rune literal represents a rune constant, an integer value identifying a Unicode code point. A rune literal is expressed as one or more characters enclosed in single quotes, as in 'x' or '\\n'. Within the quotes, any character may appear except newline and unescaped single quote. A single quoted character represents the Unicode value of the character itself, while multi-character sequences beginning with a backslash encode values in various formats. The simplest form represents the single character within the quotes; since Go source text is Unicode characters encoded in UTF-8, multiple UTF-8-encoded bytes may represent a single integer value. For instance, the literal 'a' holds a single byte representing a literal a, Unicode U+0061, value 0x61, while '\u00e4' holds two bytes (0xc3 0xa4) representing a literal a-dieresis, U+00E4, value 0xe4. Several backslash escapes allow arbitrary values to be encoded as ASCII text. There are four ways to represent the integer value as a numeric constant: \\x followed by exactly two hexadecimal digits; \\u followed by exactly four hexadecimal digits; \\U followed by exactly eight hexadecimal digits, and a plain backslash \\ followed by exactly three octal digits. In each case the value of the literal is the value represented by the digits in the corresponding base. Although these representations all result in an integer, they have different valid ranges. Octal escapes must represent a value between 0 and 255 inclusive. Hexadecimal escapes satisfy this condition by construction. The escapes \\u and \\U represent Unicode code points so within them some values are illegal, in particular those above 0x10FFFF and surrogate halves. After a backslash, certain single-character escapes represent special values: \\a U+0007 alert or bell \\b U+0008 backspace \\f U+000C form feed \\n U+000A line feed or newline \\r U+000D carriage return \\t U+0009 horizontal tab \\v U+000B vertical tab \\\\ U+005C backslash \\' U+0027 single quote (valid escape only within rune literals) \\\" U+0022 double quote (valid escape only within string literals) All other sequences starting with a backslash are illegal inside rune literals. rune_lit = \"'\" ( unicode_value | byte_value ) \"'\" . unicode_value = unicode_char | little_u_value | big_u_value | escaped_char . byte_value = octal_byte_value | hex_byte_value . octal_byte_value = `\\` octal_digit octal_digit octal_digit . hex_byte_value = `\\` \"x\" hex_digit hex_digit . little_u_value = `\\` \"u\" hex_digit hex_digit hex_digit hex_digit . big_u_value = `\\` \"U\" hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit . escaped_char = `\\` ( \"a\" | \"b\" | \"f\" | \"n\" | \"r\" | \"t\" | \"v\" | `\\` | \"'\" | `\"` ) . 'a' '\u00e4' '\u672c' '\\t' '\\000' '\\007' '\\377' '\\x07' '\\xff' '\\u12e4' '\\U00101234' '\\'' // rune literal containing single quote character 'aa' // illegal: too many characters '\\xa' // illegal: too few hexadecimal digits '\\0' // illegal: too few octal digits '\\uDFFF' // illegal: surrogate half '\\U00110000' // illegal: invalid Unicode code point","title":"Rune literals"},{"location":"golang/golang-fundamentals/grammar/#string-literals","text":"A string literal represents a string constant obtained from concatenating a sequence of characters. There are two forms: raw string literals and interpreted string literals. Raw string literals are character sequences between back quotes, as in foo . Within the quotes, any character may appear except back quote. The value of a raw string literal is the string composed of the uninterpreted (implicitly UTF-8-encoded) characters between the quotes; in particular, backslashes have no special meaning and the string may contain newlines. Carriage return characters ('\\r') inside raw string literals are discarded from the raw string value. Interpreted string literals are character sequences between double quotes, as in \"bar\". Within the quotes, any character may appear except newline and unescaped double quote. The text between the quotes forms the value of the literal, with backslash escapes interpreted as they are in rune literals (except that \\' is illegal and \\\" is legal), with the same restrictions. The three-digit octal (\\nnn) and two-digit hexadecimal (\\xnn) escapes represent individual bytes of the resulting string; all other escapes represent the (possibly multi-byte) UTF-8 encoding of individual characters. Thus inside a string literal \\377 and \\xFF represent a single byte of value 0xFF=255, while \u00ff, \\u00FF, \\U000000FF and \\xc3\\xbf represent the two bytes 0xc3 0xbf of the UTF-8 encoding of character U+00FF. string_lit = raw_string_lit | interpreted_string_lit . raw_string_lit = \"`\" { unicode_char | newline } \"`\" . interpreted_string_lit = `\"` { unicode_value | byte_value } `\"` . `abc` // same as \"abc\" `\\n \\n` // same as \"\\\\n\\n\\\\n\" \"\\n\" \"\\\"\" // same as `\"` \"Hello, world!\\n\" \"\u65e5\u672c\u8a9e\" \"\\u65e5\u672c\\U00008a9e\" \"\\xff\\u00FF\" \"\\uD800\" // illegal: surrogate half \"\\U00110000\" // illegal: invalid Unicode code point These examples all represent the same string: \"\u65e5\u672c\u8a9e\" // UTF-8 input text `\u65e5\u672c\u8a9e` // UTF-8 input text as a raw literal \"\\u65e5\\u672c\\u8a9e\" // the explicit Unicode code points \"\\U000065e5\\U0000672c\\U00008a9e\" // the explicit Unicode code points \"\\xe6\\x97\\xa5\\xe6\\x9c\\xac\\xe8\\xaa\\x9e\" // the explicit UTF-8 bytes If the source code represents a character as two code points, such as a combining form involving an accent and a letter, the result will be an error if placed in a rune literal (it is not a single code point), and will appear as two code points if placed in a string literal.","title":"String literals"},{"location":"golang/golang-fundamentals/introduction/","text":"Introduction History The Go programming language was conceived in late 2007 as an answer to some of the problems we were seeing developing software infrastructure at Google. The computing landscape today is almost unrelated to the environment in which the languages being used, mostly C++, Java, and Python, had been created. The problems introduced by multicore processors, networked systems, massive computation clusters, and the web programming model were being worked around rather than addressed head-on. Moreover, the scale has changed: today's server programs comprise tens of millions of lines of code, are worked on by hundreds or even thousands of programmers, and are updated literally every day. To make matters worse, build times, even on large compilation clusters, have stretched to many minutes, even hours. Go was designed and developed to make working in this environment more productive. Besides its better-known aspects such as built-in concurrency and garbage collection, Go's design considerations include rigorous dependency management, the adaptability of software architecture as systems grow, and robustness across the boundaries between components. Source Pain points at Google: slow builds uncontrolled dependencies each programmer using a different subset of the language poor program understanding (code hard to read, poorly documented, and so on) duplication of effort cost of updates version skew difficulty of writing automatic tools cross-language builds Gopher Original Gopher Funny Gophers from different projects Projects using Golang Docker Kubernetes Gogs InfluxDB Snappy Minio Mattermost OpenShift Pocketbase Key Benefits Deploy across platforms in record speed For enterprises, Go is preferred for providing rapid cross-platform deployment. With its goroutines, native compilation, and the URI-based package namespacing, Go code compiles to a single, small binary\u2014with zero dependencies\u2014making it very fast. Leverage Go\u2019s out-of-the-box performance to scale with ease Tigran Bayburtsyan, Co-Founder and CTO at Hexact Inc., summarizes five key reasons his company switched to Go: Compiles into a single binary \u2014 \u201cUsing static linking, Go actually combining all dependency libraries and modules into one single binary file based on OS type and architecture.\u201d Static type system \u2014 \u201cType system is really important for large scale applications.\u201d Performance \u2014 \u201cGo performed better because of its concurrency model and CPU scalability. Whenever we need to process some internal request, we are doing it with separate Goroutines which are 10x cheaper in resources than Python Threads.\u201d No need for a web framework \u2014 \u201cIn most of the cases you really don\u2019t need any third-party library.\u201d Great IDE support and debugging \u2014 \u201cAfter rewriting all projects to Go, we got 64 percent less code than we had earlier.\u201d The good Simplicity Fast Built-in Build and Package Management Type Switch Concurrency Values vs Pointers Simplicity Go aims to be a simple programming language. It has a minimal set of language constructs. It makes simple project and package module structures possible. The visibility control only relies on public or private exports. Data Structures can be easily defined by just a few possibilities: Structs, Maps, Arrays. Testing is very easy in Golang, thanks to built-in commands and libraries. Fast Go programs being compiled down to machine code, and having a static type system, makes it really fast during the execution. Also, the startup time is much less than to something like Java or any JVM language. Built-in Build and Package Management Golang has a built-in build and package management what makes it easy to maintain packages. This eliminates the requirement for a third-party package and build management systems like Gradle, Maven, make, etc., and makes life so much easier for developers. Type Switch In Golang it's possible to do easy type switches instead of doing expensive operations like instanceof (Java). Visibility Control Visibility Control can be managed by using public or private variables, constants, and methods. Concurrency Golangs concurrency model is really simple. Goroutines make it possible to start a managed concurrency model. Values vs. Pointers Go supports pass-by-value and pass-by-reference. The bad No Constructors Error Checking Confusing Design No Generics (No Inheritance) No constructors In Golang there are no constructors, you have to write constructors for structs by yourself. Error Checking Each and every error has to be checked. Confusing Design There are some patterns, like the public/private concept and error handling and many more, which can confuse the first time. No Generics This isn't true anymore :) No Inheritance There is a lot of rumor about Golang, that it does not support inheritance. This is not really correct, it actually has a concept for that, which is called embedding. But it just differs from known concepts about inheritance. Which IDE to choose? Jetbrains Goland - paid, preferred VSCode - free Go Extension - free LiteIDE - free, untested Installation To install Golang simply see: go.dev / Download and install Mac users can install golang with brew: brew install go Windows users can install golang with Chocolatey: choco install golang Hello World! main.go 1 2 3 4 5 6 7 package main import \"fmt\" func main () { fmt . Println ( \"Hello World!\" ) } To build and run it, simply run: go run main.go Playground You can always use Go Playground to play around with go or just use it as \"REPL\" editor. Is it \"Go\" or \"Golang\"? Usually you say: \"Go\". This is the official name of the programming language. The only reason why some people say \"Golang\" is, because it helps to identify the term more as programming language and to use it as google query. Also the first domain was reserved for golang.com but now it became go.dev . Books and Sources Effective Go Learning Go The Go Programming Language Go by Example Go Cookbook","title":"Introduction"},{"location":"golang/golang-fundamentals/introduction/#introduction","text":"","title":"Introduction"},{"location":"golang/golang-fundamentals/introduction/#history","text":"The Go programming language was conceived in late 2007 as an answer to some of the problems we were seeing developing software infrastructure at Google. The computing landscape today is almost unrelated to the environment in which the languages being used, mostly C++, Java, and Python, had been created. The problems introduced by multicore processors, networked systems, massive computation clusters, and the web programming model were being worked around rather than addressed head-on. Moreover, the scale has changed: today's server programs comprise tens of millions of lines of code, are worked on by hundreds or even thousands of programmers, and are updated literally every day. To make matters worse, build times, even on large compilation clusters, have stretched to many minutes, even hours. Go was designed and developed to make working in this environment more productive. Besides its better-known aspects such as built-in concurrency and garbage collection, Go's design considerations include rigorous dependency management, the adaptability of software architecture as systems grow, and robustness across the boundaries between components. Source Pain points at Google: slow builds uncontrolled dependencies each programmer using a different subset of the language poor program understanding (code hard to read, poorly documented, and so on) duplication of effort cost of updates version skew difficulty of writing automatic tools cross-language builds","title":"History"},{"location":"golang/golang-fundamentals/introduction/#gopher","text":"Original Gopher Funny Gophers from different projects","title":"Gopher"},{"location":"golang/golang-fundamentals/introduction/#projects-using-golang","text":"Docker Kubernetes Gogs InfluxDB Snappy Minio Mattermost OpenShift Pocketbase","title":"Projects using Golang"},{"location":"golang/golang-fundamentals/introduction/#key-benefits","text":"Deploy across platforms in record speed For enterprises, Go is preferred for providing rapid cross-platform deployment. With its goroutines, native compilation, and the URI-based package namespacing, Go code compiles to a single, small binary\u2014with zero dependencies\u2014making it very fast. Leverage Go\u2019s out-of-the-box performance to scale with ease Tigran Bayburtsyan, Co-Founder and CTO at Hexact Inc., summarizes five key reasons his company switched to Go: Compiles into a single binary \u2014 \u201cUsing static linking, Go actually combining all dependency libraries and modules into one single binary file based on OS type and architecture.\u201d Static type system \u2014 \u201cType system is really important for large scale applications.\u201d Performance \u2014 \u201cGo performed better because of its concurrency model and CPU scalability. Whenever we need to process some internal request, we are doing it with separate Goroutines which are 10x cheaper in resources than Python Threads.\u201d No need for a web framework \u2014 \u201cIn most of the cases you really don\u2019t need any third-party library.\u201d Great IDE support and debugging \u2014 \u201cAfter rewriting all projects to Go, we got 64 percent less code than we had earlier.\u201d","title":"Key Benefits"},{"location":"golang/golang-fundamentals/introduction/#the-good","text":"Simplicity Fast Built-in Build and Package Management Type Switch Concurrency Values vs Pointers","title":"The good"},{"location":"golang/golang-fundamentals/introduction/#simplicity","text":"Go aims to be a simple programming language. It has a minimal set of language constructs. It makes simple project and package module structures possible. The visibility control only relies on public or private exports. Data Structures can be easily defined by just a few possibilities: Structs, Maps, Arrays. Testing is very easy in Golang, thanks to built-in commands and libraries.","title":"Simplicity"},{"location":"golang/golang-fundamentals/introduction/#fast","text":"Go programs being compiled down to machine code, and having a static type system, makes it really fast during the execution. Also, the startup time is much less than to something like Java or any JVM language.","title":"Fast"},{"location":"golang/golang-fundamentals/introduction/#built-in-build-and-package-management","text":"Golang has a built-in build and package management what makes it easy to maintain packages. This eliminates the requirement for a third-party package and build management systems like Gradle, Maven, make, etc., and makes life so much easier for developers.","title":"Built-in Build and Package Management"},{"location":"golang/golang-fundamentals/introduction/#type-switch","text":"In Golang it's possible to do easy type switches instead of doing expensive operations like instanceof (Java).","title":"Type Switch"},{"location":"golang/golang-fundamentals/introduction/#visibility-control","text":"Visibility Control can be managed by using public or private variables, constants, and methods.","title":"Visibility Control"},{"location":"golang/golang-fundamentals/introduction/#concurrency","text":"Golangs concurrency model is really simple. Goroutines make it possible to start a managed concurrency model.","title":"Concurrency"},{"location":"golang/golang-fundamentals/introduction/#values-vs-pointers","text":"Go supports pass-by-value and pass-by-reference.","title":"Values vs. Pointers"},{"location":"golang/golang-fundamentals/introduction/#the-bad","text":"No Constructors Error Checking Confusing Design No Generics (No Inheritance)","title":"The bad"},{"location":"golang/golang-fundamentals/introduction/#no-constructors","text":"In Golang there are no constructors, you have to write constructors for structs by yourself.","title":"No constructors"},{"location":"golang/golang-fundamentals/introduction/#error-checking","text":"Each and every error has to be checked.","title":"Error Checking"},{"location":"golang/golang-fundamentals/introduction/#confusing-design","text":"There are some patterns, like the public/private concept and error handling and many more, which can confuse the first time.","title":"Confusing Design"},{"location":"golang/golang-fundamentals/introduction/#no-generics","text":"This isn't true anymore :)","title":"No Generics"},{"location":"golang/golang-fundamentals/introduction/#no-inheritance","text":"There is a lot of rumor about Golang, that it does not support inheritance. This is not really correct, it actually has a concept for that, which is called embedding. But it just differs from known concepts about inheritance.","title":"No Inheritance"},{"location":"golang/golang-fundamentals/introduction/#which-ide-to-choose","text":"Jetbrains Goland - paid, preferred VSCode - free Go Extension - free LiteIDE - free, untested","title":"Which IDE to choose?"},{"location":"golang/golang-fundamentals/introduction/#installation","text":"To install Golang simply see: go.dev / Download and install Mac users can install golang with brew: brew install go Windows users can install golang with Chocolatey: choco install golang","title":"Installation"},{"location":"golang/golang-fundamentals/introduction/#hello-world","text":"main.go 1 2 3 4 5 6 7 package main import \"fmt\" func main () { fmt . Println ( \"Hello World!\" ) } To build and run it, simply run: go run main.go","title":"Hello World!"},{"location":"golang/golang-fundamentals/introduction/#playground","text":"You can always use Go Playground to play around with go or just use it as \"REPL\" editor.","title":"Playground"},{"location":"golang/golang-fundamentals/introduction/#is-it-go-or-golang","text":"Usually you say: \"Go\". This is the official name of the programming language. The only reason why some people say \"Golang\" is, because it helps to identify the term more as programming language and to use it as google query. Also the first domain was reserved for golang.com but now it became go.dev .","title":"Is it \"Go\" or \"Golang\"?"},{"location":"golang/golang-fundamentals/introduction/#books-and-sources","text":"Effective Go Learning Go The Go Programming Language Go by Example Go Cookbook","title":"Books and Sources"},{"location":"golang/golang-fundamentals/logging/","text":"Logging To use logging the log package provides a standard logger, which prints to the systems Standard out . Source The documentation says: Package log implements a simple logging package. It defines a type, Logger, with methods for formatting output. It also has a predefined 'standard' Logger accessible through helper functions Print[f|ln], Fatal[f|ln], and Panic[f|ln], which are easier to use than creating a Logger manually. That logger writes to standard error and prints the date and time of each logged message. Every log message is output on a separate line: if the message being printed does not end in a newline, the logger will add one. The Fatal functions call os.Exit(1) after writing the log message. The Panic functions call panic after writing the log message. So if you want to use the default logger, here is an example: 1 2 3 4 5 6 7 8 func main () { a := 2 logger := log . Default () logger . Print ( \"Just print a string \" , a ) logger . Printf ( \"print a digit: %d\" , a ) logger . Fatal ( \"print and os.Exit(1)\" ) logger . Panic ( \"print and panic\" ) } output: 2009/11/10 23:00:00 Just print a string 2 2009/11/10 23:00:00 print a digit: 2 2009/11/10 23:00:00 print and os.Exit(1) JSON Logger If you want to have a JSON logger, you can write one on your own. Here you could use embedding, to support the log.Logger struct: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 type JSONLogger struct { log . Logger } func ( l JSONLogger ) Print ( value interface {}) { bytes , err := json . Marshal ( map [ string ] interface {}{ \"value\" : value , \"time\" : time . Now (). Format ( \"2006-01-02T15:04:05Z07:00\" ), }) if err != nil { panic ( err ) } l . Logger . Print ( string ( bytes )) } func NewJSONLogger ( logger log . Logger ) JSONLogger { return JSONLogger { Logger : logger , } } func main () { jsonLogger := NewJSONLogger ( * log . New ( os . Stdout , \"\" , 0 )) jsonLogger . Print ( struct { Name string `json:\"name\"` LastName string `json:\"lastName\"` }{ Name : \"hello\" , LastName : \"world\" , }) } Zap Logger The Zap Logger is faster than the default logger. Let's check an example: Add zap logger to your dependencies: go get go.uber.org/zap Then use the zap logger: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import ( \"go.uber.org/zap\" ) func main () { developmentLogger , err := zap . NewDevelopment () if err != nil { panic ( err ) } productionLogger , err := zap . NewProduction () if err != nil { panic ( err ) } developmentLogger . Info ( \"failed to fetch URL\" , zap . String ( \"url\" , \"url\" ), ) productionLogger . Info ( \"failed to fetch URL\" , zap . String ( \"url\" , \"url\" ), ) } output: 2022-05-12T14:27:26.733+0200 INFO bruh/main.go:16 failed to fetch URL {\"url\": \"url\"} {\"level\":\"info\",\"ts\":1652358446.733641,\"caller\":\"bruh/main.go:19\",\"msg\":\"failed to fetch URL\",\"url\":\"url\"} The Development Logger produces a tab separated string as log. The Production Logger produces a json string as log.","title":"Logging"},{"location":"golang/golang-fundamentals/logging/#logging","text":"To use logging the log package provides a standard logger, which prints to the systems Standard out . Source The documentation says: Package log implements a simple logging package. It defines a type, Logger, with methods for formatting output. It also has a predefined 'standard' Logger accessible through helper functions Print[f|ln], Fatal[f|ln], and Panic[f|ln], which are easier to use than creating a Logger manually. That logger writes to standard error and prints the date and time of each logged message. Every log message is output on a separate line: if the message being printed does not end in a newline, the logger will add one. The Fatal functions call os.Exit(1) after writing the log message. The Panic functions call panic after writing the log message. So if you want to use the default logger, here is an example: 1 2 3 4 5 6 7 8 func main () { a := 2 logger := log . Default () logger . Print ( \"Just print a string \" , a ) logger . Printf ( \"print a digit: %d\" , a ) logger . Fatal ( \"print and os.Exit(1)\" ) logger . Panic ( \"print and panic\" ) } output: 2009/11/10 23:00:00 Just print a string 2 2009/11/10 23:00:00 print a digit: 2 2009/11/10 23:00:00 print and os.Exit(1)","title":"Logging"},{"location":"golang/golang-fundamentals/logging/#json-logger","text":"If you want to have a JSON logger, you can write one on your own. Here you could use embedding, to support the log.Logger struct: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 type JSONLogger struct { log . Logger } func ( l JSONLogger ) Print ( value interface {}) { bytes , err := json . Marshal ( map [ string ] interface {}{ \"value\" : value , \"time\" : time . Now (). Format ( \"2006-01-02T15:04:05Z07:00\" ), }) if err != nil { panic ( err ) } l . Logger . Print ( string ( bytes )) } func NewJSONLogger ( logger log . Logger ) JSONLogger { return JSONLogger { Logger : logger , } } func main () { jsonLogger := NewJSONLogger ( * log . New ( os . Stdout , \"\" , 0 )) jsonLogger . Print ( struct { Name string `json:\"name\"` LastName string `json:\"lastName\"` }{ Name : \"hello\" , LastName : \"world\" , }) }","title":"JSON Logger"},{"location":"golang/golang-fundamentals/logging/#zap-logger","text":"The Zap Logger is faster than the default logger. Let's check an example: Add zap logger to your dependencies: go get go.uber.org/zap Then use the zap logger: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import ( \"go.uber.org/zap\" ) func main () { developmentLogger , err := zap . NewDevelopment () if err != nil { panic ( err ) } productionLogger , err := zap . NewProduction () if err != nil { panic ( err ) } developmentLogger . Info ( \"failed to fetch URL\" , zap . String ( \"url\" , \"url\" ), ) productionLogger . Info ( \"failed to fetch URL\" , zap . String ( \"url\" , \"url\" ), ) } output: 2022-05-12T14:27:26.733+0200 INFO bruh/main.go:16 failed to fetch URL {\"url\": \"url\"} {\"level\":\"info\",\"ts\":1652358446.733641,\"caller\":\"bruh/main.go:19\",\"msg\":\"failed to fetch URL\",\"url\":\"url\"} The Development Logger produces a tab separated string as log. The Production Logger produces a json string as log.","title":"Zap Logger"},{"location":"golang/golang-fundamentals/modules_packages_imports/","text":"Modules, Packages, and Imports Repositories, Modules, and Packages There are three main concepts in Go: repositories , modules , and packages . A repository is the location, where the source code of a project is stored. A module is the root of a Go library or application, inside a repository . Modules consist of one or more packages . Before we use third-party libraries we need to declare that our project is a module . Every module has it's own global unique identifier. It's like in Java the com.example.project.library name. In Go you usually use the location of your project, for example a Github repository. It doesn't have to be the repository location, a unique name is also fine. go.mod Create a module by using: go mod init GLOBAL_UNIQUE_IDENTIFIER The GLOBAL_UNIQUE_IDENTIFIER is case-sensitive, therefore try to avoid uppercase letters. Let's take a look a the go.mod if running the go mod init command. module github.com/bykof/gostradamus go 1.17 require github.com/stretchr/testify v1.7.0 require ( github.com/davecgh/go-spew v1.1.0 // indirect github.com/pmezard/go-difflib v1.0.0 // indirect gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c // indirect ) Beside the require section, there can be custom repositories like: exclude and replace . Cross Compiling First we have to find available platforms, where we can compile to. ( Source ) To find all possible platforms use: go tool dist list output: aix/ppc64 android/386 android/amd64 android/arm android/arm64 darwin/amd64 darwin/arm64 dragonfly/amd64 freebsd/386 freebsd/amd64 freebsd/arm freebsd/arm64 illumos/amd64 ios/amd64 ios/arm64 js/wasm linux/386 linux/amd64 linux/arm linux/arm64 linux/mips linux/mips64 linux/mips64le linux/mipsle linux/ppc64 linux/ppc64le linux/riscv64 linux/s390x netbsd/386 netbsd/amd64 netbsd/arm netbsd/arm64 openbsd/386 openbsd/amd64 openbsd/arm openbsd/arm64 openbsd/mips64 plan9/386 plan9/amd64 plan9/arm solaris/amd64 windows/386 windows/amd64 windows/arm windows/arm64 This will print out all possible cross compilations, since Go 1.15 all possible platforms are built-in. The format of the output is: $GOOS/$GOARCH . Then you can use the following pattern for $GOOS and $GOARCH to cross compile your application: GOOS = windows GOARCH = amd64 go build -o main.exe main.go Go generate Go generate is a useful tool to run important project commands. You can run it with: go generate [ -run regexp ] [ -n ] [ -v ] [ -x ] [ build flags ] [ file.go... | packages ] Go generate will not run automatically with go build, go test and go run. It should be run manually and explicitly. The command should be placed a go file at the top of the file: For example we want to main.go 1 2 3 4 5 package main //go:generate echo \"Hello, Go Generate!\" func main () {} If you run this file with following commands: \u279c go run main.go \u279c go generate Hello, Go Generate! You will see later why it's an important tool and how it can be used with wire . Go format Go format is very important tool, to format your code upon Go conventions ( Source ). It make following standards possible: easier to write: never worry about minor formatting concerns while hacking away, easier to read: when all code looks the same you need not mentally convert others' formatting style into something you can understand. easier to maintain: mechanical changes to the source don\u2019t cause unrelated changes to the file\u2019s formatting; diffs show only the real changes. uncontroversial: never have a debate about spacing or brace position ever again! To use it execute: go fmt path/to/your/package This will format your code automatically. Imports and Exports In Go you can import exported: constants variables functions types and you can export: constants variables functions types methods in a struct fields in a sruct Exporting things in Go is managed by the capitalization . This means, if you start the name of a function with an uppercase letter it gets exported , otherwise it's only visible inside a package. 1 2 3 4 5 6 7 func Exported () { // this function can be accessed from other packages } func packageFunc () { // this function is only available in the package } Packages Creating and accessing packages very easy in Go. Actually you just create a folder with the package name . Then, every file inside the package should have a package clause. The package clause can use the package name or another custom package name . Let's look at an example: math/math.go 1 2 3 4 5 package math func Double ( a int ) in { return a * 2 } formatter/formatter.go 1 2 3 4 5 6 7 package print import \"fmt\" func Format ( num int ) string { return fmt . Sprintf ( \"The numer is %d\" , num ) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \"fmt\" \"example.com/formatter\" , \"example.com/math\" , ) func main () { num := math . Double ( 2 ) output := print . Format ( num ) fmt . Println ( output ) } The import path can be relative, but always use absolute paths with the repository name as root to the module name you want to import, separated by / . In the example we imported example.com/formatter but we defined the packagein formatter.go to be package print . This is because in Go the package declaration happens in the files itself not as directory name. BUT the package name should be the same across a dirctory. It won't work, if you mix package names in a directory. Overriding imports It can happen, that you have to import two packages with the same name. Therefore you can just overwrite the package name by using import alias . Let's check an example: 1 2 3 4 import ( cryptoRand \"crypto/rand\" \"math/rand\" ) Documenting with godoc With godoc you can document your repository and it's packages. There are several rules, which you have to follow: Place the comment directly before the item being documented with no blank lines between the comment and the declaration of the item Start the comment with two forward slashes // followeg by the name of the item Use a blank comment to break your comment into multiple paragraphs Insert preformatted comment by indenting the lines Comments before the package declaration create package level comments. Generate comments by using the command: go doc . internal package If you want to export constants or types between your packages in your module, but you don't want to export them outside of your repository, you can use internal packages. Create a package called internal , everyting exported in the internal package will be accessable by the outer package or sibling package. Here is an example: \u251c\u2500\u2500 bar \u2502 \u2514\u2500\u2500 bar.go \u251c\u2500\u2500 foo \u2502 \u251c\u2500\u2500 foo.go \u2502 \u251c\u2500\u2500 internal \u2502 \u2502 \u2514\u2500\u2500 internal.go \u2502 \u2514\u2500\u2500 sibling \u2502 \u2514\u2500\u2500 sibling.go \u251c\u2500\u2500 go.mod \u2514\u2500\u2500 main.go Only foo and sibling can access exported types from internal . bar cannot access internal . Circular Dependency Go doesn't allow you to have circular dependencies. Modules Let's import now third party libraries by using the library: decimal Here is an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import ( \"fmt\" \"github.com/shopspring/decimal\" ) func main () { price , err := decimal . NewFromString ( \"136.02\" ) if err != nil { panic ( err ) } quantity := decimal . NewFromInt ( 3 ) total := price . Mul ( quantity ) fmt . Println ( \"Total:\" , total ) } If we run go build or go run main.go we get: main.go:6:2: no required module provides package github.com/shopspring/decimal; to add it: go get github.com/shopspring/decimal Here just run: go get github.com/shopspring/decimal We see that Go automatically added the required module to the go.mod it created a go.sum file It took the latest version, since you did no specified one. If the repository does not specify a version, Go will create a pseudo version, with a hash of the module: go.mod module decimal_example go 1.18 require github.com/shopspring/decimal v1.3.1 // indirect go.sum github.com/shopspring/decimal v1.3.1 h1:2Usl1nmF/WZucqkFZhnfFYxxxu8LG21F6nPQBE5gKV8= github.com/shopspring/decimal v1.3.1/go.mod h1:DKyhrW/HYNuLGql+MJL6WCR6knT2jwCFRcu2hWCYk4o= Versions If you want a specific version of a module, just use go get with the @vx.x.x tag: go get github.com/shopspring/decimal@v1.1.0 This will install decimal at version v1.1.0 . Upgrade If you want to upgrade a module to the latest version use: go get -u github.com/shopspring/decimal If you just want to upgrade the patch version use -u=patch . go get -u=patch github.com/shopspring/decimal Vendoring If you want to store the module inside the project folder without depending on the internet, you can use: go mod vendor This will create a vendor folder with downloaded module inside of it. If you update the go.mod you have to rebuild the vendor folder again. Publishing If you want to publish your module to the public, you can do it by upload it to a public repository like Github oder Gitlab. Check my own repository for example: https://github.com/bykof/gostradamus . Versioning Golang uses semantic versioning to create different versions of a module. If you release a new version of your module just tag the main branch of you repository with v1.0.0 or a preferred version. Proxying If you run go get Go actually fetches the module from a Proxy Server ([https://proxy.golang.org]) where it holds copies of Go modules. If module is not available Google's Proxy Server downloads and stores the module you requested. If you do not want to use Google's Proxy Server but another one use: GOPROXY=https://gocenter.io,direct go get ... If you don't want to use Proxy Server at all and want to directly download the packages from the source use: GOPROXY=direct go get ... If you want to use your own proxy server in the company: Artifactory Sonatype Athens GOPROXY Setup surch a service and point to the URL via GOPROXY env variable. Private Repositories If you have private repositories but you are using a public proxy you can supress the call to a public proxy (by hiding the domain of your company for example): GOPRIVATE=GOPRIVATE=*.corp.example.com,rsc.io/private","title":"Modules, Packages, and Imports"},{"location":"golang/golang-fundamentals/modules_packages_imports/#modules-packages-and-imports","text":"","title":"Modules, Packages, and Imports"},{"location":"golang/golang-fundamentals/modules_packages_imports/#repositories-modules-and-packages","text":"There are three main concepts in Go: repositories , modules , and packages . A repository is the location, where the source code of a project is stored. A module is the root of a Go library or application, inside a repository . Modules consist of one or more packages . Before we use third-party libraries we need to declare that our project is a module . Every module has it's own global unique identifier. It's like in Java the com.example.project.library name. In Go you usually use the location of your project, for example a Github repository. It doesn't have to be the repository location, a unique name is also fine.","title":"Repositories, Modules, and Packages"},{"location":"golang/golang-fundamentals/modules_packages_imports/#gomod","text":"Create a module by using: go mod init GLOBAL_UNIQUE_IDENTIFIER The GLOBAL_UNIQUE_IDENTIFIER is case-sensitive, therefore try to avoid uppercase letters. Let's take a look a the go.mod if running the go mod init command. module github.com/bykof/gostradamus go 1.17 require github.com/stretchr/testify v1.7.0 require ( github.com/davecgh/go-spew v1.1.0 // indirect github.com/pmezard/go-difflib v1.0.0 // indirect gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c // indirect ) Beside the require section, there can be custom repositories like: exclude and replace .","title":"go.mod"},{"location":"golang/golang-fundamentals/modules_packages_imports/#cross-compiling","text":"First we have to find available platforms, where we can compile to. ( Source ) To find all possible platforms use: go tool dist list output: aix/ppc64 android/386 android/amd64 android/arm android/arm64 darwin/amd64 darwin/arm64 dragonfly/amd64 freebsd/386 freebsd/amd64 freebsd/arm freebsd/arm64 illumos/amd64 ios/amd64 ios/arm64 js/wasm linux/386 linux/amd64 linux/arm linux/arm64 linux/mips linux/mips64 linux/mips64le linux/mipsle linux/ppc64 linux/ppc64le linux/riscv64 linux/s390x netbsd/386 netbsd/amd64 netbsd/arm netbsd/arm64 openbsd/386 openbsd/amd64 openbsd/arm openbsd/arm64 openbsd/mips64 plan9/386 plan9/amd64 plan9/arm solaris/amd64 windows/386 windows/amd64 windows/arm windows/arm64 This will print out all possible cross compilations, since Go 1.15 all possible platforms are built-in. The format of the output is: $GOOS/$GOARCH . Then you can use the following pattern for $GOOS and $GOARCH to cross compile your application: GOOS = windows GOARCH = amd64 go build -o main.exe main.go","title":"Cross Compiling"},{"location":"golang/golang-fundamentals/modules_packages_imports/#go-generate","text":"Go generate is a useful tool to run important project commands. You can run it with: go generate [ -run regexp ] [ -n ] [ -v ] [ -x ] [ build flags ] [ file.go... | packages ] Go generate will not run automatically with go build, go test and go run. It should be run manually and explicitly. The command should be placed a go file at the top of the file: For example we want to main.go 1 2 3 4 5 package main //go:generate echo \"Hello, Go Generate!\" func main () {} If you run this file with following commands: \u279c go run main.go \u279c go generate Hello, Go Generate! You will see later why it's an important tool and how it can be used with wire .","title":"Go generate"},{"location":"golang/golang-fundamentals/modules_packages_imports/#go-format","text":"Go format is very important tool, to format your code upon Go conventions ( Source ). It make following standards possible: easier to write: never worry about minor formatting concerns while hacking away, easier to read: when all code looks the same you need not mentally convert others' formatting style into something you can understand. easier to maintain: mechanical changes to the source don\u2019t cause unrelated changes to the file\u2019s formatting; diffs show only the real changes. uncontroversial: never have a debate about spacing or brace position ever again! To use it execute: go fmt path/to/your/package This will format your code automatically.","title":"Go format"},{"location":"golang/golang-fundamentals/modules_packages_imports/#imports-and-exports","text":"In Go you can import exported: constants variables functions types and you can export: constants variables functions types methods in a struct fields in a sruct Exporting things in Go is managed by the capitalization . This means, if you start the name of a function with an uppercase letter it gets exported , otherwise it's only visible inside a package. 1 2 3 4 5 6 7 func Exported () { // this function can be accessed from other packages } func packageFunc () { // this function is only available in the package }","title":"Imports and Exports"},{"location":"golang/golang-fundamentals/modules_packages_imports/#packages","text":"Creating and accessing packages very easy in Go. Actually you just create a folder with the package name . Then, every file inside the package should have a package clause. The package clause can use the package name or another custom package name . Let's look at an example: math/math.go 1 2 3 4 5 package math func Double ( a int ) in { return a * 2 } formatter/formatter.go 1 2 3 4 5 6 7 package print import \"fmt\" func Format ( num int ) string { return fmt . Sprintf ( \"The numer is %d\" , num ) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \"fmt\" \"example.com/formatter\" , \"example.com/math\" , ) func main () { num := math . Double ( 2 ) output := print . Format ( num ) fmt . Println ( output ) } The import path can be relative, but always use absolute paths with the repository name as root to the module name you want to import, separated by / . In the example we imported example.com/formatter but we defined the packagein formatter.go to be package print . This is because in Go the package declaration happens in the files itself not as directory name. BUT the package name should be the same across a dirctory. It won't work, if you mix package names in a directory.","title":"Packages"},{"location":"golang/golang-fundamentals/modules_packages_imports/#overriding-imports","text":"It can happen, that you have to import two packages with the same name. Therefore you can just overwrite the package name by using import alias . Let's check an example: 1 2 3 4 import ( cryptoRand \"crypto/rand\" \"math/rand\" )","title":"Overriding imports"},{"location":"golang/golang-fundamentals/modules_packages_imports/#documenting-with-godoc","text":"With godoc you can document your repository and it's packages. There are several rules, which you have to follow: Place the comment directly before the item being documented with no blank lines between the comment and the declaration of the item Start the comment with two forward slashes // followeg by the name of the item Use a blank comment to break your comment into multiple paragraphs Insert preformatted comment by indenting the lines Comments before the package declaration create package level comments. Generate comments by using the command: go doc .","title":"Documenting with godoc"},{"location":"golang/golang-fundamentals/modules_packages_imports/#internal-package","text":"If you want to export constants or types between your packages in your module, but you don't want to export them outside of your repository, you can use internal packages. Create a package called internal , everyting exported in the internal package will be accessable by the outer package or sibling package. Here is an example: \u251c\u2500\u2500 bar \u2502 \u2514\u2500\u2500 bar.go \u251c\u2500\u2500 foo \u2502 \u251c\u2500\u2500 foo.go \u2502 \u251c\u2500\u2500 internal \u2502 \u2502 \u2514\u2500\u2500 internal.go \u2502 \u2514\u2500\u2500 sibling \u2502 \u2514\u2500\u2500 sibling.go \u251c\u2500\u2500 go.mod \u2514\u2500\u2500 main.go Only foo and sibling can access exported types from internal . bar cannot access internal .","title":"internal package"},{"location":"golang/golang-fundamentals/modules_packages_imports/#circular-dependency","text":"Go doesn't allow you to have circular dependencies.","title":"Circular Dependency"},{"location":"golang/golang-fundamentals/modules_packages_imports/#modules","text":"Let's import now third party libraries by using the library: decimal Here is an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import ( \"fmt\" \"github.com/shopspring/decimal\" ) func main () { price , err := decimal . NewFromString ( \"136.02\" ) if err != nil { panic ( err ) } quantity := decimal . NewFromInt ( 3 ) total := price . Mul ( quantity ) fmt . Println ( \"Total:\" , total ) } If we run go build or go run main.go we get: main.go:6:2: no required module provides package github.com/shopspring/decimal; to add it: go get github.com/shopspring/decimal Here just run: go get github.com/shopspring/decimal We see that Go automatically added the required module to the go.mod it created a go.sum file It took the latest version, since you did no specified one. If the repository does not specify a version, Go will create a pseudo version, with a hash of the module: go.mod module decimal_example go 1.18 require github.com/shopspring/decimal v1.3.1 // indirect go.sum github.com/shopspring/decimal v1.3.1 h1:2Usl1nmF/WZucqkFZhnfFYxxxu8LG21F6nPQBE5gKV8= github.com/shopspring/decimal v1.3.1/go.mod h1:DKyhrW/HYNuLGql+MJL6WCR6knT2jwCFRcu2hWCYk4o=","title":"Modules"},{"location":"golang/golang-fundamentals/modules_packages_imports/#versions","text":"If you want a specific version of a module, just use go get with the @vx.x.x tag: go get github.com/shopspring/decimal@v1.1.0 This will install decimal at version v1.1.0 .","title":"Versions"},{"location":"golang/golang-fundamentals/modules_packages_imports/#upgrade","text":"If you want to upgrade a module to the latest version use: go get -u github.com/shopspring/decimal If you just want to upgrade the patch version use -u=patch . go get -u=patch github.com/shopspring/decimal","title":"Upgrade"},{"location":"golang/golang-fundamentals/modules_packages_imports/#vendoring","text":"If you want to store the module inside the project folder without depending on the internet, you can use: go mod vendor This will create a vendor folder with downloaded module inside of it. If you update the go.mod you have to rebuild the vendor folder again.","title":"Vendoring"},{"location":"golang/golang-fundamentals/modules_packages_imports/#publishing","text":"If you want to publish your module to the public, you can do it by upload it to a public repository like Github oder Gitlab. Check my own repository for example: https://github.com/bykof/gostradamus .","title":"Publishing"},{"location":"golang/golang-fundamentals/modules_packages_imports/#versioning","text":"Golang uses semantic versioning to create different versions of a module. If you release a new version of your module just tag the main branch of you repository with v1.0.0 or a preferred version.","title":"Versioning"},{"location":"golang/golang-fundamentals/modules_packages_imports/#proxying","text":"If you run go get Go actually fetches the module from a Proxy Server ([https://proxy.golang.org]) where it holds copies of Go modules. If module is not available Google's Proxy Server downloads and stores the module you requested. If you do not want to use Google's Proxy Server but another one use: GOPROXY=https://gocenter.io,direct go get ... If you don't want to use Proxy Server at all and want to directly download the packages from the source use: GOPROXY=direct go get ... If you want to use your own proxy server in the company: Artifactory Sonatype Athens GOPROXY Setup surch a service and point to the URL via GOPROXY env variable.","title":"Proxying"},{"location":"golang/golang-fundamentals/modules_packages_imports/#private-repositories","text":"If you have private repositories but you are using a public proxy you can supress the call to a public proxy (by hiding the domain of your company for example): GOPRIVATE=GOPRIVATE=*.corp.example.com,rsc.io/private","title":"Private Repositories"},{"location":"golang/golang-fundamentals/pointers/","text":"Pointers Overview Let's first check how variable are represented in the memory: 1 2 var x int32 = 10 var y bool = true Value 0 0 0 10 1 Address 1 2 3 4 5 Variable x y x is a 32bit integer, which needs 4 bytes (4*8) to store the integer in the memory. y is a boolean and needs just 1 byte to store it in the memory. For every byte in the memory there is an address, so the programm can read or write the specific values into the memory. A pointer \"points\" to a specific address of a variable. Let's check that: 1 2 3 4 5 6 7 var x int32 = 10 var y bool = true pointerX := & x pointerY := & y var pointerZ * string Value 0 0 0 10 1 0 0 0 1 0 0 0 5 0 0 0 0 Address 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Variable x y pointer X pointerY pointerZ The & is the address operator . It returns a the address of the memory location where the value is stored. The * is the indirection operator . It returns the actual value of a pointer. This is also called dereferencing. If you dereference a pointer which is nil, you will get a panic: 1 2 3 var x * int fmt . Println ( x == nil ) fmt . Println ( * x ) outputs: true panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x47dd2d] There is a builtin function new , which creates a pointer type variable. It returns a pointer to a zero value of given type. 1 2 3 4 5 6 7 8 9 var x = new ( int ) fmt . Println ( x == nil ) fmt . Println ( * x ) // is the same as var a int var b * int b = & a fmt . Println ( * b ) For structs you can use just a & while initializing one: 1 2 3 4 5 6 7 8 9 type person struct { FirstName string LastName string } person := & person { FirstName : \"Michael\" , LastName : \"Bykovski\" , } Take care, that you cannot take the address of a constant. Check here: 1 2 3 4 5 6 7 8 9 10 11 type person struct { FirstName string MiddleName * string LastName string } p := & person { FirstName : \"Michael\" , MiddleName : & \"Michau\" , LastName : \"Bykovski\" , } output: invalid operation: cannot take address of \"Michau\" (untyped string constant) You can use two solutions here. First introduce a variable of the constant and then take the address of it. Or create a function that gets a type and returns the pointer to that type. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func stringPointer ( s string ) * string { return & s } type person struct { FirstName string MiddleName * string LastName string } func main () { type person struct { FirstName string MiddleName * string LastName string } middleName := \"Michau\" p := & person { FirstName : \"Michael\" , MiddleName : & middleName , LastName : \"Bykovski\" , } p2 := & person { FirstName : \"Michael\" , MiddleName : stringPointer ( \"Michau\" ), LastName : \"Bykovski\" , } fmt . Println ( p , p2 ) } output: &{Michael 0xc000010250 Bykovski} &{Michael 0xc000010260 Bykovski} Mutable Parameters or Call by Reference Go is a call by value language, which means that if you pass a variable into a function as parameter, it will make a copy of that variable. So if you try to manipulate the passed in variable you will only do changed on a copy of the actual passed in variable. But what if you store an address of a variable and pass in the address into a function? -> Then you will be able to manipulate the actual value of the outer variable. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 type Person struct { FirstName string LastName string Age int } func noBirthday ( p Person ) { p . Age = p . Age + 1 } func birthday ( p * Person ) { p . Age = p . Age + 1 } func main () { p := Person { FirstName : \"Michael\" , LastName : \"Bykovski\" , Age : 28 , } fmt . Println ( p ) noBirthday ( p ) fmt . Println ( p ) birthday ( & p ) fmt . Println ( p ) } output: {Michael Bykovski 28} {Michael Bykovski 28} {Michael Bykovski 29} But it has some implications, which could be not self explanatory. For example, if you have a nil pointer and you want to assign a variable to this pointer. You still work on a \"copy\" of that pointer. 1 2 3 4 5 6 7 8 9 10 func failedUpdate ( g * int ) { x := 10 g = & x // g is still a copied pointer and will be vanished after function returns } func main () { var f * int failedUpdate ( f ) fmt . Println ( f ) // f is still nil } This can be fixed by derefencing the value and setting it. By dereferencing we access the actual value in the memory and overwrite it within a function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func failedUpdate ( g * int ) { x := 10 g = & x // g is still a copied pointer and will be vanished after function returns } func update ( g * int ) { * g = 10 } func main () { f := 1 failedUpdate ( & f ) fmt . Println ( f ) // f is still 1 update ( & f ) fmt . Println ( f ) // 10 } Danger Please be carefull with dereferencing, because they can panic. Therefore always check for nil pointer! 1 2 3 4 5 6 7 8 9 10 func update ( g * int ) { * g = 10 } func main () { var f * int update ( f ) fmt . Println ( f ) // error: invalid memory address or nil pointer dereference } Fixed: 1 2 3 4 5 6 7 8 9 10 11 12 func update ( g * int ) { if g != nil { * g = 10 } } func main () { var f * int update ( f ) fmt . Println ( f ) // prints nil } Passing Pointers rather than Values Surely passing pointers and modifying their values is easy. But it's actually an \"anti-pattern\" to make functions, which receive a pointer and modifying the value of your variable. Modern Software Engineering teaches us to work with immutable values rather than mutable ones Source . Therefore it's better to make functions which receive a copy of a value, mutate it and returns the mutated value: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 type Person struct { FirstName string Age int } func badBirthday ( p * Person ) { p . Age ++ } func birthday ( p Person ) Person { p . Age ++ return p } func main () { person := Person { FirstName : \"Michael\" , Age : 28 , } fmt . Println ( person ) badBirthday ( person ) fmt . Println ( person ) person = birthday ( person ) fmt . Println ( person ) } Performance If you pass a variable into a function, the whole variable gets copied to work on it. So if you pass in a variable which is around 10megabytes big, it can take up to 1 millisecond to copy the variable. Beside that it takes only about 1 nanosecond to load a pointer into a function. But returning a pointer can take more time than returning a variable. But only in one case, if you variable is smaller than 1 megabyte. For example for a 100 byte pointer it takes 30 nanoseconds and to return a value, it takes 10 nanoseconds. Once your data is bigger than 1 megabyte, this rule inverts. So for the vast majority of cases you should use call by value, only in a few cases a pointer makes sense. Zero Value vs. No Value A common usage for pointers is to set a variable either to it's zero value or to set it to nil. If you need to explicitly say, that a variable is not set, use a nil pointer. For example if you need optional parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 type Parameters struct { a int b * int } func sum ( parameters Parameters ) int { if parameters . b != nil { return parameters . a + * parameters . b } return parameters . a } func main () { b := 2 p1 := Parameters { a : 1 , b : & b , } p2 := Parameters { a : 5 , } fmt . Println ( sum ( p1 )) fmt . Println ( sum ( p2 )) } Maps and Pointers If you pass a map into a function you can manipulate the actual value of the map. This is because Go doesn't copy the value of the map but passes a reference (a pointer to struct) into the function. Therefore you should avoid using maps, unless you are working with really dynamic JSON data for example. Especially if you design your code to work in a team, it is better to define a concrete struct for your data structure than to use a dynamic map. When to use Methods over Functions Any time your logic depends on values that are configured at startup of changed while your program is running, those values should be stored in a struct and that logic should be implemented as a method. Follow this three rules and you'll be fine: when implementing methods of an interface for your struct (we will do interfaces in the next chapter) when the function needs to use a private variable within your struct when the function is completely related to the struct","title":"Pointers"},{"location":"golang/golang-fundamentals/pointers/#pointers","text":"","title":"Pointers"},{"location":"golang/golang-fundamentals/pointers/#overview","text":"Let's first check how variable are represented in the memory: 1 2 var x int32 = 10 var y bool = true Value 0 0 0 10 1 Address 1 2 3 4 5 Variable x y x is a 32bit integer, which needs 4 bytes (4*8) to store the integer in the memory. y is a boolean and needs just 1 byte to store it in the memory. For every byte in the memory there is an address, so the programm can read or write the specific values into the memory. A pointer \"points\" to a specific address of a variable. Let's check that: 1 2 3 4 5 6 7 var x int32 = 10 var y bool = true pointerX := & x pointerY := & y var pointerZ * string Value 0 0 0 10 1 0 0 0 1 0 0 0 5 0 0 0 0 Address 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Variable x y pointer X pointerY pointerZ The & is the address operator . It returns a the address of the memory location where the value is stored. The * is the indirection operator . It returns the actual value of a pointer. This is also called dereferencing. If you dereference a pointer which is nil, you will get a panic: 1 2 3 var x * int fmt . Println ( x == nil ) fmt . Println ( * x ) outputs: true panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x47dd2d] There is a builtin function new , which creates a pointer type variable. It returns a pointer to a zero value of given type. 1 2 3 4 5 6 7 8 9 var x = new ( int ) fmt . Println ( x == nil ) fmt . Println ( * x ) // is the same as var a int var b * int b = & a fmt . Println ( * b ) For structs you can use just a & while initializing one: 1 2 3 4 5 6 7 8 9 type person struct { FirstName string LastName string } person := & person { FirstName : \"Michael\" , LastName : \"Bykovski\" , } Take care, that you cannot take the address of a constant. Check here: 1 2 3 4 5 6 7 8 9 10 11 type person struct { FirstName string MiddleName * string LastName string } p := & person { FirstName : \"Michael\" , MiddleName : & \"Michau\" , LastName : \"Bykovski\" , } output: invalid operation: cannot take address of \"Michau\" (untyped string constant) You can use two solutions here. First introduce a variable of the constant and then take the address of it. Or create a function that gets a type and returns the pointer to that type. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func stringPointer ( s string ) * string { return & s } type person struct { FirstName string MiddleName * string LastName string } func main () { type person struct { FirstName string MiddleName * string LastName string } middleName := \"Michau\" p := & person { FirstName : \"Michael\" , MiddleName : & middleName , LastName : \"Bykovski\" , } p2 := & person { FirstName : \"Michael\" , MiddleName : stringPointer ( \"Michau\" ), LastName : \"Bykovski\" , } fmt . Println ( p , p2 ) } output: &{Michael 0xc000010250 Bykovski} &{Michael 0xc000010260 Bykovski}","title":"Overview"},{"location":"golang/golang-fundamentals/pointers/#mutable-parameters-or-call-by-reference","text":"Go is a call by value language, which means that if you pass a variable into a function as parameter, it will make a copy of that variable. So if you try to manipulate the passed in variable you will only do changed on a copy of the actual passed in variable. But what if you store an address of a variable and pass in the address into a function? -> Then you will be able to manipulate the actual value of the outer variable. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 type Person struct { FirstName string LastName string Age int } func noBirthday ( p Person ) { p . Age = p . Age + 1 } func birthday ( p * Person ) { p . Age = p . Age + 1 } func main () { p := Person { FirstName : \"Michael\" , LastName : \"Bykovski\" , Age : 28 , } fmt . Println ( p ) noBirthday ( p ) fmt . Println ( p ) birthday ( & p ) fmt . Println ( p ) } output: {Michael Bykovski 28} {Michael Bykovski 28} {Michael Bykovski 29} But it has some implications, which could be not self explanatory. For example, if you have a nil pointer and you want to assign a variable to this pointer. You still work on a \"copy\" of that pointer. 1 2 3 4 5 6 7 8 9 10 func failedUpdate ( g * int ) { x := 10 g = & x // g is still a copied pointer and will be vanished after function returns } func main () { var f * int failedUpdate ( f ) fmt . Println ( f ) // f is still nil } This can be fixed by derefencing the value and setting it. By dereferencing we access the actual value in the memory and overwrite it within a function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func failedUpdate ( g * int ) { x := 10 g = & x // g is still a copied pointer and will be vanished after function returns } func update ( g * int ) { * g = 10 } func main () { f := 1 failedUpdate ( & f ) fmt . Println ( f ) // f is still 1 update ( & f ) fmt . Println ( f ) // 10 } Danger Please be carefull with dereferencing, because they can panic. Therefore always check for nil pointer! 1 2 3 4 5 6 7 8 9 10 func update ( g * int ) { * g = 10 } func main () { var f * int update ( f ) fmt . Println ( f ) // error: invalid memory address or nil pointer dereference } Fixed: 1 2 3 4 5 6 7 8 9 10 11 12 func update ( g * int ) { if g != nil { * g = 10 } } func main () { var f * int update ( f ) fmt . Println ( f ) // prints nil }","title":"Mutable Parameters or Call by Reference"},{"location":"golang/golang-fundamentals/pointers/#passing-pointers-rather-than-values","text":"Surely passing pointers and modifying their values is easy. But it's actually an \"anti-pattern\" to make functions, which receive a pointer and modifying the value of your variable. Modern Software Engineering teaches us to work with immutable values rather than mutable ones Source . Therefore it's better to make functions which receive a copy of a value, mutate it and returns the mutated value: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 type Person struct { FirstName string Age int } func badBirthday ( p * Person ) { p . Age ++ } func birthday ( p Person ) Person { p . Age ++ return p } func main () { person := Person { FirstName : \"Michael\" , Age : 28 , } fmt . Println ( person ) badBirthday ( person ) fmt . Println ( person ) person = birthday ( person ) fmt . Println ( person ) }","title":"Passing Pointers rather than Values"},{"location":"golang/golang-fundamentals/pointers/#performance","text":"If you pass a variable into a function, the whole variable gets copied to work on it. So if you pass in a variable which is around 10megabytes big, it can take up to 1 millisecond to copy the variable. Beside that it takes only about 1 nanosecond to load a pointer into a function. But returning a pointer can take more time than returning a variable. But only in one case, if you variable is smaller than 1 megabyte. For example for a 100 byte pointer it takes 30 nanoseconds and to return a value, it takes 10 nanoseconds. Once your data is bigger than 1 megabyte, this rule inverts. So for the vast majority of cases you should use call by value, only in a few cases a pointer makes sense.","title":"Performance"},{"location":"golang/golang-fundamentals/pointers/#zero-value-vs-no-value","text":"A common usage for pointers is to set a variable either to it's zero value or to set it to nil. If you need to explicitly say, that a variable is not set, use a nil pointer. For example if you need optional parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 type Parameters struct { a int b * int } func sum ( parameters Parameters ) int { if parameters . b != nil { return parameters . a + * parameters . b } return parameters . a } func main () { b := 2 p1 := Parameters { a : 1 , b : & b , } p2 := Parameters { a : 5 , } fmt . Println ( sum ( p1 )) fmt . Println ( sum ( p2 )) }","title":"Zero Value vs. No Value"},{"location":"golang/golang-fundamentals/pointers/#maps-and-pointers","text":"If you pass a map into a function you can manipulate the actual value of the map. This is because Go doesn't copy the value of the map but passes a reference (a pointer to struct) into the function. Therefore you should avoid using maps, unless you are working with really dynamic JSON data for example. Especially if you design your code to work in a team, it is better to define a concrete struct for your data structure than to use a dynamic map.","title":"Maps and Pointers"},{"location":"golang/golang-fundamentals/pointers/#when-to-use-methods-over-functions","text":"Any time your logic depends on values that are configured at startup of changed while your program is running, those values should be stored in a struct and that logic should be implemented as a method. Follow this three rules and you'll be fine: when implementing methods of an interface for your struct (we will do interfaces in the next chapter) when the function needs to use a private variable within your struct when the function is completely related to the struct","title":"When to use Methods over Functions"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/","text":"Primitive Types and Declarations Zero Value If a variable is declared but not initialized with a value it gets the 'zero value'. Following zero values will be defined: Types Zero Value int 0 float 0.0 bool false string \"\" pointer nil interface nil slice nil map nil channel nil function nil Variable Declarations There are several ways to define a variable in Go. Each definition describes the way, the declared variable will be used. The default way to declare a variable is by using: 1 var x int = 10 Using the var keyword, the variable name, the type, the assignment operator, and a value. If there is a default type for the value you propose, you can use a shorter declaration: 1 var x = 10 If you don't want to initialize the variable and just declare it, you can leave the assignment operator with the value. The variable will be then initialized with the Zero Value . 1 var x int You can declare multiple variables of the same type with: 1 var x , y int = 10 Also it's possible to just declare multiple variables of the same type without initialization: 1 var x , y int or for different types, but only in this form: 1 var x , y = 10 , \"hello\" It's also possible to wrap declarations in paranthesis: 1 2 3 4 5 6 7 var ( x int y = 20 z int = 30 d , e = 40 , \"hello\" f , g string ) Short declaration format Golang supports also a short declaration format. It can be only used within function scopes, not at the package scope. Here is an example: 1 x := 10 it's the same as: 1 var x = 10 With := you can also assign values to variables as long as there is a new variable on the left hand side of := For example: 1 2 x := 10 x , y := 20 , \"Hello World\" When to use what? When you should use var or := ? There are some rules to follow, when you decide when to use what: When you initialize a variable to its zero value, use var x int . When assigning an untyped constant or a literal to a typed variable: 1 var x byte = 20 := allows you to assign to new and existing variables. Therefore it's idiomatic to declare new variables with var and mixed (new and existing) variables with := . Package Variables Avoid defining variables in the package block , because they can be manipulated by other functions, which makes it harder to track, what values they have. Use const for this problem. Const Const allows variables to be immutable. It has the same syntax as variables. Here are some examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \"fmt\" ) const x int = 10 const ( idKey = \"id\" nameKey = \"name\" ) const z = 20 * 10 func main () { const y = \"hello\" fmt . Println ( x ) fmt . Println ( y ) x = x + 1 y = \"bye\" fmt . Println ( x ) fmt . Println ( y ) } This would result in: 1 2 . / prog . go : 22 : 5 : cannot assign to x ( constant 10 of type int ) . / prog . go : 23 : 5 : cannot assign to y ( untyped string constant \"hello\" ) Definition at compile time Go initializes constants at compile time, therefore it's only possible to assign following values to them: Numeric literals Boolean literals Strings Runes built-in function like complex, real, imag, len, cap Expressions that consists of operators and the preceeding values Unused variables Go will complain if you leave variables unread. Take a look at the following example: 1 2 3 4 5 6 7 package main var x = 10 func main () { var y = 20 } This will result in the error: ./prog.go:7:9: y declared but not used Therefore you can define as many package variables as you want. Only function scope variables should be read at least once. This is an another argument to avoid package scope variables. Unused constants You can define as much constants as you want. Because constants are calculated at the compile time, they won't have any side effects. This compiles without errors: 1 2 3 4 5 6 7 package main const x = 10 func main () { const y = 20 } Primitive Types Following primitive types in Go can be used: Boolean Integer Float Complex Byte Rune String Booleans bool types represents Boolean values. It can have true or false as value. The zero value for bool is false . Numeric Types Go has 12 different numeric types that are grouped into three categories. Integer Float Complex Integer Go has signed and unsigned integers with different byte sizes. They are defined in the following table: Type Name Value Range int8 -128 to 127 int16 -32768 to 32767 int32 -2147483648 to 2147483647 int64 -9223372036854775808 to 9223372036854775807 uint8 0 to 255 uint16 0 to 65535 uint32 0 to 4294967295 uint64 0 to 18446744073709551615 Overflows Trying to set a higher value to a numeric type with it's allowed byte size 1 2 3 4 5 6 7 8 9 10 11 package main import ( \"fmt\" ) func main () { var x uint8 fmt . Println ( \"Throws integer overflow\" ) x = 267 // range of uint8 is 0-255 } will result in following compiler error: ./prog.go:10:9: cannot use 267 (untyped int constant) as uint8 value in assignment (overflows) Special integer types There is a special name called int . It has different byte allocations depending on the CPU architecture. On a 32-bit CPU, int is a 32-bit signed integer like int32 . On most 64-bit CPUs, int is a 64-bit signed integer like int64 . Because int depends on the CPU architecture, it is not allowed to perform mathematical operations or between int and int32 or int64 . See following example for this: 1 2 3 4 5 6 7 8 9 10 11 package main import \"fmt\" func main () { var x int = 2 var y int32 = 5 var z int64 = 2 fmt . Println ( x + y ) fmt . Println ( x + z ) } would result in a compile error: ./prog.go:9:14: invalid operation: x + y (mismatched types int and int32) ./prog.go:10:14: invalid operation: x + z (mismatched types int and int64) Go build failed. Floating point types There are two floating point types, displayed in the following table: Type Name Larget absolute value Smallest (nonzero) absolute value float32 3.4028e+38 1.4012e-45 float64 1.7976e+308 4.9406e-324 In most cases you shouldn't use float, because Go just stores the nearest approximation for a value. If you want to use float, you will need float64 unless you really know what you do. Complex types Go has a built-in support for complex numbers. You're probably not going to need them. Here is an example how to use complex numbers in Go: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \"math/cmplx\" \"fmt\" ) func main () { x := complex ( 2.5 , 4.1 ) y := complex ( 10.2 , 6 ) fmt . Println ( x + y ) fmt . Println ( x - y ) fmt . Println ( x * y ) fmt . Println ( x / y ) fmt . Println ( real ( x )) fmt . Println ( imag ( y )) fmt . Println ( cmplx . Abs ( x )) } Byte A byte is an alias for uint8 . You can compare, peform mathematical operations between a byte and uint8 . For example the following code works: 1 2 3 4 5 6 7 8 9 package main import \"fmt\" func main () { var x uint8 = 2 var y byte = 65 fmt . Println ( x + y ) } this would print: 67 However if you want to work with bytes just use byte and not uint8 . Rune A rune is a an alias for int32 . You can compare, perform mathematical operations between a rune and int32 . A rune can be initialized with single quotes: 1 const symbolRune = '\u2318' This rune has the integer value: 0x2318 which is the unicode character \u2318 ( See here ). String A string is a read only slice of bytes in Go. Strings can be initialized in two ways: double quote strings Double quotes format the string with escape sequences. So if your string contains a \\n it will format it to a newline. 1 2 3 const myString = \"Hello\\n World!\" fmt . Println ( myString ) output: Hello World back quote strings Back quotes ignore escape sequences in your string. Back quote strings can be also used as multiline strings 1 2 3 4 5 6 7 const myString = `Hello\\n World!` const anotherString = `-> Hello -> World ` fmt . Println ( myString ) fmt . Println ( anotherString ) output: Hello\\n World! -> Hello -> World Each character in your string represents an utf-8 encoded string character by default. In utf-8 each character occupies between 1-4 bytes. The characters a or b are encoded using 1 byte . If you use characters like \u00a3 (2 bytes) or \u2318 (3 bytes) the byte size can vary. Therefore be cautious if you convert a string into a byte array, the byte array will contain each byte of a character: 1 2 3 4 5 6 7 8 package main import \"fmt\" func main () { myString := \"\u00a3\u2318a\" fmt . Println ([] byte ( s )) } will output: |--\u00a3---| |---\u2318-----| |a| [194 163 226 140 152 97] Explicit Type Conversion If you work with different type of integers and float you cannot just add, subtract, multiply, and divide those types independently. You have to explicitly type cast an int32 to an int64 for example to add it to another int64 . That makes it clear with what types you work and if some data was truncated 1 2 3 4 5 6 7 8 9 10 package main import \"fmt\" func main () { var x float64 = 1.2 var y int = 2 z := int ( x ) + y fmt . Println ( z ) } A type conversion to boolean is not possible. If you want to type cast a variable to a bool, you have to use the zero value of the specific type. 1 2 3 4 5 6 7 8 var x int var s string = \"Test\" var xZero bool = x == 0 var sZero bool = s == \"\" fmt . Println ( x , xZero ) fmt . Println ( s , sZero )","title":"Primitive Types and Declarations"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#primitive-types-and-declarations","text":"","title":"Primitive Types and Declarations"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#zero-value","text":"If a variable is declared but not initialized with a value it gets the 'zero value'. Following zero values will be defined: Types Zero Value int 0 float 0.0 bool false string \"\" pointer nil interface nil slice nil map nil channel nil function nil","title":"Zero Value"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#variable-declarations","text":"There are several ways to define a variable in Go. Each definition describes the way, the declared variable will be used. The default way to declare a variable is by using: 1 var x int = 10 Using the var keyword, the variable name, the type, the assignment operator, and a value. If there is a default type for the value you propose, you can use a shorter declaration: 1 var x = 10 If you don't want to initialize the variable and just declare it, you can leave the assignment operator with the value. The variable will be then initialized with the Zero Value . 1 var x int You can declare multiple variables of the same type with: 1 var x , y int = 10 Also it's possible to just declare multiple variables of the same type without initialization: 1 var x , y int or for different types, but only in this form: 1 var x , y = 10 , \"hello\" It's also possible to wrap declarations in paranthesis: 1 2 3 4 5 6 7 var ( x int y = 20 z int = 30 d , e = 40 , \"hello\" f , g string )","title":"Variable Declarations"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#short-declaration-format","text":"Golang supports also a short declaration format. It can be only used within function scopes, not at the package scope. Here is an example: 1 x := 10 it's the same as: 1 var x = 10 With := you can also assign values to variables as long as there is a new variable on the left hand side of := For example: 1 2 x := 10 x , y := 20 , \"Hello World\"","title":"Short declaration format"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#when-to-use-what","text":"When you should use var or := ? There are some rules to follow, when you decide when to use what: When you initialize a variable to its zero value, use var x int . When assigning an untyped constant or a literal to a typed variable: 1 var x byte = 20 := allows you to assign to new and existing variables. Therefore it's idiomatic to declare new variables with var and mixed (new and existing) variables with := .","title":"When to use what?"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#package-variables","text":"Avoid defining variables in the package block , because they can be manipulated by other functions, which makes it harder to track, what values they have. Use const for this problem.","title":"Package Variables"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#const","text":"Const allows variables to be immutable. It has the same syntax as variables. Here are some examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \"fmt\" ) const x int = 10 const ( idKey = \"id\" nameKey = \"name\" ) const z = 20 * 10 func main () { const y = \"hello\" fmt . Println ( x ) fmt . Println ( y ) x = x + 1 y = \"bye\" fmt . Println ( x ) fmt . Println ( y ) } This would result in: 1 2 . / prog . go : 22 : 5 : cannot assign to x ( constant 10 of type int ) . / prog . go : 23 : 5 : cannot assign to y ( untyped string constant \"hello\" )","title":"Const"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#definition-at-compile-time","text":"Go initializes constants at compile time, therefore it's only possible to assign following values to them: Numeric literals Boolean literals Strings Runes built-in function like complex, real, imag, len, cap Expressions that consists of operators and the preceeding values","title":"Definition at compile time"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#unused-variables","text":"Go will complain if you leave variables unread. Take a look at the following example: 1 2 3 4 5 6 7 package main var x = 10 func main () { var y = 20 } This will result in the error: ./prog.go:7:9: y declared but not used Therefore you can define as many package variables as you want. Only function scope variables should be read at least once. This is an another argument to avoid package scope variables.","title":"Unused variables"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#unused-constants","text":"You can define as much constants as you want. Because constants are calculated at the compile time, they won't have any side effects. This compiles without errors: 1 2 3 4 5 6 7 package main const x = 10 func main () { const y = 20 }","title":"Unused constants"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#primitive-types","text":"Following primitive types in Go can be used: Boolean Integer Float Complex Byte Rune String","title":"Primitive Types"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#booleans","text":"bool types represents Boolean values. It can have true or false as value. The zero value for bool is false .","title":"Booleans"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#numeric-types","text":"Go has 12 different numeric types that are grouped into three categories. Integer Float Complex","title":"Numeric Types"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#integer","text":"Go has signed and unsigned integers with different byte sizes. They are defined in the following table: Type Name Value Range int8 -128 to 127 int16 -32768 to 32767 int32 -2147483648 to 2147483647 int64 -9223372036854775808 to 9223372036854775807 uint8 0 to 255 uint16 0 to 65535 uint32 0 to 4294967295 uint64 0 to 18446744073709551615","title":"Integer"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#overflows","text":"Trying to set a higher value to a numeric type with it's allowed byte size 1 2 3 4 5 6 7 8 9 10 11 package main import ( \"fmt\" ) func main () { var x uint8 fmt . Println ( \"Throws integer overflow\" ) x = 267 // range of uint8 is 0-255 } will result in following compiler error: ./prog.go:10:9: cannot use 267 (untyped int constant) as uint8 value in assignment (overflows)","title":"Overflows"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#special-integer-types","text":"There is a special name called int . It has different byte allocations depending on the CPU architecture. On a 32-bit CPU, int is a 32-bit signed integer like int32 . On most 64-bit CPUs, int is a 64-bit signed integer like int64 . Because int depends on the CPU architecture, it is not allowed to perform mathematical operations or between int and int32 or int64 . See following example for this: 1 2 3 4 5 6 7 8 9 10 11 package main import \"fmt\" func main () { var x int = 2 var y int32 = 5 var z int64 = 2 fmt . Println ( x + y ) fmt . Println ( x + z ) } would result in a compile error: ./prog.go:9:14: invalid operation: x + y (mismatched types int and int32) ./prog.go:10:14: invalid operation: x + z (mismatched types int and int64) Go build failed.","title":"Special integer types"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#floating-point-types","text":"There are two floating point types, displayed in the following table: Type Name Larget absolute value Smallest (nonzero) absolute value float32 3.4028e+38 1.4012e-45 float64 1.7976e+308 4.9406e-324 In most cases you shouldn't use float, because Go just stores the nearest approximation for a value. If you want to use float, you will need float64 unless you really know what you do.","title":"Floating point types"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#complex-types","text":"Go has a built-in support for complex numbers. You're probably not going to need them. Here is an example how to use complex numbers in Go: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \"math/cmplx\" \"fmt\" ) func main () { x := complex ( 2.5 , 4.1 ) y := complex ( 10.2 , 6 ) fmt . Println ( x + y ) fmt . Println ( x - y ) fmt . Println ( x * y ) fmt . Println ( x / y ) fmt . Println ( real ( x )) fmt . Println ( imag ( y )) fmt . Println ( cmplx . Abs ( x )) }","title":"Complex types"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#byte","text":"A byte is an alias for uint8 . You can compare, peform mathematical operations between a byte and uint8 . For example the following code works: 1 2 3 4 5 6 7 8 9 package main import \"fmt\" func main () { var x uint8 = 2 var y byte = 65 fmt . Println ( x + y ) } this would print: 67 However if you want to work with bytes just use byte and not uint8 .","title":"Byte"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#rune","text":"A rune is a an alias for int32 . You can compare, perform mathematical operations between a rune and int32 . A rune can be initialized with single quotes: 1 const symbolRune = '\u2318' This rune has the integer value: 0x2318 which is the unicode character \u2318 ( See here ).","title":"Rune"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#string","text":"A string is a read only slice of bytes in Go. Strings can be initialized in two ways:","title":"String"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#double-quote-strings","text":"Double quotes format the string with escape sequences. So if your string contains a \\n it will format it to a newline. 1 2 3 const myString = \"Hello\\n World!\" fmt . Println ( myString ) output: Hello World","title":"double quote strings"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#back-quote-strings","text":"Back quotes ignore escape sequences in your string. Back quote strings can be also used as multiline strings 1 2 3 4 5 6 7 const myString = `Hello\\n World!` const anotherString = `-> Hello -> World ` fmt . Println ( myString ) fmt . Println ( anotherString ) output: Hello\\n World! -> Hello -> World Each character in your string represents an utf-8 encoded string character by default. In utf-8 each character occupies between 1-4 bytes. The characters a or b are encoded using 1 byte . If you use characters like \u00a3 (2 bytes) or \u2318 (3 bytes) the byte size can vary. Therefore be cautious if you convert a string into a byte array, the byte array will contain each byte of a character: 1 2 3 4 5 6 7 8 package main import \"fmt\" func main () { myString := \"\u00a3\u2318a\" fmt . Println ([] byte ( s )) } will output: |--\u00a3---| |---\u2318-----| |a| [194 163 226 140 152 97]","title":"back quote strings"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#explicit-type-conversion","text":"If you work with different type of integers and float you cannot just add, subtract, multiply, and divide those types independently. You have to explicitly type cast an int32 to an int64 for example to add it to another int64 . That makes it clear with what types you work and if some data was truncated 1 2 3 4 5 6 7 8 9 10 package main import \"fmt\" func main () { var x float64 = 1.2 var y int = 2 z := int ( x ) + y fmt . Println ( z ) } A type conversion to boolean is not possible. If you want to type cast a variable to a bool, you have to use the zero value of the specific type. 1 2 3 4 5 6 7 8 var x int var s string = \"Test\" var xZero bool = x == 0 var sZero bool = s == \"\" fmt . Println ( x , xZero ) fmt . Println ( s , sZero )","title":"Explicit Type Conversion"},{"location":"golang/golang-fundamentals/reflect/","text":"Reflect Informative Source With reflect we get information about our variables at runtime. It's highly recommended not to use reflection, because every wrong usage can panic . Reflect should be the last possible way to do \"meta-programming\" in Go. But let's check an example anyway: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \"fmt\" \"reflect\" ) type Foo struct { A int `tag1:\"First Tag\" tag2:\"Second Tag\"` B string } func main () { sl := [] int { 1 , 2 , 3 } greeting := \"hello\" greetingPtr := & greeting f := Foo { A : 10 , B : \"Salutations\" } fp := & f fmt . Println ( reflect . TypeOf ( sl )) fmt . Println ( reflect . TypeOf ( greeting )) fmt . Println ( reflect . TypeOf ( greetingPtr )) fmt . Println ( reflect . TypeOf ( f )) fmt . Println ( reflect . TypeOf ( fp )) } output: []int string *string main.Foo *main.Foo Reflection has three rules, that you should remember, when you work with reflect : Reflection goes from interface value to reflection object Reflection goes from reflection object to interface value To modify a reflection object, the value must be settable Reflection goes from interface value to reflection object If you use reflect.TypeOf you pass in any and get a Type back. Type is an interface to get more information about the reflected type. If we want to examine the Value of a specific variable we can do that by: 1 2 3 var x float64 = 3.4 fmt . Println ( \"type:\" , reflect . TypeOf ( x )) fmt . Println ( \"value:\" , reflect . ValueOf ( x ). String ()) We can use the reflection to check, if a variable has a specific type: 1 2 3 4 5 var x float64 = 3.4 v := reflect . ValueOf ( x ) fmt . Println ( \"type:\" , reflect . TypeOf ( x )) fmt . Println ( \"value:\" , v . String ()) fmt . Println ( \"kind is float64:\" , v . Kind () == reflect . Float64 ) output would be: type: float64 value: <float64 Value> kind is float64: true If you have a user-defined type, Type can give you the user-defined type, but Kind will always give you the built-in type. 1 2 3 4 5 type MyInt int var x MyInt = 7 v := reflect . ValueOf ( x ) fmt . Println ( v . Kind (). String ()) fmt . Println ( v . Type ()) Reflection goes from reflection object to interface value If we have a reflected reflect.Value , we can derive back the inverse of it. We call the Interface method on a Value to get it's interface again and then we can Type Assert it back to it's natural Go type. Let's take an example: 1 2 3 4 y := 2.9 v := reflect . ValueOf ( y ) x := v . Interface ().( float64 ) fmt . Printf ( \"x, type: %T, value: %v\\n\" , x , x ) output: x, type: float64, value: 2.9 To modify a reflection object, the value must be settable To set a value via reflection, the value must be settable. 1 2 3 var x float64 = 3.4 v := reflect . ValueOf ( x ) v . SetFloat ( 7.1 ) // Error: will panic. output: panic: reflect: reflect.Value.SetFloat using unaddressable value Go is call-by-value, therefore it's a copy of the variable x what reflect.ValueOf is using. When we want to set the value of x , we have to pass a \"Setable\" type: a pointer. 1 2 3 4 var x float64 = 3.4 v := reflect . ValueOf ( & x ) v . SetFloat ( 7.1 ) fmt . Println ( x ) If we now to set the value, the output would be: panic: reflect: reflect.Value.SetFloat using unaddressable value Why? Because we just try to set 7.1 to the pointer itself and not to the actual value in RAM. To get the actual Value of a pointer in the RAM we have to call [ Elem ]. Elem returns the value that the interface v contains or that the pointer v points to. It panics if v's Kind is not Interface or Pointer. It returns the zero Value if v is nil. Example: 1 2 3 4 var x float64 = 3.4 v := reflect . ValueOf ( & x ) v . Elem (). SetFloat ( 7.1 ) fmt . Println ( x ) now the output is correct: 7.1","title":"Reflect"},{"location":"golang/golang-fundamentals/reflect/#reflect","text":"Informative Source With reflect we get information about our variables at runtime. It's highly recommended not to use reflection, because every wrong usage can panic . Reflect should be the last possible way to do \"meta-programming\" in Go. But let's check an example anyway: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \"fmt\" \"reflect\" ) type Foo struct { A int `tag1:\"First Tag\" tag2:\"Second Tag\"` B string } func main () { sl := [] int { 1 , 2 , 3 } greeting := \"hello\" greetingPtr := & greeting f := Foo { A : 10 , B : \"Salutations\" } fp := & f fmt . Println ( reflect . TypeOf ( sl )) fmt . Println ( reflect . TypeOf ( greeting )) fmt . Println ( reflect . TypeOf ( greetingPtr )) fmt . Println ( reflect . TypeOf ( f )) fmt . Println ( reflect . TypeOf ( fp )) } output: []int string *string main.Foo *main.Foo Reflection has three rules, that you should remember, when you work with reflect : Reflection goes from interface value to reflection object Reflection goes from reflection object to interface value To modify a reflection object, the value must be settable","title":"Reflect"},{"location":"golang/golang-fundamentals/reflect/#reflection-goes-from-interface-value-to-reflection-object","text":"If you use reflect.TypeOf you pass in any and get a Type back. Type is an interface to get more information about the reflected type. If we want to examine the Value of a specific variable we can do that by: 1 2 3 var x float64 = 3.4 fmt . Println ( \"type:\" , reflect . TypeOf ( x )) fmt . Println ( \"value:\" , reflect . ValueOf ( x ). String ()) We can use the reflection to check, if a variable has a specific type: 1 2 3 4 5 var x float64 = 3.4 v := reflect . ValueOf ( x ) fmt . Println ( \"type:\" , reflect . TypeOf ( x )) fmt . Println ( \"value:\" , v . String ()) fmt . Println ( \"kind is float64:\" , v . Kind () == reflect . Float64 ) output would be: type: float64 value: <float64 Value> kind is float64: true If you have a user-defined type, Type can give you the user-defined type, but Kind will always give you the built-in type. 1 2 3 4 5 type MyInt int var x MyInt = 7 v := reflect . ValueOf ( x ) fmt . Println ( v . Kind (). String ()) fmt . Println ( v . Type ())","title":"Reflection goes from interface value to reflection object"},{"location":"golang/golang-fundamentals/reflect/#reflection-goes-from-reflection-object-to-interface-value","text":"If we have a reflected reflect.Value , we can derive back the inverse of it. We call the Interface method on a Value to get it's interface again and then we can Type Assert it back to it's natural Go type. Let's take an example: 1 2 3 4 y := 2.9 v := reflect . ValueOf ( y ) x := v . Interface ().( float64 ) fmt . Printf ( \"x, type: %T, value: %v\\n\" , x , x ) output: x, type: float64, value: 2.9","title":"Reflection goes from reflection object to interface value"},{"location":"golang/golang-fundamentals/reflect/#to-modify-a-reflection-object-the-value-must-be-settable","text":"To set a value via reflection, the value must be settable. 1 2 3 var x float64 = 3.4 v := reflect . ValueOf ( x ) v . SetFloat ( 7.1 ) // Error: will panic. output: panic: reflect: reflect.Value.SetFloat using unaddressable value Go is call-by-value, therefore it's a copy of the variable x what reflect.ValueOf is using. When we want to set the value of x , we have to pass a \"Setable\" type: a pointer. 1 2 3 4 var x float64 = 3.4 v := reflect . ValueOf ( & x ) v . SetFloat ( 7.1 ) fmt . Println ( x ) If we now to set the value, the output would be: panic: reflect: reflect.Value.SetFloat using unaddressable value Why? Because we just try to set 7.1 to the pointer itself and not to the actual value in RAM. To get the actual Value of a pointer in the RAM we have to call [ Elem ]. Elem returns the value that the interface v contains or that the pointer v points to. It panics if v's Kind is not Interface or Pointer. It returns the zero Value if v is nil. Example: 1 2 3 4 var x float64 = 3.4 v := reflect . ValueOf ( & x ) v . Elem (). SetFloat ( 7.1 ) fmt . Println ( x ) now the output is correct: 7.1","title":"To modify a reflection object, the value must be settable"},{"location":"golang/golang-fundamentals/standard_library/","text":"The standard library There are a lot of \"batteries included\" in Go. The standard library is really huge, let's check some of those packages to see, how they were implemented. io Input and Output Data into files is probably one of the main things, what a programm should can. The package io provide this functionality and two most used interfaces from this package are: 1 2 3 4 5 6 7 type Reader interface { Read ( p [] byte ) ( n int , err error ) } type Writer interface { Write ( p [] byte ) ( n int , err error ) } Reader and Writer are very simple and practical interfaces. They allow to read or write len(p) byte to a specific destination. This allows also to read buffered data, lets check an example here: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func countLetters ( r io . Reader ) ( map [ string ] int , error ) { buf := make ([] byte , 2048 ) out := map [ string ] int {} for { n , err := r . Read ( buf ) for _ , r range bug [: n ] { if ( r >= 'A' && r <= 'Z' ) || ( r >= 'a' && r <= 'z' ) { out [ string ( r )] ++ } } if err == io . EOF { return out , nil } if err != nil { return nil , nil } } } Let's see, how we can read a simple file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import ( \"fmt\" \"io\" \"log\" \"os\" ) func main () { f , err := os . OpenFile ( \"notes.txt\" , os . O_RDWR | os . O_CREATE , 0755 ) if err != nil { log . Fatal ( err ) } defer func () { if err := f . Close (); err != nil { log . Fatal ( err ) } }() data , err := io . ReadAll ( f ) if err != nil { log . Fatal ( err ) } fmt . Println ( string ( data )) } The ioutil.ReadAll reads a Reader interface until an error or io.EOF is read. time The time package is for working with dates, times and datetimes. The package contains two main types: time.Duration and time.Time . A period of time is represented as an int64 . The smallest amount of time is one nanosecond. But there are some constants, which can be used to calculate a minute, two seconds and so on: 1 2 3 h := 2 * time . Hour // 2 hours m := 3 * time . Minute // 3 minutes hm := h + m // 2 hours and 3 minutes time.ParseDuration can parse strings like 300ms or 2.3h : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import ( \"fmt\" \"time\" ) func main () { hours , _ := time . ParseDuration ( \"10h\" ) complex , _ := time . ParseDuration ( \"1h10m10s\" ) micro , _ := time . ParseDuration ( \"1\u00b5s\" ) // The package also accepts the incorrect but common prefix u for micro. micro2 , _ := time . ParseDuration ( \"1us\" ) fmt . Println ( hours ) fmt . Println ( complex ) fmt . Printf ( \"There are %.0f seconds in %v.\\n\" , complex . Seconds (), complex ) fmt . Printf ( \"There are %d nanoseconds in %v.\\n\" , micro . Nanoseconds (), micro ) fmt . Printf ( \"There are %6.2e seconds in %v.\\n\" , micro2 . Seconds (), micro ) } Now we come to a really unusual thing... parsing and formatting datetimes. Go follows the idea to use a format depending on the position in the string: 01/02 03:04:05PM 06 -0700 . So for example: 1 2 3 4 5 6 7 func main () { t , err := time . Parse ( \"2006-01-02 15:04:05 -0700\" , \"2016-01-13 00:12:43 +0000\" ) if err != nil { fmt . Println ( err ) } fmt . Println ( t . Format ( \"January 2, 2006 at 03:04:05PM MST\" )) } output would be: January 13, 2016 at 12:12:43AM UTC There are a lot of more functions to manipulate time.Time . Jus see some of the documentation gostradamus If you want to work with datetimes and to have a in-replacement for time you can use my Go package: gostradamus . It's a more \"convenient\" way to work with time.Time variables: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import ( \"fmt\" \"github.com/bykof/gostradamus\" ) func main () { dateTime , err := gostradamus . Parse ( \"14.07.2017 02:40:00\" , \"DD.MM.YYYY HH:mm:ss\" ) if err != nil { panic ( err ) } // Easy manipulation dateTime = dateTime . ShiftMonths ( - 5 ). ShiftDays ( 2 ) // Easy formatting fmt . Println ( dateTime . Format ( \"DD.MM.YYYY HH:mm:ss\" )) // 16.02.2017 02:40:00 // Easy helper functions start , end := dateTime . SpanWeek () fmt . Println ( start . String (), end . String ()) } output: 16.02.2017 02:40:00 2017-02-13T00:00:00.000000Z 2017-02-19T23:59:59.999999Z encoding/json Go has a builtin json parser. It uses the word Marshal ( Parse ) and Unmarshal ( Format ) for this library. Also Go uses structs or types to represent JSON object, arrays and so on. You can \"map\" json object fields onto your struct, even when the field names are different. Let's check an example: 1 2 3 4 5 6 7 8 9 10 { \"id\" : 123 , \"first_name\" : \"Test\" , \"last_name\" : \"Tester\" , \"birthday\" : \"1994-01-19T00:00:00Z\" , \"skills\" : [ { \"id\" : 1 , \"name\" : \"Running\" }, { \"id\" : 1 , \"name\" : \"Jumping\" } ] } now we define a struct to map the data: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import ( \"encoding/json\" \"fmt\" \"time\" ) type Skill struct { ID int `json:\"id\"` Name string `json:\"name\"` } type Skills [] Skill type Person struct { ID int `json:\"id\"` FirstName string `json:\"first_name\"` LastName string `json:\"last_name\"` Birthday time . Time `json:\"birthday\"` Skills Skills `json:\"skills\"` } func main () { s := ` { \"id\": 123, \"first_name\": \"Test\", \"last_name\": \"Tester\", \"birthday\": \"1994-01-19T00:00:00Z\", \"skills\": [ {\"id\": 1, \"name\": \"Running\"}, {\"id\": 1, \"name\": \"Jumping\"} ] }` var person Person err := json . Unmarshal ([] byte ( s ), & person ) if err != nil { panic ( err ) } fmt . Printf ( \"%#v\" , person ) } output: main.Person{ID:123, FirstName:\"Test\", LastName:\"Tester\", Birthday:time.Date(1994, time.January, 19, 0, 0, 0, 0, time.UTC), Skills:main.Skills{main.Skill{ID:1, Name:\"Running\"}, main.Skill{ID:1, Name:\"Jumping\"}}} net/http The net/http library has a client and a server . So you can send and receive http requests. client You can create a http.Client instance with a default timeout: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import ( \"context\" \"encoding/json\" \"fmt\" \"net/http\" \"time\" ) func main () { client := & http . Client { Timeout : 30 * time . Second , } request , err := http . NewRequestWithContext ( context . Background (), http . MethodGet , \"https://jsonplaceholder.typicode.com/todos/1\" , nil , ) if err != nil { panic ( err ) } response , err := client . Do ( request ) if err != nil { panic ( err ) } defer response . Body . Close () if response . StatusCode != http . StatusOK { panic ( fmt . Sprintf ( \"got unexpected status: %v\" , response . StatusCode )) } var data struct { ID int `json:\"id\"` UserID int `json:\"userId\"` Title string `json:\"title\"` Completed bool `json:\"completed\"` } err = json . NewDecoder ( response . Body ). Decode ( & data ) if err != nil { panic ( err ) } fmt . Printf ( \"%+v\" , data ) } output would be: {ID:1 UserID:1 Title:delectus aut autem Completed:false}% server The server http.ServeMux handles multiple paths. You can combine multiple ServeMux Handlers, but be aware, that you have to strip the path before the request will be given to any underlying handler. Every incoming request will be handled by it's own goroutine. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import ( \"fmt\" \"net/http\" \"time\" ) func main () { apiMux := http . NewServeMux () apiMux . HandleFunc ( \"/todo/\" , func ( w http . ResponseWriter , req * http . Request ) { w . Write ([] byte ( \"todo\" )) }) apiMux . HandleFunc ( \"/\" , func ( w http . ResponseWriter , req * http . Request ) { w . Write ([] byte ( \"api\" )) }) mux := http . NewServeMux () mux . Handle ( \"/api/\" , http . StripPrefix ( \"/api\" , apiMux )) mux . HandleFunc ( \"/\" , func ( w http . ResponseWriter , req * http . Request ) { // The \"/\" pattern matches everything, so we need to check // that we're at the root here. if req . URL . Path != \"/\" { http . NotFound ( w , req ) return } fmt . Fprintf ( w , \"Welcome to the home page!\" ) }) server := http . Server { Addr : \":8000\" , ReadTimeout : 30 * time . Second , WriteTimeout : 60 * time . Second , IdleTimeout : 120 * time . Second , Handler : mux , } err := server . ListenAndServe () if err != nil && err != http . ErrServerClosed { panic ( err ) } } Sometimes you need a middleware to check if the user is allowed to access an endpoint: main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 const Password = \"notsecurepassword\" func securityMiddleware ( h http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , req * http . Request ) { if req . Header . Get ( \"Authorization\" ) != Password { w . WriteHeader ( http . StatusUnauthorized ) w . Write ([] byte ( \"no access\" )) return } h . ServeHTTP ( w , req ) }) } func requestTimer ( h http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , req * http . Request ) { start := time . Now () h . ServeHTTP ( w , req ) end := time . Now () log . Printf ( \"request took: %s\" , end . Sub ( start )) }) } // ... mux . Handle ( \"/\" , requestTimer ( securityMiddleware ( http . HandlerFunc ( func ( w http . ResponseWriter , req * http . Request ) { // The \"/\" pattern matches everything, so we need to check // that we're at the root here. if req . URL . Path != \"/\" { http . NotFound ( w , req ) return } fmt . Fprintf ( w , \"Welcome to the home page!\" ) }, ), ), ), )","title":"The standard library"},{"location":"golang/golang-fundamentals/standard_library/#the-standard-library","text":"There are a lot of \"batteries included\" in Go. The standard library is really huge, let's check some of those packages to see, how they were implemented.","title":"The standard library"},{"location":"golang/golang-fundamentals/standard_library/#io","text":"Input and Output Data into files is probably one of the main things, what a programm should can. The package io provide this functionality and two most used interfaces from this package are: 1 2 3 4 5 6 7 type Reader interface { Read ( p [] byte ) ( n int , err error ) } type Writer interface { Write ( p [] byte ) ( n int , err error ) } Reader and Writer are very simple and practical interfaces. They allow to read or write len(p) byte to a specific destination. This allows also to read buffered data, lets check an example here: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func countLetters ( r io . Reader ) ( map [ string ] int , error ) { buf := make ([] byte , 2048 ) out := map [ string ] int {} for { n , err := r . Read ( buf ) for _ , r range bug [: n ] { if ( r >= 'A' && r <= 'Z' ) || ( r >= 'a' && r <= 'z' ) { out [ string ( r )] ++ } } if err == io . EOF { return out , nil } if err != nil { return nil , nil } } } Let's see, how we can read a simple file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import ( \"fmt\" \"io\" \"log\" \"os\" ) func main () { f , err := os . OpenFile ( \"notes.txt\" , os . O_RDWR | os . O_CREATE , 0755 ) if err != nil { log . Fatal ( err ) } defer func () { if err := f . Close (); err != nil { log . Fatal ( err ) } }() data , err := io . ReadAll ( f ) if err != nil { log . Fatal ( err ) } fmt . Println ( string ( data )) } The ioutil.ReadAll reads a Reader interface until an error or io.EOF is read.","title":"io"},{"location":"golang/golang-fundamentals/standard_library/#time","text":"The time package is for working with dates, times and datetimes. The package contains two main types: time.Duration and time.Time . A period of time is represented as an int64 . The smallest amount of time is one nanosecond. But there are some constants, which can be used to calculate a minute, two seconds and so on: 1 2 3 h := 2 * time . Hour // 2 hours m := 3 * time . Minute // 3 minutes hm := h + m // 2 hours and 3 minutes time.ParseDuration can parse strings like 300ms or 2.3h : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import ( \"fmt\" \"time\" ) func main () { hours , _ := time . ParseDuration ( \"10h\" ) complex , _ := time . ParseDuration ( \"1h10m10s\" ) micro , _ := time . ParseDuration ( \"1\u00b5s\" ) // The package also accepts the incorrect but common prefix u for micro. micro2 , _ := time . ParseDuration ( \"1us\" ) fmt . Println ( hours ) fmt . Println ( complex ) fmt . Printf ( \"There are %.0f seconds in %v.\\n\" , complex . Seconds (), complex ) fmt . Printf ( \"There are %d nanoseconds in %v.\\n\" , micro . Nanoseconds (), micro ) fmt . Printf ( \"There are %6.2e seconds in %v.\\n\" , micro2 . Seconds (), micro ) } Now we come to a really unusual thing... parsing and formatting datetimes. Go follows the idea to use a format depending on the position in the string: 01/02 03:04:05PM 06 -0700 . So for example: 1 2 3 4 5 6 7 func main () { t , err := time . Parse ( \"2006-01-02 15:04:05 -0700\" , \"2016-01-13 00:12:43 +0000\" ) if err != nil { fmt . Println ( err ) } fmt . Println ( t . Format ( \"January 2, 2006 at 03:04:05PM MST\" )) } output would be: January 13, 2016 at 12:12:43AM UTC There are a lot of more functions to manipulate time.Time . Jus see some of the documentation","title":"time"},{"location":"golang/golang-fundamentals/standard_library/#gostradamus","text":"If you want to work with datetimes and to have a in-replacement for time you can use my Go package: gostradamus . It's a more \"convenient\" way to work with time.Time variables: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import ( \"fmt\" \"github.com/bykof/gostradamus\" ) func main () { dateTime , err := gostradamus . Parse ( \"14.07.2017 02:40:00\" , \"DD.MM.YYYY HH:mm:ss\" ) if err != nil { panic ( err ) } // Easy manipulation dateTime = dateTime . ShiftMonths ( - 5 ). ShiftDays ( 2 ) // Easy formatting fmt . Println ( dateTime . Format ( \"DD.MM.YYYY HH:mm:ss\" )) // 16.02.2017 02:40:00 // Easy helper functions start , end := dateTime . SpanWeek () fmt . Println ( start . String (), end . String ()) } output: 16.02.2017 02:40:00 2017-02-13T00:00:00.000000Z 2017-02-19T23:59:59.999999Z","title":"gostradamus"},{"location":"golang/golang-fundamentals/standard_library/#encodingjson","text":"Go has a builtin json parser. It uses the word Marshal ( Parse ) and Unmarshal ( Format ) for this library. Also Go uses structs or types to represent JSON object, arrays and so on. You can \"map\" json object fields onto your struct, even when the field names are different. Let's check an example: 1 2 3 4 5 6 7 8 9 10 { \"id\" : 123 , \"first_name\" : \"Test\" , \"last_name\" : \"Tester\" , \"birthday\" : \"1994-01-19T00:00:00Z\" , \"skills\" : [ { \"id\" : 1 , \"name\" : \"Running\" }, { \"id\" : 1 , \"name\" : \"Jumping\" } ] } now we define a struct to map the data: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import ( \"encoding/json\" \"fmt\" \"time\" ) type Skill struct { ID int `json:\"id\"` Name string `json:\"name\"` } type Skills [] Skill type Person struct { ID int `json:\"id\"` FirstName string `json:\"first_name\"` LastName string `json:\"last_name\"` Birthday time . Time `json:\"birthday\"` Skills Skills `json:\"skills\"` } func main () { s := ` { \"id\": 123, \"first_name\": \"Test\", \"last_name\": \"Tester\", \"birthday\": \"1994-01-19T00:00:00Z\", \"skills\": [ {\"id\": 1, \"name\": \"Running\"}, {\"id\": 1, \"name\": \"Jumping\"} ] }` var person Person err := json . Unmarshal ([] byte ( s ), & person ) if err != nil { panic ( err ) } fmt . Printf ( \"%#v\" , person ) } output: main.Person{ID:123, FirstName:\"Test\", LastName:\"Tester\", Birthday:time.Date(1994, time.January, 19, 0, 0, 0, 0, time.UTC), Skills:main.Skills{main.Skill{ID:1, Name:\"Running\"}, main.Skill{ID:1, Name:\"Jumping\"}}}","title":"encoding/json"},{"location":"golang/golang-fundamentals/standard_library/#nethttp","text":"The net/http library has a client and a server . So you can send and receive http requests.","title":"net/http"},{"location":"golang/golang-fundamentals/standard_library/#client","text":"You can create a http.Client instance with a default timeout: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import ( \"context\" \"encoding/json\" \"fmt\" \"net/http\" \"time\" ) func main () { client := & http . Client { Timeout : 30 * time . Second , } request , err := http . NewRequestWithContext ( context . Background (), http . MethodGet , \"https://jsonplaceholder.typicode.com/todos/1\" , nil , ) if err != nil { panic ( err ) } response , err := client . Do ( request ) if err != nil { panic ( err ) } defer response . Body . Close () if response . StatusCode != http . StatusOK { panic ( fmt . Sprintf ( \"got unexpected status: %v\" , response . StatusCode )) } var data struct { ID int `json:\"id\"` UserID int `json:\"userId\"` Title string `json:\"title\"` Completed bool `json:\"completed\"` } err = json . NewDecoder ( response . Body ). Decode ( & data ) if err != nil { panic ( err ) } fmt . Printf ( \"%+v\" , data ) } output would be: {ID:1 UserID:1 Title:delectus aut autem Completed:false}%","title":"client"},{"location":"golang/golang-fundamentals/standard_library/#server","text":"The server http.ServeMux handles multiple paths. You can combine multiple ServeMux Handlers, but be aware, that you have to strip the path before the request will be given to any underlying handler. Every incoming request will be handled by it's own goroutine. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import ( \"fmt\" \"net/http\" \"time\" ) func main () { apiMux := http . NewServeMux () apiMux . HandleFunc ( \"/todo/\" , func ( w http . ResponseWriter , req * http . Request ) { w . Write ([] byte ( \"todo\" )) }) apiMux . HandleFunc ( \"/\" , func ( w http . ResponseWriter , req * http . Request ) { w . Write ([] byte ( \"api\" )) }) mux := http . NewServeMux () mux . Handle ( \"/api/\" , http . StripPrefix ( \"/api\" , apiMux )) mux . HandleFunc ( \"/\" , func ( w http . ResponseWriter , req * http . Request ) { // The \"/\" pattern matches everything, so we need to check // that we're at the root here. if req . URL . Path != \"/\" { http . NotFound ( w , req ) return } fmt . Fprintf ( w , \"Welcome to the home page!\" ) }) server := http . Server { Addr : \":8000\" , ReadTimeout : 30 * time . Second , WriteTimeout : 60 * time . Second , IdleTimeout : 120 * time . Second , Handler : mux , } err := server . ListenAndServe () if err != nil && err != http . ErrServerClosed { panic ( err ) } } Sometimes you need a middleware to check if the user is allowed to access an endpoint: main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 const Password = \"notsecurepassword\" func securityMiddleware ( h http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , req * http . Request ) { if req . Header . Get ( \"Authorization\" ) != Password { w . WriteHeader ( http . StatusUnauthorized ) w . Write ([] byte ( \"no access\" )) return } h . ServeHTTP ( w , req ) }) } func requestTimer ( h http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , req * http . Request ) { start := time . Now () h . ServeHTTP ( w , req ) end := time . Now () log . Printf ( \"request took: %s\" , end . Sub ( start )) }) } // ... mux . Handle ( \"/\" , requestTimer ( securityMiddleware ( http . HandlerFunc ( func ( w http . ResponseWriter , req * http . Request ) { // The \"/\" pattern matches everything, so we need to check // that we're at the root here. if req . URL . Path != \"/\" { http . NotFound ( w , req ) return } fmt . Fprintf ( w , \"Welcome to the home page!\" ) }, ), ), ), )","title":"server"},{"location":"golang/golang-fundamentals/tags/","text":"Tags Some libraries like encoding/json use tags for more information in a struct. Tags can be fetched by using reflect. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type Person struct { FirstName string `json:\"first_name,omitempty\" other:\"hello\"` } func main () { person := Person { FirstName : \"Michael\" , } personType := reflect . TypeOf ( person ) if firstNameField , ok := personType . FieldByName ( \"FirstName\" ); ok { fmt . Println ( firstNameField . Tag . Get ( \"json\" )) fmt . Println ( firstNameField . Tag . Get ( \"other\" )) } } output: first_name,omitempty hello JSON Tags If you use, for example encoding/json , you influence how your fields get Marshaled or Unmarshaled Source . We can set the key name of the json object, by using tags. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type Person struct { FirstName string `json:\"first_name,omitempty\"` } func main () { person := Person { FirstName : \"Michael\" , } data , err := json . Marshal ( person ) if err != nil { fmt . Println ( err ) } fmt . Println ( string ( data )) } output: {\"first_name\":\"Michael\"} If we use omitempty on a field and the field value is set to a zero value, then the field will be truncated: 1 2 3 4 5 6 7 8 person := Person {} data , err := json . Marshal ( person ) if err != nil { fmt . Println ( err ) } fmt . Println ( string ( data )) output: {} If we do not use omitempty the field will be included always: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type Person struct { FirstName string `json:\"first_name\"` } func main () { person := Person {} data , err := json . Marshal ( person ) if err != nil { fmt . Println ( err ) } fmt . Println ( string ( data )) } output: {\"first_name\":\"\"}","title":"Tags"},{"location":"golang/golang-fundamentals/tags/#tags","text":"Some libraries like encoding/json use tags for more information in a struct. Tags can be fetched by using reflect. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type Person struct { FirstName string `json:\"first_name,omitempty\" other:\"hello\"` } func main () { person := Person { FirstName : \"Michael\" , } personType := reflect . TypeOf ( person ) if firstNameField , ok := personType . FieldByName ( \"FirstName\" ); ok { fmt . Println ( firstNameField . Tag . Get ( \"json\" )) fmt . Println ( firstNameField . Tag . Get ( \"other\" )) } } output: first_name,omitempty hello","title":"Tags"},{"location":"golang/golang-fundamentals/tags/#json-tags","text":"If you use, for example encoding/json , you influence how your fields get Marshaled or Unmarshaled Source . We can set the key name of the json object, by using tags. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type Person struct { FirstName string `json:\"first_name,omitempty\"` } func main () { person := Person { FirstName : \"Michael\" , } data , err := json . Marshal ( person ) if err != nil { fmt . Println ( err ) } fmt . Println ( string ( data )) } output: {\"first_name\":\"Michael\"} If we use omitempty on a field and the field value is set to a zero value, then the field will be truncated: 1 2 3 4 5 6 7 8 person := Person {} data , err := json . Marshal ( person ) if err != nil { fmt . Println ( err ) } fmt . Println ( string ( data )) output: {} If we do not use omitempty the field will be included always: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type Person struct { FirstName string `json:\"first_name\"` } func main () { person := Person {} data , err := json . Marshal ( person ) if err != nil { fmt . Println ( err ) } fmt . Println ( string ( data )) } output: {\"first_name\":\"\"}","title":"JSON Tags"},{"location":"golang/golang-fundamentals/tests/","text":"Tests Tests are important. Tests check, if you application works as expected. Tests in Go are so easy, it's easier to write tests than not to do it. Normally you will not see any logs from tests, unles you set the -v (verbose) flag. Tests are executed automatically when you name your files *_test.go . Let's dive in with an easy example: calculator.go 1 2 3 func add ( a , b int ) int { return a + b } calculator_test.go 1 2 3 4 5 6 7 func Test_add ( t * testing . T ) { result := add ( 1 , 2 ) expected := 2 if result != expected { t . Error ( \"not correct, expected\" , expected , \" got\" , result ) } } If you run go test ./... the output is: ? example [no test files] --- FAIL: Test_add (0.00s) calculator_test.go:9: not correct, expected 2 got 3 FAIL FAIL example/calculator 0.153s FAIL Let's fix the test: calculator_test.go 1 2 3 4 5 6 7 func Test_add ( t * testing . T ) { result := add ( 1 , 2 ) expected := 3 if result != expected { t . Error ( \"not correct, expected\" , expected , \" got\" , result ) } } Now the tests are running properly: ? example [no test files] ok example/calculator 0.154s Setup and Teardown To setup a test use a function called TestMain . To teardown a tests files and data use t.Cleanup(func() { ... }) . calculator_test.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func TestMain ( m * testing . M ) { fmt . Println ( \"Setting up...\" ) fmt . Println ( \"Running tests...\" ) exitValue := m . Run () fmt . Println ( \"Clean up all tests...\" ) os . Exit ( exitValue ) } func Test_add ( t * testing . T ) { result := add ( 1 , 2 ) expected := 3 if result != expected { t . Error ( \"not correct, expected\" , expected , \" got\" , result ) } t . Cleanup ( func () { fmt . Println ( \"Teardown test\" ) }) } By running the tests with: go test ./... -v the output is: ? reader_writer [no test files] Setting up... Running tests... === RUN Test_add Teardown add test --- PASS: Test_add (0.00s) PASS Clean up all tests... ok reader_writer/calculator 0.152s Public API Testing If you want to test your public exposed functions or methods you can create a \"*_test\" package. This will, by definition, create a new package, which can only access exported functions and methods. Let's check that: calculator/calculator.go 1 2 3 func Add ( a int , b int ) int { return a + b } calculator/calculator_test/calculator_test.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package calculator import ( \"testing\" \"example/calculator\" ) func Test_Add ( t * testing . T ) { result := calculator . Add ( 1 , 2 ) expected := 3 if result != expected { t . Error ( \"not correct, expected\" , expected , \" got\" , result ) } } Testify In a lot of projects you will see the package github.com/stretchr/testify/assert . This is because it brings a more \"convenient\" way of testing with assertions, mocking, and suite. Let's check some examples: main.go 1 2 3 4 5 6 7 8 import ( \"testing\" \"github.com/stretchr/testify/assert\" ) func Test_Add ( t * testing . T ) { assert . Equal ( t , 3 , calculator . Add ( 1 , 2 )) }","title":"Tests"},{"location":"golang/golang-fundamentals/tests/#tests","text":"Tests are important. Tests check, if you application works as expected. Tests in Go are so easy, it's easier to write tests than not to do it. Normally you will not see any logs from tests, unles you set the -v (verbose) flag. Tests are executed automatically when you name your files *_test.go . Let's dive in with an easy example: calculator.go 1 2 3 func add ( a , b int ) int { return a + b } calculator_test.go 1 2 3 4 5 6 7 func Test_add ( t * testing . T ) { result := add ( 1 , 2 ) expected := 2 if result != expected { t . Error ( \"not correct, expected\" , expected , \" got\" , result ) } } If you run go test ./... the output is: ? example [no test files] --- FAIL: Test_add (0.00s) calculator_test.go:9: not correct, expected 2 got 3 FAIL FAIL example/calculator 0.153s FAIL Let's fix the test: calculator_test.go 1 2 3 4 5 6 7 func Test_add ( t * testing . T ) { result := add ( 1 , 2 ) expected := 3 if result != expected { t . Error ( \"not correct, expected\" , expected , \" got\" , result ) } } Now the tests are running properly: ? example [no test files] ok example/calculator 0.154s","title":"Tests"},{"location":"golang/golang-fundamentals/tests/#setup-and-teardown","text":"To setup a test use a function called TestMain . To teardown a tests files and data use t.Cleanup(func() { ... }) . calculator_test.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func TestMain ( m * testing . M ) { fmt . Println ( \"Setting up...\" ) fmt . Println ( \"Running tests...\" ) exitValue := m . Run () fmt . Println ( \"Clean up all tests...\" ) os . Exit ( exitValue ) } func Test_add ( t * testing . T ) { result := add ( 1 , 2 ) expected := 3 if result != expected { t . Error ( \"not correct, expected\" , expected , \" got\" , result ) } t . Cleanup ( func () { fmt . Println ( \"Teardown test\" ) }) } By running the tests with: go test ./... -v the output is: ? reader_writer [no test files] Setting up... Running tests... === RUN Test_add Teardown add test --- PASS: Test_add (0.00s) PASS Clean up all tests... ok reader_writer/calculator 0.152s","title":"Setup and Teardown"},{"location":"golang/golang-fundamentals/tests/#public-api-testing","text":"If you want to test your public exposed functions or methods you can create a \"*_test\" package. This will, by definition, create a new package, which can only access exported functions and methods. Let's check that: calculator/calculator.go 1 2 3 func Add ( a int , b int ) int { return a + b } calculator/calculator_test/calculator_test.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package calculator import ( \"testing\" \"example/calculator\" ) func Test_Add ( t * testing . T ) { result := calculator . Add ( 1 , 2 ) expected := 3 if result != expected { t . Error ( \"not correct, expected\" , expected , \" got\" , result ) } }","title":"Public API Testing"},{"location":"golang/golang-fundamentals/tests/#testify","text":"In a lot of projects you will see the package github.com/stretchr/testify/assert . This is because it brings a more \"convenient\" way of testing with assertions, mocking, and suite. Let's check some examples: main.go 1 2 3 4 5 6 7 8 import ( \"testing\" \"github.com/stretchr/testify/assert\" ) func Test_Add ( t * testing . T ) { assert . Equal ( t , 3 , calculator . Add ( 1 , 2 )) }","title":"Testify"},{"location":"golang/golang-fundamentals/third_party_libraries/","text":"Third Party Libraries gorm : ORM library gin : Web Framework cobra : CLI library zap : Logger Library for Go Go Awesome","title":"Third Party Libraries"},{"location":"golang/golang-fundamentals/third_party_libraries/#third-party-libraries","text":"gorm : ORM library gin : Web Framework cobra : CLI library zap : Logger Library for Go Go Awesome","title":"Third Party Libraries"},{"location":"golang/golang-fundamentals/types_interfaces_methods/","text":"Types, Interfaces and Methods Types Go allows you to declare a user-defined type. It can be a struct literal or primitive type. Let's see an example: 1 2 3 4 5 6 7 8 type Person struct { FirstName string LastName string } type Score int type Converter func ( string ) Score type TeamScores map [ string ] Score Methods Like many programming languages, Go supports Methods on user-defined types. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type Person struct { FirstName string LastName string Age int } func ( p Person ) String () string { return fmt . Sprintf ( \"%s %s: age %d\" , p . FirstName , p . LastName , p . Age ) } func main () { p := Person { FirstName : \"Michael\" , LastName : \"Bykovski\" , Age : 28 , } fmt . Println ( p . String ()) } The receiver declares to which type a function belongs to. The receiver is between the func keyword and the method's name and it's usually a short abbreviation of the receiver type and not conventional names like self or this . Method overloading is prohibited. You can use the same name for different user-defined types, but not two methods with the same name for one specific user-defined types. Pointer Receivers As with usual functions the parameters (or receivers) of function are passed by value. This means, that the method will work on a copy of the receiver variable. If you want to modify the receiver variable, you can use pointer receivers: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type Counter struct { total int lastUpdated time . Time } func ( c * Counter ) Increment () { c . total ++ c . lastUpdated = time . Now () } func ( c Counter ) String () string { return fmt . Sprintf ( \"counts: %d, last updated %v\" , c . total , c . lastUpdated ) } func main () { counter := Counter {} fmt . Println ( counter . String ()) counter . Increment () fmt . Println ( counter . String ()) } output will be: counts: 0, last updated 0001-01-01 00:00:00 +0000 UTC counts: 1, last updated 2009-11-10 23:00:00 +0000 UTC m=+0.000000001 If you use counter you dont have to convert it to a pointer type, because you use the method of the specific type. So therefore counter.Increment() is converted to (&counter).Increment() Be aware if you pass in a copy of a variable and work with the pointer type of it. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 type Counter struct { total int lastUpdated time . Time } func ( c * Counter ) Increment () { c . total ++ c . lastUpdated = time . Now () } func ( c Counter ) String () string { return fmt . Sprintf ( \"counts: %d, last updated %v\" , c . total , c . lastUpdated ) } func update ( counter Counter ) { counter . Increment () } func main () { counter := Counter {} fmt . Println ( counter . String ()) update ( counter ) fmt . Println ( counter . String ()) } will output: counts: 0, last updated 0001-01-01 00:00:00 +0000 UTC counts: 0, last updated 0001-01-01 00:00:00 +0000 UTC Nil and Methods If a struct poiner gets declared but not initialized it becomes nil. Implementing pointer receivers on structs can produce a problem. But Go handles it quiet easily: If you create a nil struct pointer and call a value receiver, it will panic If you create a nil struct pointer and call a pointer receiver, it will try to execute the function Here are some examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 type Person struct { FirstName string LastName string } func ( p * Person ) ChangeName ( newName string ) * Person { if p == nil { return & Person { LastName : newName , } } p . LastName = newName return p } func ( p Person ) String () string { return fmt . Sprintf ( \"%s %s\" , p . FirstName , p . LastName ) } func main () { var person * Person newPerson := person . ChangeName ( \"Test\" ) fmt . Println ( newPerson . String ()) fmt . Println ( person . String ()) } output: Test panic: runtime error: invalid memory address or nil pointer dereference Nested Typing is not Inheritance One could believe that if you nest different types, you get a similar behaviour like inheratance. But this is not correct. Inheritance would enable the possibility to use the underlying defined methods for the inherited type, but this is not the case. Every type builds it's own \"environment\" with methods. You can't even assign a child type to a parent type, because in Go those type are two different one and don't belong together. Danger This won't work: 1 2 3 4 5 6 7 8 9 10 11 12 13 type Score int type TeamScore Score func ( s Score ) Good () bool { return s > 10 } func main () { var score Score teamScore := TeamScore ( 10 ) fmt . Println ( \"Team Score is: \" , teamScore . Good ()) score = teamScore } Success This works: 1 2 3 4 5 6 7 8 9 10 11 12 13 type Score int type TeamScore Score func ( s Score ) Good () bool { return s > 10 } func main () { var score Score teamScore := TeamScore ( 10 ) fmt . Println ( \"Team Score is: \" , Score ( teamScore ). Good ()) score = Score ( teamScore ) } iotas are Enums Go doesn't have the concept of enumerations. But it has iota , which somehow has the same concepts, but different. If you start with iota define an integer type: 1 type PurchasingCategory int then start with a const block and define a some iotas: 1 2 3 4 5 6 7 const ( NoCategory PurchasingCategory = iota Shirts Pants Watches Hats ) If the Go compiler sees iota at the end of a line and succeeding lines of constants it will increment each line by one. The first constant NoCategory receives the value 0 . If you define a new const block with another variable, iota will start again from 0 . Danger This will not work 1 2 3 4 5 6 7 8 9 10 11 type Test int const ( one Test = 1 two three ) func main () { fmt . Println ( one , two , three ) } output: 1 1 1 Success This is the correct usage: 1 2 3 4 5 6 7 8 9 10 11 type Test int const ( one Test = iota two three ) func main () { fmt . Println ( one , two , three ) } Use iota only if you are not relying on the value of the constants. Because the values can be changed, if you insert a new constant in the middle of the definition block. Use commond constants with a value assigned if you use it for database entries or outgoing messages. Use iotas only for \"internal\" computation, where you need some kind of named constant where the value doesn't matter. Embedding is Composition There is some kind of inheritance in Go what is called \"Composition\". Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package main import ( \"fmt\" \"strings\" ) type Employee struct { Name string ID string } func ( e Employee ) Description () string { return fmt . Sprintf ( \"%s: %s\" , e . ID , e . Name ) } type Project struct { Name string } type Projects [] Project func ( ps Projects ) ProjectNames () [] string { var names [] string for _ , project := range ps { names = append ( names , project . Name ) } return names } type SoftwareDeveloper struct { Employee Projects Projects } func ( sd SoftwareDeveloper ) String () string { return fmt . Sprintf ( \"%s\\nProjects: \\n%s\" , sd . Description (), strings . Join ( sd . Projects . ProjectNames (), \"\\n\" , ), ) } func main () { developer := SoftwareDeveloper { Employee : Employee { Name : \"Michael Bykovski\" , ID : \"1\" , }, Projects : Projects { { Name : \"Daimler\" }, { Name : \"Deutsche B\u00f6rse\" }, }, } fmt . Println ( developer ) } It is important to leave the name of the variable of the embedding struct (line 33). If you want to overwrite the embedded function or some field, just do it. They will be still accessable: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 type Inner struct { Y int } func ( i Inner ) String () string { return fmt . Sprintf ( \"%d\" , i . Y ) } type Outer struct { Inner Y int } func ( o Outer ) String () string { return fmt . Sprintf ( \"%d\" , o . Y ) } func main () { outer := Outer { Inner : Inner { Y : 5 , }, Y : 10 , } fmt . Println ( outer . String (), outer . Inner . String ()) } output: 10 5 Embedding is not Inheritance Do not treat embedding as inheritance. You cannot assign an inherited member to the parent type 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type Inner struct { Y int } type Outer struct { Inner Y int } func main () { var inner Inner outer := Outer { Inner : Inner { Y : 1 , }, Y : 2 , } inner = outer } output would be: cannot use outer (variable of type Outer) as type Inner in assignment this would fix it: 1 2 3 4 5 6 7 8 9 10 func main () { var inner Inner outer := Outer { Inner : Inner { Y : 1 , }, Y : 2 , } inner = outer . Inner } Go does not dynamically dispatch the Methods 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 type Inner struct { Y int } func ( i Inner ) IntPrinter ( value int ) string { return fmt . Sprintf ( \"Inner: %d\" , value ) } func ( i Inner ) Double () string { return i . IntPrinter ( i . Y * 2 ) } type Outer struct { Inner Y int } func ( o Outer ) IntPrinter ( value int ) string { return fmt . Sprintf ( \"Outer: %d\" , value ) } func main () { outer := Outer { Inner : Inner { Y : 2 , }, Y : 4 , } fmt . Println ( outer . Double ()) } If you have a struct, which embeds another struct and you can an embedded function, it will resolve other functions of the struct in the \"embedded scope\". Interfaces Why interfaces? Tip Interfaces specify behaviour . Interfaces are a tool to make code more reliable, shorter, clearer and easier to understand. But using to much and unnecessary interfaces can have the opposite effect. Let's have a look at the following example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import \"fmt\" type Cat struct {} func ( c Cat ) Say () string { return \"meow\" } func ( c Cat ) Type () string { return \"cat\" } type Dog struct {} func ( d Dog ) Say () string { return \"woof\" } func ( d Dog ) Type () string { return \"dog\" } func main () { c := Cat {} fmt . Println ( c . Type (), \"says:\" , c . Say ()) d := Dog {} fmt . Println ( d . Type (), \"says:\" , d . Say ()) } Output: cat says: meow dog says: woof If we would like to make a function, which takes in a Cat or a Dog and prints out the output message, we would have to create two functions, because of Go's strict typing. 1 2 3 4 5 6 7 func TalkDog ( dog Dog ) { fmt . Println ( dog . Type (), \"says:\" , dog . Say ()) } func TalkCat ( cat Cat ) { fmt . Println ( cat . Type (), \"says:\" , cat . Say ()) } But there is help, we can use interfaces . Syntax The only abstract type in Go are interfaces . 1 2 3 type Stringer interface { String () string } Usually interfaces end with \"er\", there are several Go built-in interfaces like io.Reader , io.Closer , io.ReadCloser , json.Marshaler . Implicit Interfaces Go Interfaces work in a different way compared to other programming languages. Types implement interfaces by implementing their function signatures. Let's check it out: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 type ConsoleWriter struct { Prefix string } func ( cw ConsoleWriter ) Write ( data string ) { fmt . Println ( cw . Prefix , \":\" , data ) } type Writer interface { Write ( data string ) } type Application struct { W Writer } func ( a Application ) Run () { a . W . Write ( \"Hello World\" ) } func main () { application := Application { W : ConsoleWriter { Prefix : \"ConsoleWriter\" , }, } application . Run () } Application wants a type that fulfills the Writer interface. Since ConsoleWriter implements the defined function signatures of the Writer interface, it implements automatically the Writer interface. Interfaces are a type and therefore they can be shared like functions, variables and structs. Let's check this example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 type ConsoleWriter struct { Prefix string } func ( cw ConsoleWriter ) Write ( data string ) { fmt . Println ( cw . Prefix , \":\" , data ) } type Writer interface { Write ( data string ) } type Application struct { W Writer } func NewApplication ( w Writer ) Application { return Application { W : w , } } func ( a Application ) Run () { a . W . Write ( \"Hello World\" ) } func main () { consoleWriter := ConsoleWriter { Prefix : \"ConsoleWriter\" , } application := NewApplication ( consoleWriter ) application . Run () } You can also append new methods to structs which implement interfaces. As long as the signature fulfills the interface, it implements the interface, all other methods belong to the struct. Multiple interface implementations are also possible: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 type ConsoleWriter struct { Prefix string Cache string } func ( cw ConsoleWriter ) Write ( data string ) { fmt . Printf ( \"%s: %s (cached: %s)\" , cw . Prefix , data , cw . Cache ) cw . Cache = \"\" } func ( cw * ConsoleWriter ) Read ( data string ) { cw . Cache = data } func ( cw * ConsoleWriter ) PurgeCache () { cw . Cache = \"\" } type Writer interface { Write ( data string ) } type Reader interface { Read ( data string ) } type Application struct { W Writer R Reader } func NewApplication ( w Writer , r Reader ) Application { return Application { W : w , R : r , } } func ( a Application ) Run () { a . R . Read ( \"Hello World\" ) a . W . Write ( \"Hello Go\" ) } func main () { consoleWriter := ConsoleWriter { Prefix : \"ConsoleWriter\" , } application := NewApplication ( & consoleWriter , & consoleWriter ) application . Run () consoleWriter . PurgeCache () } Embedding Interfaces The same way you can embed structs, you can embed interfaces too. Here is an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 type ConsoleWriter struct { Prefix string Cache string } func ( cw ConsoleWriter ) Write ( data string ) { fmt . Printf ( \"%s: %s (cached: %s)\" , cw . Prefix , data , cw . Cache ) cw . Cache = \"\" } func ( cw * ConsoleWriter ) Read ( data string ) { cw . Cache = data } func ( cw * ConsoleWriter ) PurgeCache () { cw . Cache = \"\" } type Writer interface { Write ( data string ) } type Reader interface { Read ( data string ) } type ReaderWriter interface { Reader Writer } type Application struct { RW ReaderWriter } func NewApplication ( readerWriter ReaderWriter ) Application { return Application { RW : readerWriter , } } func ( a Application ) Run () { a . RW . Read ( \"Hello World\" ) a . RW . Write ( \"Hello Go\" ) } func main () { consoleWriter := ConsoleWriter { Prefix : \"ConsoleWriter\" , } application := NewApplication ( & consoleWriter ) application . Run () consoleWriter . PurgeCache () } Accept Interfaces, Return Concrete Types As we want to decouple our code but make it easy to adapt we should build functions that accept interfaces and return concrete types. Because interfaces define a specific functionality our code should accept functionality, run it and return a concrete behaviour or value. Let's take for example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type UserData struct { // ... } type Authentication struct { // ... } func ( a Authentication ) Auth () ( UserData , error ) { // ... return UserData {}, nil } func DoAuthentication ( a Authentication ) ( UserData , error ) { // ... return a . Auth () } If we want now to support multiple Auth methods for example, we can open the DoAuthentication for an interface, which defines the Method Auth but we should still a concrete struct, for further implementations: userdata.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 type AppleUserData struct { // ... } type GoogleUserData struct { // ... } type UserData struct { AppleUserData * AppleUserData GoogleUserData * GoogleUserData } func ( ud UserData ) IsApple () { // ... } func ( ud UserData ) IsGoogle () { // ... } type Authenticator interface { Auth () ( UserData , error ) } type GoogleAuthentication struct { // ... } func ( ga GoogleAuthentication ) Auth () ( UserData , error ) { // ... return UserData { GoogleUserData : & GoogleUserData { // ... }, }, nil } type AppleAuthentication struct { // ... } func ( aa AppleAuthentication ) Auth () ( UserData , error ) { return UserData { AppleUserData : & AppleUserData { // ... }, }, nil } func DoAuthentication ( a Authenticator ) ( UserData , error ) { return a . Auth () } Danger Do NOT do this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 type UserData struct { // ... } type UserDataGetter interface { UserData () UserData } type AppleUserData struct { // ... } func ( aud AppleUserData ) UserData () { } type GoogleUserData struct { // ... } // ... func DoAuthentication ( a Authenticator ) UserDataGetter { return a . Auth () } If you want to read more about \"accept interfaces, return concrete types\" follow this and this The rule is: Unnecessary abstraction creates unnecessary complication. Don\u2019t over complicate code until it\u2019s needed. Interface as a type An interface can be used as a type. It does the same if you define a user-defined user type. The example above shows a defined interface with no methods . Therefore every type can be used as this interface type. Take a look: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func main () { var i interface {} i = 2 fmt . Println ( i ) i = \"test\" fmt . Println ( i ) i = func () { fmt . Println ( \"Test\" ) } fmt . Println ( i ) i = struct { name string } { name : \"Michael\" , } fmt . Println ( i ) } output: 2 test 0x104244000 {Michael} You can also use any as an alias for an empty interface{} . But the empty interface is used regularly. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func main () { var i any i = 2 fmt . Println ( i ) i = \"test\" fmt . Println ( i ) i = func () { fmt . Println ( \"Test\" ) } fmt . Println ( i ) i = struct { name string } { name : \"Michael\" , } fmt . Println ( i ) } Is struct implementing interface check If you want to check, if a struct implements a specific interface. You can use a small \"hack\". Just initiate a blank identifier variable with the interface type and the struct value. 1 2 3 4 5 6 7 8 type Sayer interface { Say () string } type Cat struct {} func ( c Cat ) Say () string { return \"meow\" } var _ Sayer = Cat {} Since the compiler will ignore the value of _ but will do the type checks, this can get very useful. Interfaces and nil Interfaces are nil as long as they: don't have a type don't have a value This example should make it clear: 1 2 3 4 5 6 7 8 var s * string fmt . Println ( s == nil ) // true var i interface {} fmt . Println ( i == nil ) // true i = s fmt . Println ( i == nil ) // false This tells us, that if an interface has a struct which is nil, it can still run methods of the nil-struct: 1 2 3 4 5 6 7 8 9 10 11 12 13 type Dog struct {} func ( d * Dog ) BarkGhost () { fmt . Println ( \"Woof!\" ) } func main () { var ghostDog interface {} var dog * Dog ghostDog = dog ghostDog .( * Dog ). BarkGhost () } Empty Interface All The Way Sometimes you need to define a variable, where you will not know which type it is going to have. Take interface for that: 1 2 3 4 5 6 7 8 9 var i interface {} i = 10 fmt . Println ( i ) i = \"Hello\" fmt . Println ( i ) i = func ( word string ) string { return word } fmt . Println ( i ) output: 10 Hello 0x47dcc0 Mostly you won't need an empty interface. Sometimes you will need it to store some really unknown data structure, which comes from an unknown json schema: 1 2 3 4 5 6 7 8 9 10 func main () { data := map [ string ] interface {}{} contents , err := ioutil . ReadFile ( \"data.json\" ) if err != nil { return err } defer contents . Close () json . Unmarshal ( contents , & data ) } Type Assertions and Type Switches Type Assertions Let's make first a type assertions, so we assert a specific type to an interface variable: 1 2 3 4 5 6 7 8 9 type Score int func main () { var i interface {} var score Score = 20 i = score i2 := i .( Score ) fmt . Println ( i2 + score ) } If you try to assert a type, which could not work, Go will panic: 1 2 3 4 5 6 7 8 9 type Score int func main () { var i interface {} var score Score = 20 i = score i2 := i .( string ) fmt . Println ( i2 ) } output: interface conversion: interface {} is main.Score, not string The type has to match the exact underlying type, not embedded or type inferenced . 1 2 3 4 5 6 7 8 9 type Score int func main () { var i interface {} var score Score = 20 i = score i2 := i .( int ) fmt . Println ( i2 + score ) } output: interface conversion: interface {} is main.Score, not int If you want to test in your code and don't want to panic, use the variable, ok := idiom 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type Score int func main () { var i interface {} var score Score = 1 i = score i2 , ok := i .( int ) if ! ok { fmt . Printf ( \"i is not an int: %v\" , i ) return } fmt . Println ( i2 + 1 ) } Type Switches If your interface variable can have multiple types, use a type switch: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func checkType ( i interface {}) { switch j := i .( type ) { case nil : fmt . Println ( \"i is nil\" ) return case int : fmt . Println ( \"i is an int\" ) return case string fmt . Println ( \"i is a string\" ) return default : fmt . Println ( \"the type is not defined as case\" ) return } }","title":"Types, Interfaces and Methods"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#types-interfaces-and-methods","text":"","title":"Types, Interfaces and Methods"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#types","text":"Go allows you to declare a user-defined type. It can be a struct literal or primitive type. Let's see an example: 1 2 3 4 5 6 7 8 type Person struct { FirstName string LastName string } type Score int type Converter func ( string ) Score type TeamScores map [ string ] Score","title":"Types"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#methods","text":"Like many programming languages, Go supports Methods on user-defined types. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type Person struct { FirstName string LastName string Age int } func ( p Person ) String () string { return fmt . Sprintf ( \"%s %s: age %d\" , p . FirstName , p . LastName , p . Age ) } func main () { p := Person { FirstName : \"Michael\" , LastName : \"Bykovski\" , Age : 28 , } fmt . Println ( p . String ()) } The receiver declares to which type a function belongs to. The receiver is between the func keyword and the method's name and it's usually a short abbreviation of the receiver type and not conventional names like self or this . Method overloading is prohibited. You can use the same name for different user-defined types, but not two methods with the same name for one specific user-defined types.","title":"Methods"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#pointer-receivers","text":"As with usual functions the parameters (or receivers) of function are passed by value. This means, that the method will work on a copy of the receiver variable. If you want to modify the receiver variable, you can use pointer receivers: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type Counter struct { total int lastUpdated time . Time } func ( c * Counter ) Increment () { c . total ++ c . lastUpdated = time . Now () } func ( c Counter ) String () string { return fmt . Sprintf ( \"counts: %d, last updated %v\" , c . total , c . lastUpdated ) } func main () { counter := Counter {} fmt . Println ( counter . String ()) counter . Increment () fmt . Println ( counter . String ()) } output will be: counts: 0, last updated 0001-01-01 00:00:00 +0000 UTC counts: 1, last updated 2009-11-10 23:00:00 +0000 UTC m=+0.000000001 If you use counter you dont have to convert it to a pointer type, because you use the method of the specific type. So therefore counter.Increment() is converted to (&counter).Increment() Be aware if you pass in a copy of a variable and work with the pointer type of it. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 type Counter struct { total int lastUpdated time . Time } func ( c * Counter ) Increment () { c . total ++ c . lastUpdated = time . Now () } func ( c Counter ) String () string { return fmt . Sprintf ( \"counts: %d, last updated %v\" , c . total , c . lastUpdated ) } func update ( counter Counter ) { counter . Increment () } func main () { counter := Counter {} fmt . Println ( counter . String ()) update ( counter ) fmt . Println ( counter . String ()) } will output: counts: 0, last updated 0001-01-01 00:00:00 +0000 UTC counts: 0, last updated 0001-01-01 00:00:00 +0000 UTC","title":"Pointer Receivers"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#nil-and-methods","text":"If a struct poiner gets declared but not initialized it becomes nil. Implementing pointer receivers on structs can produce a problem. But Go handles it quiet easily: If you create a nil struct pointer and call a value receiver, it will panic If you create a nil struct pointer and call a pointer receiver, it will try to execute the function Here are some examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 type Person struct { FirstName string LastName string } func ( p * Person ) ChangeName ( newName string ) * Person { if p == nil { return & Person { LastName : newName , } } p . LastName = newName return p } func ( p Person ) String () string { return fmt . Sprintf ( \"%s %s\" , p . FirstName , p . LastName ) } func main () { var person * Person newPerson := person . ChangeName ( \"Test\" ) fmt . Println ( newPerson . String ()) fmt . Println ( person . String ()) } output: Test panic: runtime error: invalid memory address or nil pointer dereference","title":"Nil and Methods"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#nested-typing-is-not-inheritance","text":"One could believe that if you nest different types, you get a similar behaviour like inheratance. But this is not correct. Inheritance would enable the possibility to use the underlying defined methods for the inherited type, but this is not the case. Every type builds it's own \"environment\" with methods. You can't even assign a child type to a parent type, because in Go those type are two different one and don't belong together. Danger This won't work: 1 2 3 4 5 6 7 8 9 10 11 12 13 type Score int type TeamScore Score func ( s Score ) Good () bool { return s > 10 } func main () { var score Score teamScore := TeamScore ( 10 ) fmt . Println ( \"Team Score is: \" , teamScore . Good ()) score = teamScore } Success This works: 1 2 3 4 5 6 7 8 9 10 11 12 13 type Score int type TeamScore Score func ( s Score ) Good () bool { return s > 10 } func main () { var score Score teamScore := TeamScore ( 10 ) fmt . Println ( \"Team Score is: \" , Score ( teamScore ). Good ()) score = Score ( teamScore ) }","title":"Nested Typing is not Inheritance"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#iotas-are-enums","text":"Go doesn't have the concept of enumerations. But it has iota , which somehow has the same concepts, but different. If you start with iota define an integer type: 1 type PurchasingCategory int then start with a const block and define a some iotas: 1 2 3 4 5 6 7 const ( NoCategory PurchasingCategory = iota Shirts Pants Watches Hats ) If the Go compiler sees iota at the end of a line and succeeding lines of constants it will increment each line by one. The first constant NoCategory receives the value 0 . If you define a new const block with another variable, iota will start again from 0 . Danger This will not work 1 2 3 4 5 6 7 8 9 10 11 type Test int const ( one Test = 1 two three ) func main () { fmt . Println ( one , two , three ) } output: 1 1 1 Success This is the correct usage: 1 2 3 4 5 6 7 8 9 10 11 type Test int const ( one Test = iota two three ) func main () { fmt . Println ( one , two , three ) } Use iota only if you are not relying on the value of the constants. Because the values can be changed, if you insert a new constant in the middle of the definition block. Use commond constants with a value assigned if you use it for database entries or outgoing messages. Use iotas only for \"internal\" computation, where you need some kind of named constant where the value doesn't matter.","title":"iotas are Enums"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#embedding-is-composition","text":"There is some kind of inheritance in Go what is called \"Composition\". Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package main import ( \"fmt\" \"strings\" ) type Employee struct { Name string ID string } func ( e Employee ) Description () string { return fmt . Sprintf ( \"%s: %s\" , e . ID , e . Name ) } type Project struct { Name string } type Projects [] Project func ( ps Projects ) ProjectNames () [] string { var names [] string for _ , project := range ps { names = append ( names , project . Name ) } return names } type SoftwareDeveloper struct { Employee Projects Projects } func ( sd SoftwareDeveloper ) String () string { return fmt . Sprintf ( \"%s\\nProjects: \\n%s\" , sd . Description (), strings . Join ( sd . Projects . ProjectNames (), \"\\n\" , ), ) } func main () { developer := SoftwareDeveloper { Employee : Employee { Name : \"Michael Bykovski\" , ID : \"1\" , }, Projects : Projects { { Name : \"Daimler\" }, { Name : \"Deutsche B\u00f6rse\" }, }, } fmt . Println ( developer ) } It is important to leave the name of the variable of the embedding struct (line 33). If you want to overwrite the embedded function or some field, just do it. They will be still accessable: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 type Inner struct { Y int } func ( i Inner ) String () string { return fmt . Sprintf ( \"%d\" , i . Y ) } type Outer struct { Inner Y int } func ( o Outer ) String () string { return fmt . Sprintf ( \"%d\" , o . Y ) } func main () { outer := Outer { Inner : Inner { Y : 5 , }, Y : 10 , } fmt . Println ( outer . String (), outer . Inner . String ()) } output: 10 5","title":"Embedding is Composition"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#embedding-is-not-inheritance","text":"Do not treat embedding as inheritance. You cannot assign an inherited member to the parent type 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type Inner struct { Y int } type Outer struct { Inner Y int } func main () { var inner Inner outer := Outer { Inner : Inner { Y : 1 , }, Y : 2 , } inner = outer } output would be: cannot use outer (variable of type Outer) as type Inner in assignment this would fix it: 1 2 3 4 5 6 7 8 9 10 func main () { var inner Inner outer := Outer { Inner : Inner { Y : 1 , }, Y : 2 , } inner = outer . Inner } Go does not dynamically dispatch the Methods 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 type Inner struct { Y int } func ( i Inner ) IntPrinter ( value int ) string { return fmt . Sprintf ( \"Inner: %d\" , value ) } func ( i Inner ) Double () string { return i . IntPrinter ( i . Y * 2 ) } type Outer struct { Inner Y int } func ( o Outer ) IntPrinter ( value int ) string { return fmt . Sprintf ( \"Outer: %d\" , value ) } func main () { outer := Outer { Inner : Inner { Y : 2 , }, Y : 4 , } fmt . Println ( outer . Double ()) } If you have a struct, which embeds another struct and you can an embedded function, it will resolve other functions of the struct in the \"embedded scope\".","title":"Embedding is not Inheritance"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#interfaces","text":"","title":"Interfaces"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#why-interfaces","text":"Tip Interfaces specify behaviour . Interfaces are a tool to make code more reliable, shorter, clearer and easier to understand. But using to much and unnecessary interfaces can have the opposite effect. Let's have a look at the following example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import \"fmt\" type Cat struct {} func ( c Cat ) Say () string { return \"meow\" } func ( c Cat ) Type () string { return \"cat\" } type Dog struct {} func ( d Dog ) Say () string { return \"woof\" } func ( d Dog ) Type () string { return \"dog\" } func main () { c := Cat {} fmt . Println ( c . Type (), \"says:\" , c . Say ()) d := Dog {} fmt . Println ( d . Type (), \"says:\" , d . Say ()) } Output: cat says: meow dog says: woof If we would like to make a function, which takes in a Cat or a Dog and prints out the output message, we would have to create two functions, because of Go's strict typing. 1 2 3 4 5 6 7 func TalkDog ( dog Dog ) { fmt . Println ( dog . Type (), \"says:\" , dog . Say ()) } func TalkCat ( cat Cat ) { fmt . Println ( cat . Type (), \"says:\" , cat . Say ()) } But there is help, we can use interfaces .","title":"Why interfaces?"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#syntax","text":"The only abstract type in Go are interfaces . 1 2 3 type Stringer interface { String () string } Usually interfaces end with \"er\", there are several Go built-in interfaces like io.Reader , io.Closer , io.ReadCloser , json.Marshaler .","title":"Syntax"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#implicit-interfaces","text":"Go Interfaces work in a different way compared to other programming languages. Types implement interfaces by implementing their function signatures. Let's check it out: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 type ConsoleWriter struct { Prefix string } func ( cw ConsoleWriter ) Write ( data string ) { fmt . Println ( cw . Prefix , \":\" , data ) } type Writer interface { Write ( data string ) } type Application struct { W Writer } func ( a Application ) Run () { a . W . Write ( \"Hello World\" ) } func main () { application := Application { W : ConsoleWriter { Prefix : \"ConsoleWriter\" , }, } application . Run () } Application wants a type that fulfills the Writer interface. Since ConsoleWriter implements the defined function signatures of the Writer interface, it implements automatically the Writer interface. Interfaces are a type and therefore they can be shared like functions, variables and structs. Let's check this example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 type ConsoleWriter struct { Prefix string } func ( cw ConsoleWriter ) Write ( data string ) { fmt . Println ( cw . Prefix , \":\" , data ) } type Writer interface { Write ( data string ) } type Application struct { W Writer } func NewApplication ( w Writer ) Application { return Application { W : w , } } func ( a Application ) Run () { a . W . Write ( \"Hello World\" ) } func main () { consoleWriter := ConsoleWriter { Prefix : \"ConsoleWriter\" , } application := NewApplication ( consoleWriter ) application . Run () } You can also append new methods to structs which implement interfaces. As long as the signature fulfills the interface, it implements the interface, all other methods belong to the struct. Multiple interface implementations are also possible: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 type ConsoleWriter struct { Prefix string Cache string } func ( cw ConsoleWriter ) Write ( data string ) { fmt . Printf ( \"%s: %s (cached: %s)\" , cw . Prefix , data , cw . Cache ) cw . Cache = \"\" } func ( cw * ConsoleWriter ) Read ( data string ) { cw . Cache = data } func ( cw * ConsoleWriter ) PurgeCache () { cw . Cache = \"\" } type Writer interface { Write ( data string ) } type Reader interface { Read ( data string ) } type Application struct { W Writer R Reader } func NewApplication ( w Writer , r Reader ) Application { return Application { W : w , R : r , } } func ( a Application ) Run () { a . R . Read ( \"Hello World\" ) a . W . Write ( \"Hello Go\" ) } func main () { consoleWriter := ConsoleWriter { Prefix : \"ConsoleWriter\" , } application := NewApplication ( & consoleWriter , & consoleWriter ) application . Run () consoleWriter . PurgeCache () }","title":"Implicit Interfaces"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#embedding-interfaces","text":"The same way you can embed structs, you can embed interfaces too. Here is an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 type ConsoleWriter struct { Prefix string Cache string } func ( cw ConsoleWriter ) Write ( data string ) { fmt . Printf ( \"%s: %s (cached: %s)\" , cw . Prefix , data , cw . Cache ) cw . Cache = \"\" } func ( cw * ConsoleWriter ) Read ( data string ) { cw . Cache = data } func ( cw * ConsoleWriter ) PurgeCache () { cw . Cache = \"\" } type Writer interface { Write ( data string ) } type Reader interface { Read ( data string ) } type ReaderWriter interface { Reader Writer } type Application struct { RW ReaderWriter } func NewApplication ( readerWriter ReaderWriter ) Application { return Application { RW : readerWriter , } } func ( a Application ) Run () { a . RW . Read ( \"Hello World\" ) a . RW . Write ( \"Hello Go\" ) } func main () { consoleWriter := ConsoleWriter { Prefix : \"ConsoleWriter\" , } application := NewApplication ( & consoleWriter ) application . Run () consoleWriter . PurgeCache () }","title":"Embedding Interfaces"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#accept-interfaces-return-concrete-types","text":"As we want to decouple our code but make it easy to adapt we should build functions that accept interfaces and return concrete types. Because interfaces define a specific functionality our code should accept functionality, run it and return a concrete behaviour or value. Let's take for example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type UserData struct { // ... } type Authentication struct { // ... } func ( a Authentication ) Auth () ( UserData , error ) { // ... return UserData {}, nil } func DoAuthentication ( a Authentication ) ( UserData , error ) { // ... return a . Auth () } If we want now to support multiple Auth methods for example, we can open the DoAuthentication for an interface, which defines the Method Auth but we should still a concrete struct, for further implementations: userdata.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 type AppleUserData struct { // ... } type GoogleUserData struct { // ... } type UserData struct { AppleUserData * AppleUserData GoogleUserData * GoogleUserData } func ( ud UserData ) IsApple () { // ... } func ( ud UserData ) IsGoogle () { // ... } type Authenticator interface { Auth () ( UserData , error ) } type GoogleAuthentication struct { // ... } func ( ga GoogleAuthentication ) Auth () ( UserData , error ) { // ... return UserData { GoogleUserData : & GoogleUserData { // ... }, }, nil } type AppleAuthentication struct { // ... } func ( aa AppleAuthentication ) Auth () ( UserData , error ) { return UserData { AppleUserData : & AppleUserData { // ... }, }, nil } func DoAuthentication ( a Authenticator ) ( UserData , error ) { return a . Auth () } Danger Do NOT do this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 type UserData struct { // ... } type UserDataGetter interface { UserData () UserData } type AppleUserData struct { // ... } func ( aud AppleUserData ) UserData () { } type GoogleUserData struct { // ... } // ... func DoAuthentication ( a Authenticator ) UserDataGetter { return a . Auth () } If you want to read more about \"accept interfaces, return concrete types\" follow this and this The rule is: Unnecessary abstraction creates unnecessary complication. Don\u2019t over complicate code until it\u2019s needed.","title":"Accept Interfaces, Return Concrete Types"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#interface-as-a-type","text":"An interface can be used as a type. It does the same if you define a user-defined user type. The example above shows a defined interface with no methods . Therefore every type can be used as this interface type. Take a look: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func main () { var i interface {} i = 2 fmt . Println ( i ) i = \"test\" fmt . Println ( i ) i = func () { fmt . Println ( \"Test\" ) } fmt . Println ( i ) i = struct { name string } { name : \"Michael\" , } fmt . Println ( i ) } output: 2 test 0x104244000 {Michael} You can also use any as an alias for an empty interface{} . But the empty interface is used regularly. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func main () { var i any i = 2 fmt . Println ( i ) i = \"test\" fmt . Println ( i ) i = func () { fmt . Println ( \"Test\" ) } fmt . Println ( i ) i = struct { name string } { name : \"Michael\" , } fmt . Println ( i ) }","title":"Interface as a type"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#is-struct-implementing-interface-check","text":"If you want to check, if a struct implements a specific interface. You can use a small \"hack\". Just initiate a blank identifier variable with the interface type and the struct value. 1 2 3 4 5 6 7 8 type Sayer interface { Say () string } type Cat struct {} func ( c Cat ) Say () string { return \"meow\" } var _ Sayer = Cat {} Since the compiler will ignore the value of _ but will do the type checks, this can get very useful.","title":"Is struct implementing interface check"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#interfaces-and-nil","text":"Interfaces are nil as long as they: don't have a type don't have a value This example should make it clear: 1 2 3 4 5 6 7 8 var s * string fmt . Println ( s == nil ) // true var i interface {} fmt . Println ( i == nil ) // true i = s fmt . Println ( i == nil ) // false This tells us, that if an interface has a struct which is nil, it can still run methods of the nil-struct: 1 2 3 4 5 6 7 8 9 10 11 12 13 type Dog struct {} func ( d * Dog ) BarkGhost () { fmt . Println ( \"Woof!\" ) } func main () { var ghostDog interface {} var dog * Dog ghostDog = dog ghostDog .( * Dog ). BarkGhost () }","title":"Interfaces and nil"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#empty-interface-all-the-way","text":"Sometimes you need to define a variable, where you will not know which type it is going to have. Take interface for that: 1 2 3 4 5 6 7 8 9 var i interface {} i = 10 fmt . Println ( i ) i = \"Hello\" fmt . Println ( i ) i = func ( word string ) string { return word } fmt . Println ( i ) output: 10 Hello 0x47dcc0 Mostly you won't need an empty interface. Sometimes you will need it to store some really unknown data structure, which comes from an unknown json schema: 1 2 3 4 5 6 7 8 9 10 func main () { data := map [ string ] interface {}{} contents , err := ioutil . ReadFile ( \"data.json\" ) if err != nil { return err } defer contents . Close () json . Unmarshal ( contents , & data ) }","title":"Empty Interface All The Way"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#type-assertions-and-type-switches","text":"","title":"Type Assertions and Type Switches"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#type-assertions","text":"Let's make first a type assertions, so we assert a specific type to an interface variable: 1 2 3 4 5 6 7 8 9 type Score int func main () { var i interface {} var score Score = 20 i = score i2 := i .( Score ) fmt . Println ( i2 + score ) } If you try to assert a type, which could not work, Go will panic: 1 2 3 4 5 6 7 8 9 type Score int func main () { var i interface {} var score Score = 20 i = score i2 := i .( string ) fmt . Println ( i2 ) } output: interface conversion: interface {} is main.Score, not string The type has to match the exact underlying type, not embedded or type inferenced . 1 2 3 4 5 6 7 8 9 type Score int func main () { var i interface {} var score Score = 20 i = score i2 := i .( int ) fmt . Println ( i2 + score ) } output: interface conversion: interface {} is main.Score, not int If you want to test in your code and don't want to panic, use the variable, ok := idiom 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type Score int func main () { var i interface {} var score Score = 1 i = score i2 , ok := i .( int ) if ! ok { fmt . Printf ( \"i is not an int: %v\" , i ) return } fmt . Println ( i2 + 1 ) }","title":"Type Assertions"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#type-switches","text":"If your interface variable can have multiple types, use a type switch: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func checkType ( i interface {}) { switch j := i .( type ) { case nil : fmt . Println ( \"i is nil\" ) return case int : fmt . Println ( \"i is an int\" ) return case string fmt . Println ( \"i is a string\" ) return default : fmt . Println ( \"the type is not defined as case\" ) return } }","title":"Type Switches"},{"location":"javascript/","text":"Introduction Welcome to my lectures which I collected, wrote, reevaluated and worked on in several years. Here is the webengineering course: Link","title":"Introduction"},{"location":"javascript/#introduction","text":"Welcome to my lectures which I collected, wrote, reevaluated and worked on in several years. Here is the webengineering course: Link","title":"Introduction"},{"location":"javascript/byot/","text":"Introduction Build Your Own Tool follows the idea, that you build a small tool with the least effort possible. To achieve this solution there is currently a best practice way to do so. Strapi is an open source headless CMS which is build with JavaScript. Next.JS is a React Framework. You can find the whole example as repository on Github","title":"Introduction"},{"location":"javascript/byot/#introduction","text":"Build Your Own Tool follows the idea, that you build a small tool with the least effort possible. To achieve this solution there is currently a best practice way to do so. Strapi is an open source headless CMS which is build with JavaScript. Next.JS is a React Framework. You can find the whole example as repository on Github","title":"Introduction"},{"location":"javascript/byot/add-theme/","text":"Add Theme We add a theme to our application first with: yarn add 98 .css and then in the file dashboard/pages/_app.js : import \"../styles/globals.css\" ; import \"98.css\" ; function MyApp ({ Component , pageProps }) { return < Component {... pageProps } /> ; } export default MyApp ;","title":"Add Theme"},{"location":"javascript/byot/add-theme/#add-theme","text":"We add a theme to our application first with: yarn add 98 .css and then in the file dashboard/pages/_app.js : import \"../styles/globals.css\" ; import \"98.css\" ; function MyApp ({ Component , pageProps }) { return < Component {... pageProps } /> ; } export default MyApp ;","title":"Add Theme"},{"location":"javascript/byot/api/","text":"API Find Now after we setup the Content-Type and the Roles & Permissions we are able to access the api: http://localhost:1337/events We will get a response like this: [ { id : 1 , na me : \"TechTalk #46 - BYOT - Build Your Own Tool mit Strapi und Next.js!\" , descrip t io n : \" \" Sch nell mal ei n Tool baue n \" ist f\u00fcr viele eine gro\u00dfe Herausforderung. Es muss ein Backend mit Datenbankzugriff, REST-Schnittstellen, Benutzerverwaltung und vielen mehr entwickelt werden. Hinzu kommt, dass eine Oberfl\u00e4che f\u00fcr das Eintragen und Anzeigen der Daten implementiert werden muss. Des Weiteren bleibt es meistens nicht bei der Verwaltung und Anzeige der Daten, denn es wird noch dazu ein Gesch\u00e4ftsprozess programmiert. Mit Strapi und Next.JS zeige ich anhand eines Live-Coding-Beispiels, wie ein Event-Verwaltungstool f\u00fcr interne Events eines Unternehmens in unter einer Stunde entwickelt werden kann.\" , s tart : \"2020-10-02T15:00:00.000Z\" , e n d : \"2020-10-02T18:00:00.000Z\" , crea te d_by : { id : 1 , f irs tna me : \"Test\" , las tna me : \"test\" , user na me : null }, upda te d_by : { id : 1 , f irs tna me : \"Test\" , las tna me : \"test\" , user na me : null }, crea te d_a t : \"2020-09-21T07:20:05.564Z\" , upda te d_a t : \"2020-09-21T07:20:05.573Z\" } ] Find One And we can directly access the event with the id: http://localhost:1337/events/1 Response: { id : 1 , na me : \"TechTalk #46 - BYOT - Build Your Own Tool mit Strapi und Next.js!\" , descrip t io n : \" \" Sch nell mal ei n Tool baue n \" ist f\u00fcr viele eine gro\u00dfe Herausforderung. Es muss ein Backend mit Datenbankzugriff, REST-Schnittstellen, Benutzerverwaltung und vielen mehr entwickelt werden. Hinzu kommt, dass eine Oberfl\u00e4che f\u00fcr das Eintragen und Anzeigen der Daten implementiert werden muss. Des Weiteren bleibt es meistens nicht bei der Verwaltung und Anzeige der Daten, denn es wird noch dazu ein Gesch\u00e4ftsprozess programmiert. Mit Strapi und Next.JS zeige ich anhand eines Live-Coding-Beispiels, wie ein Event-Verwaltungstool f\u00fcr interne Events eines Unternehmens in unter einer Stunde entwickelt werden kann.\" , s tart : \"2020-10-02T15:00:00.000Z\" , e n d : \"2020-10-02T18:00:00.000Z\" , crea te d_by : { id : 1 , f irs tna me : \"Test\" , las tna me : \"test\" , user na me : null }, upda te d_by : { id : 1 , f irs tna me : \"Test\" , las tna me : \"test\" , user na me : null }, crea te d_a t : \"2020-09-21T07:20:05.564Z\" , upda te d_a t : \"2020-09-21T07:20:05.573Z\" }","title":"API"},{"location":"javascript/byot/api/#api","text":"","title":"API"},{"location":"javascript/byot/api/#find","text":"Now after we setup the Content-Type and the Roles & Permissions we are able to access the api: http://localhost:1337/events We will get a response like this: [ { id : 1 , na me : \"TechTalk #46 - BYOT - Build Your Own Tool mit Strapi und Next.js!\" , descrip t io n : \" \" Sch nell mal ei n Tool baue n \" ist f\u00fcr viele eine gro\u00dfe Herausforderung. Es muss ein Backend mit Datenbankzugriff, REST-Schnittstellen, Benutzerverwaltung und vielen mehr entwickelt werden. Hinzu kommt, dass eine Oberfl\u00e4che f\u00fcr das Eintragen und Anzeigen der Daten implementiert werden muss. Des Weiteren bleibt es meistens nicht bei der Verwaltung und Anzeige der Daten, denn es wird noch dazu ein Gesch\u00e4ftsprozess programmiert. Mit Strapi und Next.JS zeige ich anhand eines Live-Coding-Beispiels, wie ein Event-Verwaltungstool f\u00fcr interne Events eines Unternehmens in unter einer Stunde entwickelt werden kann.\" , s tart : \"2020-10-02T15:00:00.000Z\" , e n d : \"2020-10-02T18:00:00.000Z\" , crea te d_by : { id : 1 , f irs tna me : \"Test\" , las tna me : \"test\" , user na me : null }, upda te d_by : { id : 1 , f irs tna me : \"Test\" , las tna me : \"test\" , user na me : null }, crea te d_a t : \"2020-09-21T07:20:05.564Z\" , upda te d_a t : \"2020-09-21T07:20:05.573Z\" } ]","title":"Find"},{"location":"javascript/byot/api/#find-one","text":"And we can directly access the event with the id: http://localhost:1337/events/1 Response: { id : 1 , na me : \"TechTalk #46 - BYOT - Build Your Own Tool mit Strapi und Next.js!\" , descrip t io n : \" \" Sch nell mal ei n Tool baue n \" ist f\u00fcr viele eine gro\u00dfe Herausforderung. Es muss ein Backend mit Datenbankzugriff, REST-Schnittstellen, Benutzerverwaltung und vielen mehr entwickelt werden. Hinzu kommt, dass eine Oberfl\u00e4che f\u00fcr das Eintragen und Anzeigen der Daten implementiert werden muss. Des Weiteren bleibt es meistens nicht bei der Verwaltung und Anzeige der Daten, denn es wird noch dazu ein Gesch\u00e4ftsprozess programmiert. Mit Strapi und Next.JS zeige ich anhand eines Live-Coding-Beispiels, wie ein Event-Verwaltungstool f\u00fcr interne Events eines Unternehmens in unter einer Stunde entwickelt werden kann.\" , s tart : \"2020-10-02T15:00:00.000Z\" , e n d : \"2020-10-02T18:00:00.000Z\" , crea te d_by : { id : 1 , f irs tna me : \"Test\" , las tna me : \"test\" , user na me : null }, upda te d_by : { id : 1 , f irs tna me : \"Test\" , las tna me : \"test\" , user na me : null }, crea te d_a t : \"2020-09-21T07:20:05.564Z\" , upda te d_a t : \"2020-09-21T07:20:05.573Z\" }","title":"Find One"},{"location":"javascript/byot/client/","text":"Client To communicate with the server, we need to implement a client in the dashboard. And to work easier with HTTP requests and responses, we install Axios: yarn add axios Now we implement the client: dashboard/client/index.js import Axios from \"axios\" ; export const API_URL = \"http://localhost:1337\" ; export const getEvents = async () => { return Axios . get ( ` ${ API_URL } /events` ); };","title":"Client"},{"location":"javascript/byot/client/#client","text":"To communicate with the server, we need to implement a client in the dashboard. And to work easier with HTTP requests and responses, we install Axios: yarn add axios Now we implement the client: dashboard/client/index.js import Axios from \"axios\" ; export const API_URL = \"http://localhost:1337\" ; export const getEvents = async () => { return Axios . get ( ` ${ API_URL } /events` ); };","title":"Client"},{"location":"javascript/byot/content-type/","text":"Content-Type Let's create our first content type. Imagine we want to build a small tool, which helps a company to store their upcoming and past events. First we need to create a \"content type\". You can compare it to a model or database table, which stores your information. Strapi creates and alters your table in the database automatically, so we just have to setup the content type through the UI. Click on the left side on Content-Types Builder and then on Create new collection type : Then we enter the name of the new content type Event for example: We click on Continue and add a new Textfield to the model: After that we enter \"name\" as name for the field and check the Advanded Settings , where we check required field . Now we do that for description (optional Textfield), start (required DateTimefield), end (required DateTimefield). After we created the fields we should see this model. We press Save to let Strapi create the tables in the database. On the left side under Collection Types should appear Events . We click on Events and then on Add New Event : Enter data for a new event and click on Save :","title":"Content-Type"},{"location":"javascript/byot/content-type/#content-type","text":"Let's create our first content type. Imagine we want to build a small tool, which helps a company to store their upcoming and past events. First we need to create a \"content type\". You can compare it to a model or database table, which stores your information. Strapi creates and alters your table in the database automatically, so we just have to setup the content type through the UI. Click on the left side on Content-Types Builder and then on Create new collection type : Then we enter the name of the new content type Event for example: We click on Continue and add a new Textfield to the model: After that we enter \"name\" as name for the field and check the Advanded Settings , where we check required field . Now we do that for description (optional Textfield), start (required DateTimefield), end (required DateTimefield). After we created the fields we should see this model. We press Save to let Strapi create the tables in the database. On the left side under Collection Types should appear Events . We click on Events and then on Add New Event : Enter data for a new event and click on Save :","title":"Content-Type"},{"location":"javascript/byot/implement-the-frontend/","text":"Implement the frontend Event Component First let's create a component to show our events later: dashboard/components/Event.js export const Event = ({ title , description , start , end }) => { const startDateTime = new Date ( start ); const endDateTime = new Date ( end ); return ( < div className = \"window\" style = {{ width : 300 , marginBottom : \"1em\" }} > < div className = \"title-bar\" > < div className = \"title-bar-text\" > { title } < /div> < /div> < div className = \"window-body\" > < p > { description } < /p> < hr /> < p > { startDateTime . toLocaleString ()} - { endDateTime . toLocaleString ()} < /p> < /div> < /div> ); }; export default Event ; Add react-query To fetch data properly from the backend server, we will use the library react-query . It is able to fetch, cache, synchronize and update server state. We install it using: yarn add react-query Events Container Create a container to fetch the data from the server and display it by using our created Event component, our implemented client , and the react-query library. dashboard/containers/Events.js import { useQuery } from \"react-query\" ; import { getEvents } from \"../client\" ; import { Event } from \"../components/Event\" ; export const Events = () => { const { isLoading , isError , data : events , error } = useQuery ( \"events\" , getEvents ); if ( isLoading ) { return < div > Loading ... < /div>; } if ( isError ) { return < div > Error fetching events : { error . toString ()} < /div>; } return events . map (( event ) => < Event key = { event . id } {... event } /> ); }; export default Events ; Glueing it all together Now we are finished and just have to call the Event container in the index.js file. dashboard/pages/index.js import Head from \"next/head\" ; import Events from \"../containers/Events\" ; const mainStyle = { padding : 30 , display : \"flex\" , alignItems : \"center\" , justifyContent : \"space-evenly\" , flexWrap : \"wrap\" , }; export default function Home () { return ( < div > < Head > < title > Events Dashboard < /title> < /Head> < main style = { mainStyle } > < Events /> < /main> < /div> ); } Result","title":"Implement the frontend"},{"location":"javascript/byot/implement-the-frontend/#implement-the-frontend","text":"","title":"Implement the frontend"},{"location":"javascript/byot/implement-the-frontend/#event-component","text":"First let's create a component to show our events later: dashboard/components/Event.js export const Event = ({ title , description , start , end }) => { const startDateTime = new Date ( start ); const endDateTime = new Date ( end ); return ( < div className = \"window\" style = {{ width : 300 , marginBottom : \"1em\" }} > < div className = \"title-bar\" > < div className = \"title-bar-text\" > { title } < /div> < /div> < div className = \"window-body\" > < p > { description } < /p> < hr /> < p > { startDateTime . toLocaleString ()} - { endDateTime . toLocaleString ()} < /p> < /div> < /div> ); }; export default Event ;","title":"Event Component"},{"location":"javascript/byot/implement-the-frontend/#add-react-query","text":"To fetch data properly from the backend server, we will use the library react-query . It is able to fetch, cache, synchronize and update server state. We install it using: yarn add react-query","title":"Add react-query"},{"location":"javascript/byot/implement-the-frontend/#events-container","text":"Create a container to fetch the data from the server and display it by using our created Event component, our implemented client , and the react-query library. dashboard/containers/Events.js import { useQuery } from \"react-query\" ; import { getEvents } from \"../client\" ; import { Event } from \"../components/Event\" ; export const Events = () => { const { isLoading , isError , data : events , error } = useQuery ( \"events\" , getEvents ); if ( isLoading ) { return < div > Loading ... < /div>; } if ( isError ) { return < div > Error fetching events : { error . toString ()} < /div>; } return events . map (( event ) => < Event key = { event . id } {... event } /> ); }; export default Events ;","title":"Events Container"},{"location":"javascript/byot/implement-the-frontend/#glueing-it-all-together","text":"Now we are finished and just have to call the Event container in the index.js file. dashboard/pages/index.js import Head from \"next/head\" ; import Events from \"../containers/Events\" ; const mainStyle = { padding : 30 , display : \"flex\" , alignItems : \"center\" , justifyContent : \"space-evenly\" , flexWrap : \"wrap\" , }; export default function Home () { return ( < div > < Head > < title > Events Dashboard < /title> < /Head> < main style = { mainStyle } > < Events /> < /main> < /div> ); }","title":"Glueing it all together"},{"location":"javascript/byot/implement-the-frontend/#result","text":"","title":"Result"},{"location":"javascript/byot/installation/","text":"Installation To setup the projects you need to install Node.JS . Preferably you need yarn .","title":"Installation"},{"location":"javascript/byot/installation/#installation","text":"To setup the projects you need to install Node.JS . Preferably you need yarn .","title":"Installation"},{"location":"javascript/byot/roles-and-permissions/","text":"Roles & Permissions Before we consume our created content type Event , we need to enable the endpoint find and findOne to public API.","title":"Roles & Permissions"},{"location":"javascript/byot/roles-and-permissions/#roles-permissions","text":"Before we consume our created content type Event , we need to enable the endpoint find and findOne to public API.","title":"Roles &amp; Permissions"},{"location":"javascript/byot/setup-next/","text":"Setup Next.JS Now that we have setup our headless CMS, we can create a frontend to show an event dashboard for our employees. For that we run: npx create-next-app dashboard","title":"Setup Next.JS"},{"location":"javascript/byot/setup-next/#setup-nextjs","text":"Now that we have setup our headless CMS, we can create a frontend to show an event dashboard for our employees. For that we run: npx create-next-app dashboard","title":"Setup Next.JS"},{"location":"javascript/byot/setup/","text":"Setup Strapi Create a new project with: yarn create strapi-app backend --quickstart Now your browser should show up this site:","title":"Setup Strapi"},{"location":"javascript/byot/setup/#setup-strapi","text":"Create a new project with: yarn create strapi-app backend --quickstart Now your browser should show up this site:","title":"Setup Strapi"},{"location":"react/chakra-ui/","text":"Chakra UI TBD","title":"Chakra UI"},{"location":"react/chakra-ui/#chakra-ui","text":"TBD","title":"Chakra UI"},{"location":"react/component_lifecycles/","text":"Component Lifecycles Here are the component lifecycles listed. Let's talk about that a little bit deeper: Example import React from \"react\" ; import * as ReactDOM from \"react-dom/client\" ; function Reactive ({ prop }) { const [ state , setState ] = React . useState (); // Runs on mount React . useEffect (() => { console . log ( \"this runs only on component mount\" ); // Runs on unmount return () => { console . log ( \"this run when the component unmounts\" ); }; }, []); // Runs on every change of prop and state React . useEffect (() => { console . log ( \"this runs on every update of prop or state\" ); }, [ prop , state ]); // Returns on every state and prop change return < button onClick = {() => setState ( \"test\" )} > Click < /button>; } function Component () { const [ isShowReactive , setIsShowReactive ] = React . useState ( false ); const [ outerState , setOuterState ] = React . useState ( \"\" ); return ( <> { isShowReactive && < Reactive prop = { outerState } /> } < input value = { outerState } onChange = {( event ) => setOuterState ( event . target . value )} /> < button onClick = {() => setIsShowReactive ( ! isShowReactive )} > Toggle < /button> < /> ); } const root = ReactDOM . createRoot ( document . getElementById ( \"root\" )); root . render ( < Component /> );","title":"Component Lifecycles"},{"location":"react/component_lifecycles/#component-lifecycles","text":"Here are the component lifecycles listed. Let's talk about that a little bit deeper: Example import React from \"react\" ; import * as ReactDOM from \"react-dom/client\" ; function Reactive ({ prop }) { const [ state , setState ] = React . useState (); // Runs on mount React . useEffect (() => { console . log ( \"this runs only on component mount\" ); // Runs on unmount return () => { console . log ( \"this run when the component unmounts\" ); }; }, []); // Runs on every change of prop and state React . useEffect (() => { console . log ( \"this runs on every update of prop or state\" ); }, [ prop , state ]); // Returns on every state and prop change return < button onClick = {() => setState ( \"test\" )} > Click < /button>; } function Component () { const [ isShowReactive , setIsShowReactive ] = React . useState ( false ); const [ outerState , setOuterState ] = React . useState ( \"\" ); return ( <> { isShowReactive && < Reactive prop = { outerState } /> } < input value = { outerState } onChange = {( event ) => setOuterState ( event . target . value )} /> < button onClick = {() => setIsShowReactive ( ! isShowReactive )} > Toggle < /button> < /> ); } const root = ReactDOM . createRoot ( document . getElementById ( \"root\" )); root . render ( < Component /> );","title":"Component Lifecycles"},{"location":"react/components/","text":"Components A React component is a small, reusable code, which is responsible for one part of the application UI. A React application is an aggregation of components. React can help us to build reusable components. The following diagram shows different components. All the components have different border colors. In React we assemble different components together to create an application. We use JavaScript functions or classes to make components. If we use a function, the component will be a functional component, but if we use a class, the component will be a class-based component. Components can be: Functional Component / Presentational Component / Stateless Component / Dumb Component Class Component / Container Component / Stateful Component / Smart Component The classification of components above does not work for the latest version of React, but it is good to know the former definition and how the previous versions work. So, let us change all the JSX to components. Components in React are JavaScript functions, that return a JSX. Component name must start with an uppercase, and if the name is two words, it should be CamelCase - a camel with two humps. In general class components will fade away in the future, therefore use only functional components ! Big picture of components In the previous section we agreed, that a website or an application is made of buttons, forms, texts, media objects, header, section, article and footer. If we have a million-dollar button, we can use this button all the time, instead of recreating it all over again, whenever we need a button. The same goes for input fields, forms, header or footer. That is where the power of the component comes. In the following diagram, the header, main and footer are components. Inside the main there is also a user card component and a text section component. All the different colors represent different components. How many colors do you see? Each color represent a single component. We have four components in this diagram, but they are reused multiple times. Creating React Components Using a JavaScript function, we can make a functional React component. This example is the most simple React Component you can image: Example function ComponentName () { return < p > Content < /p> } As we know already you can define variables and set the values in JSX: Example function Component () { const user = { firstName : 'Test' , lastName : 'Tester' , } return ( <> < p > { user . firstName } < /p> < p > { user . lastName } < /p> < /> ) } Also you can define styles in the Component: Example function Component () { const user = { firstName : 'Test' , lastName : 'Tester' , } const firstNameStyles = { fontSize : '24px' , } const lastNameStyles = { fontSize : '18px' , color : 'red' , } return ( <> < p style = { firstNameStyles } > First Name : { user . firstName } < /p> < p style = { lastNameStyles } > { user . lastName } < /p> < /> ) } If you run the example above in Babel you get following JavaScript Code: Example 'use strict' function Component () { const user = { firstName : 'Test' , lastName : 'Tester' , } const firstNameStyles = { fontSize : '24px' , } const lastNameStyles = { fontSize : '18px' , color : 'red' , } return /*#__PURE__*/ React . createElement ( React . Fragment , null , /*#__PURE__*/ React . createElement ( 'p' , { style : firstNameStyles , }, 'First Name: ' , user . firstName , ), /*#__PURE__*/ React . createElement ( 'p' , { style : lastNameStyles , }, user . lastName , ), ) } As you see, you actually call React.createElement and pass in the element name + the variables you defined. The result of the example is: Example < p style = \"font-size: 24px;\" > First Name: Test </ p > < p style = \"font-size: 18px; color: red;\" > Tester </ p > Nesting React Components Let's image you have a component, which you would like to insert into another component. Let's see this example: Example function Text () { return < p > Some Text < /p> } function Wrapper () { return ( <> { Text ()} { Text ()} { Text ()} < /> ) } Because this is not the way Components are meant for, you can actually use React Component Functions as JSX Elements. Components are made for sharing. Because of that, components should be nestable. You can use React Components as JSX Elements to render them out. Let's check a simple example first: Example function Text () { return < p > Some Text < /p> } function Wrapper () { return ( <> < Text /> < Text /> < Text /> < /> ) } output: < p > Some Text </ p > < p > Some Text </ p > < p > Some Text </ p > if you check the Babel output this is what happens: Example 'use strict' function Text () { return /*#__PURE__*/ React . createElement ( 'p' , null , 'Some Text' ) } function Wrapper () { return /*#__PURE__*/ React . createElement ( React . Fragment , null , /*#__PURE__*/ React . createElement ( Text , null ), /*#__PURE__*/ React . createElement ( Text , null ), /*#__PURE__*/ React . createElement ( Text , null ), ) } The actual function Text gets inserted into React.createElement .","title":"Components"},{"location":"react/components/#components","text":"A React component is a small, reusable code, which is responsible for one part of the application UI. A React application is an aggregation of components. React can help us to build reusable components. The following diagram shows different components. All the components have different border colors. In React we assemble different components together to create an application. We use JavaScript functions or classes to make components. If we use a function, the component will be a functional component, but if we use a class, the component will be a class-based component. Components can be: Functional Component / Presentational Component / Stateless Component / Dumb Component Class Component / Container Component / Stateful Component / Smart Component The classification of components above does not work for the latest version of React, but it is good to know the former definition and how the previous versions work. So, let us change all the JSX to components. Components in React are JavaScript functions, that return a JSX. Component name must start with an uppercase, and if the name is two words, it should be CamelCase - a camel with two humps. In general class components will fade away in the future, therefore use only functional components !","title":"Components"},{"location":"react/components/#big-picture-of-components","text":"In the previous section we agreed, that a website or an application is made of buttons, forms, texts, media objects, header, section, article and footer. If we have a million-dollar button, we can use this button all the time, instead of recreating it all over again, whenever we need a button. The same goes for input fields, forms, header or footer. That is where the power of the component comes. In the following diagram, the header, main and footer are components. Inside the main there is also a user card component and a text section component. All the different colors represent different components. How many colors do you see? Each color represent a single component. We have four components in this diagram, but they are reused multiple times.","title":"Big picture of components"},{"location":"react/components/#creating-react-components","text":"Using a JavaScript function, we can make a functional React component. This example is the most simple React Component you can image: Example function ComponentName () { return < p > Content < /p> } As we know already you can define variables and set the values in JSX: Example function Component () { const user = { firstName : 'Test' , lastName : 'Tester' , } return ( <> < p > { user . firstName } < /p> < p > { user . lastName } < /p> < /> ) } Also you can define styles in the Component: Example function Component () { const user = { firstName : 'Test' , lastName : 'Tester' , } const firstNameStyles = { fontSize : '24px' , } const lastNameStyles = { fontSize : '18px' , color : 'red' , } return ( <> < p style = { firstNameStyles } > First Name : { user . firstName } < /p> < p style = { lastNameStyles } > { user . lastName } < /p> < /> ) } If you run the example above in Babel you get following JavaScript Code: Example 'use strict' function Component () { const user = { firstName : 'Test' , lastName : 'Tester' , } const firstNameStyles = { fontSize : '24px' , } const lastNameStyles = { fontSize : '18px' , color : 'red' , } return /*#__PURE__*/ React . createElement ( React . Fragment , null , /*#__PURE__*/ React . createElement ( 'p' , { style : firstNameStyles , }, 'First Name: ' , user . firstName , ), /*#__PURE__*/ React . createElement ( 'p' , { style : lastNameStyles , }, user . lastName , ), ) } As you see, you actually call React.createElement and pass in the element name + the variables you defined. The result of the example is: Example < p style = \"font-size: 24px;\" > First Name: Test </ p > < p style = \"font-size: 18px; color: red;\" > Tester </ p >","title":"Creating React Components"},{"location":"react/components/#nesting-react-components","text":"Let's image you have a component, which you would like to insert into another component. Let's see this example: Example function Text () { return < p > Some Text < /p> } function Wrapper () { return ( <> { Text ()} { Text ()} { Text ()} < /> ) } Because this is not the way Components are meant for, you can actually use React Component Functions as JSX Elements. Components are made for sharing. Because of that, components should be nestable. You can use React Components as JSX Elements to render them out. Let's check a simple example first: Example function Text () { return < p > Some Text < /p> } function Wrapper () { return ( <> < Text /> < Text /> < Text /> < /> ) } output: < p > Some Text </ p > < p > Some Text </ p > < p > Some Text </ p > if you check the Babel output this is what happens: Example 'use strict' function Text () { return /*#__PURE__*/ React . createElement ( 'p' , null , 'Some Text' ) } function Wrapper () { return /*#__PURE__*/ React . createElement ( React . Fragment , null , /*#__PURE__*/ React . createElement ( Text , null ), /*#__PURE__*/ React . createElement ( Text , null ), /*#__PURE__*/ React . createElement ( Text , null ), ) } The actual function Text gets inserted into React.createElement .","title":"Nesting React Components"},{"location":"react/conditional_rendering/","text":"Conditional Rendering As we can understand from the term, conditional rendering is a way to render different JSX or component at different condition. We can implement conditional rendering using regular if and else statement, ternary operator and &&. Let's implement a different conditional rendering. Conditional Rendering using If and Else statement The problem with using if and else statements is that you are not allowed to use hooks afterwards. Example const Component = ({ isAllowed }) => { if ( isAllowed ) { return < p > You are allowed < /p> } return < p > You are not allowed !< /p> } An if- and else statement inside a React component is done mostly at the bottom of the component. See an example here: Example const Component = () => { const { isLoggedIn , isLoading } = React . useContext ( AuthenticationContext ) const [ someState , setSomeState ] = React . useState ( false ) if ( ! isLoggedIn ) { return < p > You are not allowed to see this < /p> } if ( ! isLoading ) { return < p > Loading ... < /p> } return ( < p onClick = {() => { setSomeState ( ! someState ) }} > Currently its : { someState } < /p> ) } Ternary operator In most cases you want to switch inside your component between different views. Therefore you will use the conditional operator the OR operator or the AND Operator . Here are some examples: Example const Component = ({ isAllowed }) => { return ( < div > < h1 > Here is a title < /h1> < p > You are { isAllowed ? 'allowed' : 'not allowed' } to enter < /p> < /div> ) } Example const Component = ({ isAllowed }) => { return ( < div > < h1 > Here is a title < /h1> < p > You are { ! isAllowed && 'not' } allowed to enter < /p> < /div> ) } Example const Component = ({ value , defaultValue }) => { return ( < div > < h1 > Here is a title < /h1> < p > { value || defaultValue } < /p> < /div> ) }","title":"Conditional Rendering"},{"location":"react/conditional_rendering/#conditional-rendering","text":"As we can understand from the term, conditional rendering is a way to render different JSX or component at different condition. We can implement conditional rendering using regular if and else statement, ternary operator and &&. Let's implement a different conditional rendering.","title":"Conditional Rendering"},{"location":"react/conditional_rendering/#conditional-rendering-using-if-and-else-statement","text":"The problem with using if and else statements is that you are not allowed to use hooks afterwards. Example const Component = ({ isAllowed }) => { if ( isAllowed ) { return < p > You are allowed < /p> } return < p > You are not allowed !< /p> } An if- and else statement inside a React component is done mostly at the bottom of the component. See an example here: Example const Component = () => { const { isLoggedIn , isLoading } = React . useContext ( AuthenticationContext ) const [ someState , setSomeState ] = React . useState ( false ) if ( ! isLoggedIn ) { return < p > You are not allowed to see this < /p> } if ( ! isLoading ) { return < p > Loading ... < /p> } return ( < p onClick = {() => { setSomeState ( ! someState ) }} > Currently its : { someState } < /p> ) }","title":"Conditional Rendering using If and Else statement"},{"location":"react/conditional_rendering/#ternary-operator","text":"In most cases you want to switch inside your component between different views. Therefore you will use the conditional operator the OR operator or the AND Operator . Here are some examples: Example const Component = ({ isAllowed }) => { return ( < div > < h1 > Here is a title < /h1> < p > You are { isAllowed ? 'allowed' : 'not allowed' } to enter < /p> < /div> ) } Example const Component = ({ isAllowed }) => { return ( < div > < h1 > Here is a title < /h1> < p > You are { ! isAllowed && 'not' } allowed to enter < /p> < /div> ) } Example const Component = ({ value , defaultValue }) => { return ( < div > < h1 > Here is a title < /h1> < p > { value || defaultValue } < /p> < /div> ) }","title":"Ternary operator"},{"location":"react/context/","text":"Context Context is a very important tool to pass states and props to underlying components.","title":"Context"},{"location":"react/context/#context","text":"Context is a very important tool to pass states and props to underlying components.","title":"Context"},{"location":"react/controlled_versus_uncontrolled/","text":"Controlled vs. Uncontrolled If a React component has an element which changes by itself, it's called uncontrolled. If you handle the rendering with React it's called controlled. Examples Controlled You influence controlled inputs by using state and props. Uncontrolled You can influence uncontrolled inputs by using ref and manipulating the DOM element directly. Pitfalls It often happens, when you define a state with an empty default value and use this state as value for your input field. Then you set this state via the onChange method of the input field. What happens then is that a value is being set from undefined -> string . If a prop is undefined it's not defined and there it won't be considered in the DOM element. If you then set the prop the element changes from an uncontrolled to a controlled element. React warns you about this problem. Enter text in the following textfield and check the console.","title":"Controlled vs. Uncontrolled"},{"location":"react/controlled_versus_uncontrolled/#controlled-vs-uncontrolled","text":"If a React component has an element which changes by itself, it's called uncontrolled. If you handle the rendering with React it's called controlled.","title":"Controlled vs. Uncontrolled"},{"location":"react/controlled_versus_uncontrolled/#examples","text":"","title":"Examples"},{"location":"react/controlled_versus_uncontrolled/#controlled","text":"You influence controlled inputs by using state and props.","title":"Controlled"},{"location":"react/controlled_versus_uncontrolled/#uncontrolled","text":"You can influence uncontrolled inputs by using ref and manipulating the DOM element directly.","title":"Uncontrolled"},{"location":"react/controlled_versus_uncontrolled/#pitfalls","text":"It often happens, when you define a state with an empty default value and use this state as value for your input field. Then you set this state via the onChange method of the input field. What happens then is that a value is being set from undefined -> string . If a prop is undefined it's not defined and there it won't be considered in the DOM element. If you then set the prop the element changes from an uncontrolled to a controlled element. React warns you about this problem. Enter text in the following textfield and check the console.","title":"Pitfalls"},{"location":"react/custom_hooks/","text":"Custom Hooks Lets image you want to have a scroll tracker in a lot of components, but you don't want to implement it in every component. Therefore you can implement a custom hook to outsource the logic and have a \"reactive\" hook.","title":"Custom Hooks"},{"location":"react/custom_hooks/#custom-hooks","text":"Lets image you want to have a scroll tracker in a lot of components, but you don't want to implement it in every component. Therefore you can implement a custom hook to outsource the logic and have a \"reactive\" hook.","title":"Custom Hooks"},{"location":"react/events/","text":"Events What is an event? An event is an action or occurrence recognized by a software. To make an event more clear let's use the daily activities we do when we use a computer such as clicking on a button, hover on an image, pressing a keyboard, scrolling the mouse wheel and etc. The react documentation has already a detail note about events . Handling events in React is very similar to handling elements on DOM elements using pure JavaScript. Some of the syntax difference between handling event in React and pure JavaScript: React events are named using camelCase, rather than lowercase. With JSX you pass a function as the event handler, rather than a string. Lets check an example first: Example function App () { const greetPeople = ( event ) => { alert ( 'Welcome' ) } return < button onClick = { greetPeople } > Welcome < /button> } However, in React it could be as follows: Overview Event Type/Category: Events: Event Specific Properties: Clipboard onCopy, onCut, onPaste DOMDataTransfer, clipboardData Composition onCompositionEnd, onCompositionStart, onCompositionUpdate data Keyboard onKeyDown, onKeyPress, onKeyUp altKey, charCode, ctrlKey, getModifierState(key), key, keyCode, locale, location, metaKey, repeat, shiftKey, which Focus onChange, onInput, onSubmit DOMEventTarget, relatedTarget Form onFocus, onBlur Mouse onClick, onContextMenu, onDoubleClick, onDrag, onDragEnd, onDragEnter, onDragExit, onDragLeave, onDragOver, onDragStart, onDrop, onMouseDown, onMouseEnter, onMouseLeave, onMouseMove, onMouseOut, onMouseOver, onMouseUp altKey, button, buttons, clientX, clientY, ctrlKey, getModifierState(key), metaKey, pageX, pageY, DOMEventTarget relatedTarget, screenX, screenY, shiftKey Selection onSelect Touch onTouchCancel, onTouchEnd, onTouchMove, onTouchStart altKey DOMTouchList changedTouches, ctrlKey, getModifierState(key), metaKey, shiftKey, DOMTouchList targetTouches, DOMTouchList touches UI onScroll detail, DOMAbstractView view Wheel onWheel deltaMode, deltaX, deltaY, deltaZ Media onAbort, onCanPlay, onCanPlayThrough, onDurationChange, onEmptied, onEncrypted, onEnded, onError, onLoadedData, onLoadedMetadata, onLoadStart, onPause, onPlay, onPlaying, onProgress, onRateChange, onSeeked, onSeeking, onStalled, onSuspend, onTimeUpdate, onVolumeChange, onWaiting Image onLoad, onError Animation onAnimationStart, onAnimationEnd, onAnimationIteration animationName, pseudoElement, elapsedTime Transition onTransitionEnd propertyName, pseudoElement, elapsedTime","title":"Events"},{"location":"react/events/#events","text":"","title":"Events"},{"location":"react/events/#what-is-an-event","text":"An event is an action or occurrence recognized by a software. To make an event more clear let's use the daily activities we do when we use a computer such as clicking on a button, hover on an image, pressing a keyboard, scrolling the mouse wheel and etc. The react documentation has already a detail note about events . Handling events in React is very similar to handling elements on DOM elements using pure JavaScript. Some of the syntax difference between handling event in React and pure JavaScript: React events are named using camelCase, rather than lowercase. With JSX you pass a function as the event handler, rather than a string. Lets check an example first: Example function App () { const greetPeople = ( event ) => { alert ( 'Welcome' ) } return < button onClick = { greetPeople } > Welcome < /button> } However, in React it could be as follows:","title":"What is an event?"},{"location":"react/events/#overview","text":"Event Type/Category: Events: Event Specific Properties: Clipboard onCopy, onCut, onPaste DOMDataTransfer, clipboardData Composition onCompositionEnd, onCompositionStart, onCompositionUpdate data Keyboard onKeyDown, onKeyPress, onKeyUp altKey, charCode, ctrlKey, getModifierState(key), key, keyCode, locale, location, metaKey, repeat, shiftKey, which Focus onChange, onInput, onSubmit DOMEventTarget, relatedTarget Form onFocus, onBlur Mouse onClick, onContextMenu, onDoubleClick, onDrag, onDragEnd, onDragEnter, onDragExit, onDragLeave, onDragOver, onDragStart, onDrop, onMouseDown, onMouseEnter, onMouseLeave, onMouseMove, onMouseOut, onMouseOver, onMouseUp altKey, button, buttons, clientX, clientY, ctrlKey, getModifierState(key), metaKey, pageX, pageY, DOMEventTarget relatedTarget, screenX, screenY, shiftKey Selection onSelect Touch onTouchCancel, onTouchEnd, onTouchMove, onTouchStart altKey DOMTouchList changedTouches, ctrlKey, getModifierState(key), metaKey, shiftKey, DOMTouchList targetTouches, DOMTouchList touches UI onScroll detail, DOMAbstractView view Wheel onWheel deltaMode, deltaX, deltaY, deltaZ Media onAbort, onCanPlay, onCanPlayThrough, onDurationChange, onEmptied, onEncrypted, onEnded, onError, onLoadedData, onLoadedMetadata, onLoadStart, onPause, onPlay, onPlaying, onProgress, onRateChange, onSeeked, onSeeking, onStalled, onSuspend, onTimeUpdate, onVolumeChange, onWaiting Image onLoad, onError Animation onAnimationStart, onAnimationEnd, onAnimationIteration animationName, pseudoElement, elapsedTime Transition onTransitionEnd propertyName, pseudoElement, elapsedTime","title":"Overview"},{"location":"react/fetch_and_useQuery/","text":"Requests and Responses To retrieve data from a server, you can use HTTP. The browser has already a pretty \"okayish\" request client called fetch . There is a nice library, which is used in many projects, called React Query . Fetch React Query","title":"Requests and Responses"},{"location":"react/fetch_and_useQuery/#requests-and-responses","text":"To retrieve data from a server, you can use HTTP. The browser has already a pretty \"okayish\" request client called fetch . There is a nice library, which is used in many projects, called React Query .","title":"Requests and Responses"},{"location":"react/fetch_and_useQuery/#fetch","text":"","title":"Fetch"},{"location":"react/fetch_and_useQuery/#react-query","text":"","title":"React Query"},{"location":"react/forms/","text":"Forms Forms are important to save input from a user and JavaScript was introduced back in the late 90s, to validate input data. Let's first check an example: React Hook Forms React Hook Forms is the goto library for React forms Link . It brings a lot of nice functionality like error handling, states and watches.","title":"Forms"},{"location":"react/forms/#forms","text":"Forms are important to save input from a user and JavaScript was introduced back in the late 90s, to validate input data. Let's first check an example:","title":"Forms"},{"location":"react/forms/#react-hook-forms","text":"React Hook Forms is the goto library for React forms Link . It brings a lot of nice functionality like error handling, states and watches.","title":"React Hook Forms"},{"location":"react/getting_started/","text":"Getting Started This section covers prerequisites to get started with React. You should have a good understanding of the following technologies: HTML CSS JavaScript What is React? React is a JavaScript library for building a reusable user interface(UI). It was initially released on May 29, 2013. The current version is 18.x.x and it is stable. React was created by Facebook. React makes creating UI components very easy. The official React documentation can be found here . When we work with React we do not interact directly with the DOM. React has its own way to handle the DOM(Document Object Model) manipulation. React uses its virtual DOM to make new changes and it updates only the element, that needs changing. Do not directly interact with DOM when you build a React Application and leave the DOM manipulation job for the React virtual DOM. A web application, or a website, is made of buttons, links, forms with different input fields, header, footer, sections, articles, texts, images, audios, videos and boxes with different shapes. We use react to make a reusable UI components of a website. To summarize: React was released in May 2013 React was created by Facebook React is a JavaScript library for building user interfaces React is used to build single page applications - An application which has only one HTML page. React allows us to create reusable UI components React latest release is 18.x.x React versions React official documentation can be found here Why React? React is one of the most popular JavaScript libraries. Many developers and companies have been using it for the last couple of years. Its popularity has been growing fast and it has a huge community. How do we measure popularity? One measure of popularity could be GitHub repository stars, watchers and forks. Let us compare the popularity of React and Vue . As of today, the popularity between the two most popular JavaScript looks like as shown on the diagram. From the diagram, you can speculate the most popular JavaScript library. You may look at the number of watchers, stars and forks for both React and Vue. These alone will not be a very good measure of popularity, but still it tells a little bit about the popularity of the two technologies. If I have to recommend another JavaScript library next to React, it would be Vue.js. React vs Vue vs Angular popularity in October 2022 React Official GitHub Repository Vue Official GitHub Repository Angular Official GitHub Repository Why we choose to use React? fast modular scalable flexible big community and popular open source High job opportunity most used JavaScript rendering library","title":"Getting Started"},{"location":"react/getting_started/#getting-started","text":"This section covers prerequisites to get started with React. You should have a good understanding of the following technologies: HTML CSS JavaScript","title":"Getting Started"},{"location":"react/getting_started/#what-is-react","text":"React is a JavaScript library for building a reusable user interface(UI). It was initially released on May 29, 2013. The current version is 18.x.x and it is stable. React was created by Facebook. React makes creating UI components very easy. The official React documentation can be found here . When we work with React we do not interact directly with the DOM. React has its own way to handle the DOM(Document Object Model) manipulation. React uses its virtual DOM to make new changes and it updates only the element, that needs changing. Do not directly interact with DOM when you build a React Application and leave the DOM manipulation job for the React virtual DOM. A web application, or a website, is made of buttons, links, forms with different input fields, header, footer, sections, articles, texts, images, audios, videos and boxes with different shapes. We use react to make a reusable UI components of a website. To summarize: React was released in May 2013 React was created by Facebook React is a JavaScript library for building user interfaces React is used to build single page applications - An application which has only one HTML page. React allows us to create reusable UI components React latest release is 18.x.x React versions React official documentation can be found here","title":"What is React?"},{"location":"react/getting_started/#why-react","text":"React is one of the most popular JavaScript libraries. Many developers and companies have been using it for the last couple of years. Its popularity has been growing fast and it has a huge community. How do we measure popularity? One measure of popularity could be GitHub repository stars, watchers and forks. Let us compare the popularity of React and Vue . As of today, the popularity between the two most popular JavaScript looks like as shown on the diagram. From the diagram, you can speculate the most popular JavaScript library. You may look at the number of watchers, stars and forks for both React and Vue. These alone will not be a very good measure of popularity, but still it tells a little bit about the popularity of the two technologies. If I have to recommend another JavaScript library next to React, it would be Vue.js.","title":"Why React?"},{"location":"react/getting_started/#react-vs-vue-vs-angular-popularity-in-october-2022","text":"React Official GitHub Repository Vue Official GitHub Repository Angular Official GitHub Repository Why we choose to use React? fast modular scalable flexible big community and popular open source High job opportunity most used JavaScript rendering library","title":"React vs Vue vs Angular popularity in October 2022"},{"location":"react/hooks/","text":"React Hooks Hooks are a new addition in React 16.8. They allow you use state, life cycle methods and other React features without writing a class component. If we are using hooks we can have only a functional component in the entire application. For more detail explanation you check React documentation . Different hooks have been introduced to React: Basic hooks and additional hooks Basic Hooks The basic hooks are: useState useEffect useContext State Hook Using hooks we can access state. To use hooks, first we should import the useState hooks from react. The useState is a function which takes one argument (the initial value) and returns an array of the current state and a function that lets you update it. State with Data Types If you use useState with primitive data types, there is no problem by using operators to set the state with the current value, like in our example above. But if you use non-primitive data types you can't just change the value and set it, you have to create a \"new\" object or copy the old one and set it: Here is a bad example, which won't work: Here is the fixed example: The same happens to arrays: Here is the fixed examle: When a state changes, React will check if the state is used somewhere and update the element . Effect Hook Effects happen, when a state or a prop changes. To watch for changes and do a sideeffect (not computing a value or not preparing a callback) you can use useEffect . Context useContext will be discussed later in the Context chapter. Additional Hooks Additional Hooks can be used to express specific statements or to speed up your code. useReducer useCallback useMemo useRef useImperativeHandle useLayoutEffect useDebugValue useDeferredValue useTransition useId Reducer Reducer are handy if you have multiple actions for the same state. For example, if you work on the same state with different functions, then a reducer can be used to define the actions on a state in one place: Callbacks Callbacks are important to pass a behaviour into a component from an outer scope. Let's check this example first: You see that an update of our states results in an update for our buttons. Let's improve the code by using useCallback to listen for specific changes: Now the buttons does not update if the other button gets clicked. This can lead to massive performance improvements. Memo If you have some operations, which take a lot of computing time, useMemo . Actually I would say, use always useMemo if you calculate something depending on a state or prop. Here is a bad example: Here we use useMemo , additionally we define the dependency: Ref What if you need to access to the actual html element in the dom, to call a function on the element? You can useRef for that: Imperative Handle Layout Effect useLayoutEffect works the same way useEffect works. The signature is identical to useEffect, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint. Debug Value useDebugValue shows a value in React DevTools. function useFriendStatus ( friendID ) { const [ isOnline , setIsOnline ] = useState ( null ); // Show a label in DevTools next to this Hook // e.g. \"FriendStatus: Online\" useDebugValue ( isOnline ? \"Online\" : \"Offline\" ); return isOnline ; } Deferred Value useDeferredValue receives a state variable and returns a new state variable, which will wait until all rendering finishes for the given state variable and then rerenders the deferred value. function Typeahead () { const query = useSearchQuery ( \"\" ); const deferredQuery = useDeferredValue ( query ); // Memoizing tells React to only re-render when deferredQuery changes, // not when query changes. const suggestions = useMemo ( () => < SearchSuggestions query = { deferredQuery } /> , [ deferredQuery ] ); return ( <> < SearchInput query = { query } /> < Suspense fallback = \"Loading results...\" > { suggestions } < /Suspense> < /> ); } Transition useTransition can handle loading states. ID useId is a hook for generating unique IDs that are stable across the server and client, while avoiding hydration mismatches. Warning useId is not for generating keys in a list. Keys should be generated from your data. function Checkbox () { const id = useId (); return ( <> < label htmlFor = { id } > Do you like React ?< /label> < input id = { id } type = \"checkbox\" name = \"react\" /> < /> ); }","title":"React Hooks"},{"location":"react/hooks/#react-hooks","text":"Hooks are a new addition in React 16.8. They allow you use state, life cycle methods and other React features without writing a class component. If we are using hooks we can have only a functional component in the entire application. For more detail explanation you check React documentation . Different hooks have been introduced to React: Basic hooks and additional hooks","title":"React Hooks"},{"location":"react/hooks/#basic-hooks","text":"The basic hooks are: useState useEffect useContext","title":"Basic Hooks"},{"location":"react/hooks/#state-hook","text":"Using hooks we can access state. To use hooks, first we should import the useState hooks from react. The useState is a function which takes one argument (the initial value) and returns an array of the current state and a function that lets you update it.","title":"State Hook"},{"location":"react/hooks/#state-with-data-types","text":"If you use useState with primitive data types, there is no problem by using operators to set the state with the current value, like in our example above. But if you use non-primitive data types you can't just change the value and set it, you have to create a \"new\" object or copy the old one and set it: Here is a bad example, which won't work: Here is the fixed example: The same happens to arrays: Here is the fixed examle: When a state changes, React will check if the state is used somewhere and update the element .","title":"State with Data Types"},{"location":"react/hooks/#effect-hook","text":"Effects happen, when a state or a prop changes. To watch for changes and do a sideeffect (not computing a value or not preparing a callback) you can use useEffect .","title":"Effect Hook"},{"location":"react/hooks/#context","text":"useContext will be discussed later in the Context chapter.","title":"Context"},{"location":"react/hooks/#additional-hooks","text":"Additional Hooks can be used to express specific statements or to speed up your code. useReducer useCallback useMemo useRef useImperativeHandle useLayoutEffect useDebugValue useDeferredValue useTransition useId","title":"Additional Hooks"},{"location":"react/hooks/#reducer","text":"Reducer are handy if you have multiple actions for the same state. For example, if you work on the same state with different functions, then a reducer can be used to define the actions on a state in one place:","title":"Reducer"},{"location":"react/hooks/#callbacks","text":"Callbacks are important to pass a behaviour into a component from an outer scope. Let's check this example first: You see that an update of our states results in an update for our buttons. Let's improve the code by using useCallback to listen for specific changes: Now the buttons does not update if the other button gets clicked. This can lead to massive performance improvements.","title":"Callbacks"},{"location":"react/hooks/#memo","text":"If you have some operations, which take a lot of computing time, useMemo . Actually I would say, use always useMemo if you calculate something depending on a state or prop. Here is a bad example: Here we use useMemo , additionally we define the dependency:","title":"Memo"},{"location":"react/hooks/#ref","text":"What if you need to access to the actual html element in the dom, to call a function on the element? You can useRef for that:","title":"Ref"},{"location":"react/hooks/#imperative-handle","text":"","title":"Imperative Handle"},{"location":"react/hooks/#layout-effect","text":"useLayoutEffect works the same way useEffect works. The signature is identical to useEffect, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint.","title":"Layout Effect"},{"location":"react/hooks/#debug-value","text":"useDebugValue shows a value in React DevTools. function useFriendStatus ( friendID ) { const [ isOnline , setIsOnline ] = useState ( null ); // Show a label in DevTools next to this Hook // e.g. \"FriendStatus: Online\" useDebugValue ( isOnline ? \"Online\" : \"Offline\" ); return isOnline ; }","title":"Debug Value"},{"location":"react/hooks/#deferred-value","text":"useDeferredValue receives a state variable and returns a new state variable, which will wait until all rendering finishes for the given state variable and then rerenders the deferred value. function Typeahead () { const query = useSearchQuery ( \"\" ); const deferredQuery = useDeferredValue ( query ); // Memoizing tells React to only re-render when deferredQuery changes, // not when query changes. const suggestions = useMemo ( () => < SearchSuggestions query = { deferredQuery } /> , [ deferredQuery ] ); return ( <> < SearchInput query = { query } /> < Suspense fallback = \"Loading results...\" > { suggestions } < /Suspense> < /> ); }","title":"Deferred Value"},{"location":"react/hooks/#transition","text":"useTransition can handle loading states.","title":"Transition"},{"location":"react/hooks/#id","text":"useId is a hook for generating unique IDs that are stable across the server and client, while avoiding hydration mismatches. Warning useId is not for generating keys in a list. Keys should be generated from your data. function Checkbox () { const id = useId (); return ( <> < label htmlFor = { id } > Do you like React ?< /label> < input id = { id } type = \"checkbox\" name = \"react\" /> < /> ); }","title":"ID"},{"location":"react/jsx/","text":"JSX JSX stands for JavaScript XML . JSX allows us to write HTML elements with JavaScript code. An HTML element has an opening and closing tags, content, and attribute in the opening tag. However, some HTML elements may not have content and a closing tag - they are self closing elements. To create HTML elements in React we do not use the createElement() instead we just use JSX elements. Therefore, JSX makes it easier to write and add HTML elements in React. JSX will be converted to JavaScript on browser using a transpiler - babel.js . Babel is a library which transpiles JSX to pure JavaScript and latest JavaScript to older version. See the JSX code below. In conclusion with Babel this: Example const a = < h1 id = \"123\" > test < /h1> becomes this: Example 'use strict' const a = /*#__PURE__*/ React . createElement ( 'h1' , { id : '123' , }, 'test' , ) JSX is stricter than html. If you write for example <br> in HTML this becomes valid. If you write the same in JSX, it will throw an error. Therefore you have to close every element properly: Example < br /> Expressions in JSX If you work with JSX, you can use expressions to inject values into jsx code: Example const value = 123 const element = < p > { value } < /p> < p > 123 </ p > Expressions produce values . According to MDN an expression is: An expression is any valid unit of code that resolves to a value. Do not confuse it with statements which produce code statements, assignments and expressions. Statements Expressions let a = 1 + 2 1 + 2 if (1 === 2) { return 3 } else { return 4 } 1 === 2 ? 3 : 4 For example, you can also use the result of a function inside of jsx: Example function formatName ( user ) { return ` ${ user . firstName } ${ user . lastName } ` } const user = { firstName : 'Test' , lastName : 'Tester' , } const element = < h1 > Hello , { formatName ( user )} ! < /h1> result < h1 > Hello, Test Tester </ h1 > Attributes in JSX You can specify attributes in JSX: Example const h1Id = 'testId' const element = < h1 id = { h1Id } > Test < /h1> Warning Since JSX is closer to JavaScript than to HTML, React DOM uses camelCase property naming convention instead of HTML attribute names. For example, class becomes className in JSX, and tabindex becomes tabIndex. Children in JSX We discussed simple elements for now. But when HTML elements can have children, JSX elements can have them too: Example const container = ( < div > < h1 > Hello World < /h1> < p > Some text < /p> < /div> ) Warning Do not use nested elements without paranthesis. This is a false example: const container = < div > < h1 > Hello World < /h1> < p > Some text < /p> < /div> Warning Note that you cannot use multiple elements as JSX: // this won't work! const container = ( < h1 > Hello World < /h1> < p > Some text < /p> ) You have to wrap multiple elements into an outer element. This can be another html element or the 'empty' element <>... For example: Example const container = ( < div > < h1 > Hello World < /h1> < p > Some text < /p> < /div> ) will result as HTML in the DOM as: result < div > < h1 > Hello World </ h1 > < p > Some text </ p > </ div > Example const container = ( <> < h1 > Hello World < /h1> < p > Some text < /p> < /> ) will result als HTML in the DOM as: result < h1 > Hello World </ h1 > < p > Some text </ p > Adding styles If you want to add a style to a JSX element, you can use className (instead of the html class ) or style . Please note, that style will be overwritten by Babel so that you cannot use just a string, but you use an object: Example const container = ( < p style = {{ color : 'red' , fontSize : '' }} className = { 'bordered' } > abc < /p> )","title":"JSX"},{"location":"react/jsx/#jsx","text":"JSX stands for JavaScript XML . JSX allows us to write HTML elements with JavaScript code. An HTML element has an opening and closing tags, content, and attribute in the opening tag. However, some HTML elements may not have content and a closing tag - they are self closing elements. To create HTML elements in React we do not use the createElement() instead we just use JSX elements. Therefore, JSX makes it easier to write and add HTML elements in React. JSX will be converted to JavaScript on browser using a transpiler - babel.js . Babel is a library which transpiles JSX to pure JavaScript and latest JavaScript to older version. See the JSX code below. In conclusion with Babel this: Example const a = < h1 id = \"123\" > test < /h1> becomes this: Example 'use strict' const a = /*#__PURE__*/ React . createElement ( 'h1' , { id : '123' , }, 'test' , ) JSX is stricter than html. If you write for example <br> in HTML this becomes valid. If you write the same in JSX, it will throw an error. Therefore you have to close every element properly: Example < br />","title":"JSX"},{"location":"react/jsx/#expressions-in-jsx","text":"If you work with JSX, you can use expressions to inject values into jsx code: Example const value = 123 const element = < p > { value } < /p> < p > 123 </ p > Expressions produce values . According to MDN an expression is: An expression is any valid unit of code that resolves to a value. Do not confuse it with statements which produce code statements, assignments and expressions. Statements Expressions let a = 1 + 2 1 + 2 if (1 === 2) { return 3 } else { return 4 } 1 === 2 ? 3 : 4 For example, you can also use the result of a function inside of jsx: Example function formatName ( user ) { return ` ${ user . firstName } ${ user . lastName } ` } const user = { firstName : 'Test' , lastName : 'Tester' , } const element = < h1 > Hello , { formatName ( user )} ! < /h1> result < h1 > Hello, Test Tester </ h1 >","title":"Expressions in JSX"},{"location":"react/jsx/#attributes-in-jsx","text":"You can specify attributes in JSX: Example const h1Id = 'testId' const element = < h1 id = { h1Id } > Test < /h1> Warning Since JSX is closer to JavaScript than to HTML, React DOM uses camelCase property naming convention instead of HTML attribute names. For example, class becomes className in JSX, and tabindex becomes tabIndex.","title":"Attributes in JSX"},{"location":"react/jsx/#children-in-jsx","text":"We discussed simple elements for now. But when HTML elements can have children, JSX elements can have them too: Example const container = ( < div > < h1 > Hello World < /h1> < p > Some text < /p> < /div> ) Warning Do not use nested elements without paranthesis. This is a false example: const container = < div > < h1 > Hello World < /h1> < p > Some text < /p> < /div> Warning Note that you cannot use multiple elements as JSX: // this won't work! const container = ( < h1 > Hello World < /h1> < p > Some text < /p> ) You have to wrap multiple elements into an outer element. This can be another html element or the 'empty' element <>... For example: Example const container = ( < div > < h1 > Hello World < /h1> < p > Some text < /p> < /div> ) will result as HTML in the DOM as: result < div > < h1 > Hello World </ h1 > < p > Some text </ p > </ div > Example const container = ( <> < h1 > Hello World < /h1> < p > Some text < /p> < /> ) will result als HTML in the DOM as: result < h1 > Hello World </ h1 > < p > Some text </ p >","title":"Children in JSX"},{"location":"react/jsx/#adding-styles","text":"If you want to add a style to a JSX element, you can use className (instead of the html class ) or style . Please note, that style will be overwritten by Babel so that you cannot use just a string, but you use an object: Example const container = ( < p style = {{ color : 'red' , fontSize : '' }} className = { 'bordered' } > abc < /p> )","title":"Adding styles"},{"location":"react/openapi/","text":"OpenAPI (Swagger) If you have a Swagger file you can generate code by use openapi-generator Install openapi-generator according to the Getting Started . You can generate an openapi client by using this: openapi-generator-cli generate -g javascript -o out -i https://webeng.mi.hs-rm.de/docs/json","title":"OpenAPI (Swagger)"},{"location":"react/openapi/#openapi-swagger","text":"If you have a Swagger file you can generate code by use openapi-generator Install openapi-generator according to the Getting Started . You can generate an openapi client by using this: openapi-generator-cli generate -g javascript -o out -i https://webeng.mi.hs-rm.de/docs/json","title":"OpenAPI (Swagger)"},{"location":"react/project_structure/","text":"Project Structure","title":"Project Structure"},{"location":"react/project_structure/#project-structure","text":"","title":"Project Structure"},{"location":"react/props/","text":"Props What is props? w Props is a special keyword in React that stands for properties and is being used to pass data from one component to another and mostly from parent component to child component. We can say props is a data carrier or a means to transport data. I hope you are familiar with the JavaScript function. Most of the time, functions with parameters are smart and they can take dynamic data likewise props is a way we pass data or parameter to a component. Let's see the difference between a function and a component. In a React component function you will always get the first parameter as an object, which represents your Example // JavaScript const getUserInfo = ( firstName , lastName , country ) => { return ` ${ firstName } ${ lastName } . Lives in ${ country } .` } const userInfo = getUserInfo ( 'Test' , 'Tester' , 'Finland' ) // JSX function User ( props ) { return ( < div > < h1 > { props . firstName } { props . lastName } < /h1> < small > { props . country } < /small> < /div> ) } const renderedUser = ( < User firstName = { 'Test' } lastName = { 'Tester' } country = { 'Finland' } /> ) React passing `props` into JSX Element Children If you nest JSX Elements you can decide how to wrap the child elements of your component. The word children is a reserved keyword to pass in the child elements into your component. You can pick elements and render them separately or render them all at one (which is the most common case) Example function User ( props ) { return ( < div > { props . children } < /div> ) } const renderedUser = ( < User > < p > Test < /p> < p > Tester < /p> < /User> ) the result is: < div > < p > Test </ p > < p > Tester </ p > </ div > Different data type props String props type Strings are easy to pass into components Example function Component ( props ) { return < div > { props . text } < /div> } const component = < Component text = { 'Hello World!' } /> the result is: < div > Hello World! </ div > Number props type Let's use a number props to a component Example function Component ( props ) { return < div > { props . year } < /div> } const component = < Component year = { 2022 } /> the result is: < div > 2022 </ div > Boolean props type We can pass boolean data types to a React component. Example function Component ( props ) { return < div > { props . isChecked } < /div> } const component = < Component isChecked = { true } /> the result is: < div ></ div > Boolean types do not get rendered with their .toString() method. Therefore you have to set the value, which should be rendered. Example function Component ( props ) { return < div > { props . isChecked ? 'is checked' : 'not checked' } < /div> } const component = < Component isChecked = { true } /> the result is: < div > is checked </ div > Array props type In programming arrays and objects are the most frequently used data structure to solve different problems and store data in a more structured way. Therefore, we encounter data in the form of an array quite often. Let's pass an array as props to a component Example function Component ( props ) { return < div > { props . skills } < /div> } const component = < Component skills = {[ 'HTML' , 'CSS' , 'JavaScript' ]} /> the result is: < div > HTMLCSSJavaScript </ div > In this case, react tries to iterate over the array and render each element. In the example above we are lucky, because we have only strings. If we would use something not renderable like a boolean, React wouldn't show anything. Example function Component ( props ) { return < div > { props . skills } < /div> } const component = < Component skills = {[ true , false , true ]} /> the result is: < div ></ div > In the most cases you would wrap each element in a HTML element or prerender the given array elements: Wrap each array element in a HTML element function Component ( props ) { return < ul > { props . skills . map (( skill ) => < li > { skill } < /li>)}</ul> } const component = < Component skills = {[ 'HTML' , 'CSS' , 'JavaScrip' ]} /> the result is: < ul > < li > HTML </ li > < li > CSS </ li > < li > JavaScript </ li > </ ul > Render prerendered JSX element function Component ( props ) { return < ul > { props . skills } < /ul> } const component = < Component skills = {[ < li > HTML < /li>, <li>CSS</li>, <li>JavaScript</li>]} /> the result is: < ul > < li > HTML </ li > < li > CSS </ li > < li > JavaScript </ li > </ ul > Object props type We may pass an object as props to a React component. Let's see an example. Example function Component ( props ) { return < p > { props . user . firstName } { props . user . lastName } < /p> } const component = < Component user = {{ firstName : 'Test' , lastName : 'Tester' }} /> the result is: < p > Test Tester </ p > When we use an object as props we usually destructure the data to access the values. Destructuring makes our code easy to read. Example function Component ( props ) { const { firstName , lastName } = props . user return < p > { firstName } { lastName } < /p> } const component = < Component user = {{ firstName : 'Test' , lastName : 'Tester' }} /> the result is: < p > Test Tester </ p > Function prop types We can pass a function as props type to a React component. Functions passed in React Compoents are often used as callbacks Let's see some examples Example function Component ( props ) { return < p > { props . callback ()} < /p> } const component = < Component callback = {() => 'Hello World' } /> the result is: < p > Hello World </ p > Default Props You can define default or optional props, by assigning values or defining undefined to them: Example function Component ({ firstName = 'Default' , lastName = 'Default' }) { return ( < p > { firstName } { lastName } < /p> ); } const component = ( < Component firstName = { 'Test' } lastName = { 'Tester' } /> ); const defaultComponent = < Component /> ; the result is: < p > Test Tester </ p > < p > Default Default </ p >","title":"Props"},{"location":"react/props/#props","text":"","title":"Props"},{"location":"react/props/#what-is-props","text":"w Props is a special keyword in React that stands for properties and is being used to pass data from one component to another and mostly from parent component to child component. We can say props is a data carrier or a means to transport data. I hope you are familiar with the JavaScript function. Most of the time, functions with parameters are smart and they can take dynamic data likewise props is a way we pass data or parameter to a component. Let's see the difference between a function and a component. In a React component function you will always get the first parameter as an object, which represents your Example // JavaScript const getUserInfo = ( firstName , lastName , country ) => { return ` ${ firstName } ${ lastName } . Lives in ${ country } .` } const userInfo = getUserInfo ( 'Test' , 'Tester' , 'Finland' ) // JSX function User ( props ) { return ( < div > < h1 > { props . firstName } { props . lastName } < /h1> < small > { props . country } < /small> < /div> ) } const renderedUser = ( < User firstName = { 'Test' } lastName = { 'Tester' } country = { 'Finland' } /> ) React passing `props` into JSX Element","title":"What is props?"},{"location":"react/props/#children","text":"If you nest JSX Elements you can decide how to wrap the child elements of your component. The word children is a reserved keyword to pass in the child elements into your component. You can pick elements and render them separately or render them all at one (which is the most common case) Example function User ( props ) { return ( < div > { props . children } < /div> ) } const renderedUser = ( < User > < p > Test < /p> < p > Tester < /p> < /User> ) the result is: < div > < p > Test </ p > < p > Tester </ p > </ div >","title":"Children"},{"location":"react/props/#different-data-type-props","text":"","title":"Different data type props"},{"location":"react/props/#string-props-type","text":"Strings are easy to pass into components Example function Component ( props ) { return < div > { props . text } < /div> } const component = < Component text = { 'Hello World!' } /> the result is: < div > Hello World! </ div >","title":"String props type"},{"location":"react/props/#number-props-type","text":"Let's use a number props to a component Example function Component ( props ) { return < div > { props . year } < /div> } const component = < Component year = { 2022 } /> the result is: < div > 2022 </ div >","title":"Number props type"},{"location":"react/props/#boolean-props-type","text":"We can pass boolean data types to a React component. Example function Component ( props ) { return < div > { props . isChecked } < /div> } const component = < Component isChecked = { true } /> the result is: < div ></ div > Boolean types do not get rendered with their .toString() method. Therefore you have to set the value, which should be rendered. Example function Component ( props ) { return < div > { props . isChecked ? 'is checked' : 'not checked' } < /div> } const component = < Component isChecked = { true } /> the result is: < div > is checked </ div >","title":"Boolean props type"},{"location":"react/props/#array-props-type","text":"In programming arrays and objects are the most frequently used data structure to solve different problems and store data in a more structured way. Therefore, we encounter data in the form of an array quite often. Let's pass an array as props to a component Example function Component ( props ) { return < div > { props . skills } < /div> } const component = < Component skills = {[ 'HTML' , 'CSS' , 'JavaScript' ]} /> the result is: < div > HTMLCSSJavaScript </ div > In this case, react tries to iterate over the array and render each element. In the example above we are lucky, because we have only strings. If we would use something not renderable like a boolean, React wouldn't show anything. Example function Component ( props ) { return < div > { props . skills } < /div> } const component = < Component skills = {[ true , false , true ]} /> the result is: < div ></ div > In the most cases you would wrap each element in a HTML element or prerender the given array elements: Wrap each array element in a HTML element function Component ( props ) { return < ul > { props . skills . map (( skill ) => < li > { skill } < /li>)}</ul> } const component = < Component skills = {[ 'HTML' , 'CSS' , 'JavaScrip' ]} /> the result is: < ul > < li > HTML </ li > < li > CSS </ li > < li > JavaScript </ li > </ ul > Render prerendered JSX element function Component ( props ) { return < ul > { props . skills } < /ul> } const component = < Component skills = {[ < li > HTML < /li>, <li>CSS</li>, <li>JavaScript</li>]} /> the result is: < ul > < li > HTML </ li > < li > CSS </ li > < li > JavaScript </ li > </ ul >","title":"Array props type"},{"location":"react/props/#object-props-type","text":"We may pass an object as props to a React component. Let's see an example. Example function Component ( props ) { return < p > { props . user . firstName } { props . user . lastName } < /p> } const component = < Component user = {{ firstName : 'Test' , lastName : 'Tester' }} /> the result is: < p > Test Tester </ p > When we use an object as props we usually destructure the data to access the values. Destructuring makes our code easy to read. Example function Component ( props ) { const { firstName , lastName } = props . user return < p > { firstName } { lastName } < /p> } const component = < Component user = {{ firstName : 'Test' , lastName : 'Tester' }} /> the result is: < p > Test Tester </ p >","title":"Object props type"},{"location":"react/props/#function-prop-types","text":"We can pass a function as props type to a React component. Functions passed in React Compoents are often used as callbacks Let's see some examples Example function Component ( props ) { return < p > { props . callback ()} < /p> } const component = < Component callback = {() => 'Hello World' } /> the result is: < p > Hello World </ p >","title":"Function prop types"},{"location":"react/props/#default-props","text":"You can define default or optional props, by assigning values or defining undefined to them: Example function Component ({ firstName = 'Default' , lastName = 'Default' }) { return ( < p > { firstName } { lastName } < /p> ); } const component = ( < Component firstName = { 'Test' } lastName = { 'Tester' } /> ); const defaultComponent = < Component /> ; the result is: < p > Test Tester </ p > < p > Default Default </ p >","title":"Default Props"},{"location":"react/react-router/","text":"React Router https://reactrouter.com/en/main","title":"React Router"},{"location":"react/react-router/#react-router","text":"https://reactrouter.com/en/main","title":"React Router"},{"location":"react/setting_up/","text":"Setting Up Here we will learn, how to setup a React project fast, so that we don't have to setup every dependency by ourselves. Create React App To create a react project you can use one of the following ways. Let's assume you installed node. Open the command line interface (CLI), git bash or terminal on Mac or Linux. Then run the following command. I am using git bash. $ npx create-react-app name-of-your-project If you do not like to write npx every time you create a project you may install create-react-app package globally in your computer using the following command. $ npm install -g create-react-app After you installed create-react-app, you create a React application as follows: $ create-react-app name-of-project Your first React App $ cd Desktop/ $ npx create-react-app react-app $ cd react-app $ yarn start Now your React app should run at localhost 3000. Go to the App.js and modify the content by writing some text, you will see the latest changes on the browser. To stop the server, press Ctr + C in the CLI. React Boilerplate Let's see the React boilerplate, which has been created by create-react-app. Whenever you create a new project, you run create-react-app and name of the project. In the following React boilerplate, there are three folders: node_modules, public and src. In addition, there are .gitignore, README.md, package.json and yarn.lock. Some of you, instead of yarn.lock, you may have package-lock.json. It is good to know these folders and files. node_modules - stores all the necessary node packages of the React applications. /public index.html - the only HTML file we have in the entire application favicon.ico - an icon file manifest.json - is used to make the application a progressive web app other images - open graph images(open graph images are images which are visible when a link share on social media) robots.txt - information, if the website allows web scraping /src App.css, index.css - are CSS files index.js - a file which allows to connect all the components with index.html App.js - A file where we usually import most of the presentational components App.test.js - Tests with testing library and jest reportWebVitals.js : is useful to collect Web Vitals information setupTests.js - to write testing cases logo.svg - just a svg file package.json - List of packages the applications uses .gitignore - React boilerplate comes with git initiated, and the .gitingore allows files and folders not to be pushed to GitHub README.md - Markdown file to write documentation yarn.lock or package-lock.json - a means to lock the version of the package","title":"Setting Up"},{"location":"react/setting_up/#setting-up","text":"Here we will learn, how to setup a React project fast, so that we don't have to setup every dependency by ourselves.","title":"Setting Up"},{"location":"react/setting_up/#create-react-app","text":"To create a react project you can use one of the following ways. Let's assume you installed node. Open the command line interface (CLI), git bash or terminal on Mac or Linux. Then run the following command. I am using git bash. $ npx create-react-app name-of-your-project If you do not like to write npx every time you create a project you may install create-react-app package globally in your computer using the following command. $ npm install -g create-react-app After you installed create-react-app, you create a React application as follows: $ create-react-app name-of-project","title":"Create React App"},{"location":"react/setting_up/#your-first-react-app","text":"$ cd Desktop/ $ npx create-react-app react-app $ cd react-app $ yarn start Now your React app should run at localhost 3000. Go to the App.js and modify the content by writing some text, you will see the latest changes on the browser. To stop the server, press Ctr + C in the CLI.","title":"Your first React App"},{"location":"react/setting_up/#react-boilerplate","text":"Let's see the React boilerplate, which has been created by create-react-app. Whenever you create a new project, you run create-react-app and name of the project. In the following React boilerplate, there are three folders: node_modules, public and src. In addition, there are .gitignore, README.md, package.json and yarn.lock. Some of you, instead of yarn.lock, you may have package-lock.json. It is good to know these folders and files. node_modules - stores all the necessary node packages of the React applications. /public index.html - the only HTML file we have in the entire application favicon.ico - an icon file manifest.json - is used to make the application a progressive web app other images - open graph images(open graph images are images which are visible when a link share on social media) robots.txt - information, if the website allows web scraping /src App.css, index.css - are CSS files index.js - a file which allows to connect all the components with index.html App.js - A file where we usually import most of the presentational components App.test.js - Tests with testing library and jest reportWebVitals.js : is useful to collect Web Vitals information setupTests.js - to write testing cases logo.svg - just a svg file package.json - List of packages the applications uses .gitignore - React boilerplate comes with git initiated, and the .gitingore allows files and folders not to be pushed to GitHub README.md - Markdown file to write documentation yarn.lock or package-lock.json - a means to lock the version of the package","title":"React Boilerplate"}]}