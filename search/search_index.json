{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome! On this website you will find lectures about: JavaScript Lectures JavaScript Fundamentals Browser API React Web Workers in React BYOT - Build Your Own Tool Go Lectures Go Fundamentals Dependency Injection in Go Build Go Docker images Architecture and Best Practices Design Patterns Or just click in the left upper corner on Javascript Light/Dark Mode Just switch between Light and Dark mode with the switch in the navigation at the top beside the search input field. Feel free to visit my website: https://bykovski.de","title":"Welcome!"},{"location":"#welcome","text":"On this website you will find lectures about: JavaScript Lectures JavaScript Fundamentals Browser API React Web Workers in React BYOT - Build Your Own Tool Go Lectures Go Fundamentals Dependency Injection in Go Build Go Docker images Architecture and Best Practices Design Patterns Or just click in the left upper corner on Javascript","title":"Welcome!"},{"location":"#lightdark-mode","text":"Just switch between Light and Dark mode with the switch in the navigation at the top beside the search input field. Feel free to visit my website: https://bykovski.de","title":"Light/Dark Mode"},{"location":"exercises/","text":"Exercises","title":"Exercises"},{"location":"exercises/#exercises","text":"","title":"Exercises"},{"location":"exercises/browser-api/shop/","text":"Shop Exercise Let's continue with our shopping example in exercise JavaScript Fundamentals - Shop . Now we build an interface for the shop. It will look like this: responsive, mobile-ready, fast as hell \ud83d\udd25! Quickstart Example Use this example to start: index.html Note: Your browser will try to render the index.html, so just download and start to edit it. After downloading the example, try to add a JavaScript file as resource. Lastly just double-click the index.html file to see it in the browser.","title":"Shop Exercise"},{"location":"exercises/browser-api/shop/#shop-exercise","text":"Let's continue with our shopping example in exercise JavaScript Fundamentals - Shop . Now we build an interface for the shop. It will look like this: responsive, mobile-ready, fast as hell \ud83d\udd25!","title":"Shop Exercise"},{"location":"exercises/browser-api/shop/#quickstart-example","text":"Use this example to start: index.html Note: Your browser will try to render the index.html, so just download and start to edit it. After downloading the example, try to add a JavaScript file as resource. Lastly just double-click the index.html file to see it in the browser.","title":"Quickstart Example"},{"location":"exercises/go/projects/product_service/","text":"Product Service Domain Driven Hexagonal Architecture You are the main dev of a big online shop. The old product service is written in an esoteric language, which cannot handle more than 10.000 requests per second. Now you want to try Go, so let's do it... Create a RESTful service with the http web-framework Gin . It has the following endpoints: GET /product - List all articles GET /product/{id} - Get a specific article POST /product - Create a product PUT /product - Update a product DELETE /product - Delete a product The product struct uses the package https://pkg.go.dev/github.com/shopspring/decimal for prices: core/domain/product.go 1 2 3 4 5 6 7 8 9 10 import ( \"github.com/shopspring/decimal\" ) type Product struct { ID int64 Name string Category string Price decimal . Decimal } The service should have two possible ways to store products and categories. It should store all data in memory or in json files called products.json and categories.json . Use interfaces, domain driven hexagonal architecture and dependency injection to built the service properly. Example Requests: Create products Request: POST /products { \"name\": \"iPhone 14 Pro\", \"price\": 99.99, \"category\": \"smartphones\" } Response: POST /products: 200 1 Request: POST /products { \"name\": \"iPhone 12 Pro\", \"price\": 999.99, \"category\": \"smartphones\" } Response: POST /products: 200 2 Request: POST /products { \"price\": 999.99, \"category\": \"smartphones\" } Response: POST /products: 400 { \"error\": \"Key: 'ProductBody.Name' Error:Field validation for 'Name' failed on the 'required' tag\" } Get products Request: GET /products Response: GET /products: 200 [ { \"id\": 1, \"name\": \"iPhone 14 Pro\", \"category\": \"smartphones\", \"price\": \"99.99\" }, { \"id\": 2, \"name\": \"iPhone 13 Pro\", \"category\": \"smartphones\", \"price\": \"999.99\" } ] Get a specific product Request: GET /products/1 Response: GET /products/1: 200 { \"id\": 1, \"name\": \"iPhone 14 Pro\", \"category\": \"smartphones\", \"price\": \"99.99\" } Request: GET /products/999 Response: GET /products/999: 404 { \"error\": \"could not find product with id: 999\" } Update a product Request: PUT /products/1 { \"name\": \"iPhone 11 Pro\", \"category\": \"smartphones\", \"price\": \"999.99\" } Response: PUT /products/1: 200 { \"name\": \"iPhone 11 Pro\", \"category\": \"smartphones\", \"price\": \"999.99\" } Delete a product Request: DELETE /products/1 Response: DELETE /products/1: 204","title":"Product Service"},{"location":"exercises/go/projects/product_service/#product-service","text":"Domain Driven Hexagonal Architecture You are the main dev of a big online shop. The old product service is written in an esoteric language, which cannot handle more than 10.000 requests per second. Now you want to try Go, so let's do it... Create a RESTful service with the http web-framework Gin . It has the following endpoints: GET /product - List all articles GET /product/{id} - Get a specific article POST /product - Create a product PUT /product - Update a product DELETE /product - Delete a product The product struct uses the package https://pkg.go.dev/github.com/shopspring/decimal for prices: core/domain/product.go 1 2 3 4 5 6 7 8 9 10 import ( \"github.com/shopspring/decimal\" ) type Product struct { ID int64 Name string Category string Price decimal . Decimal } The service should have two possible ways to store products and categories. It should store all data in memory or in json files called products.json and categories.json . Use interfaces, domain driven hexagonal architecture and dependency injection to built the service properly. Example Requests:","title":"Product Service"},{"location":"exercises/go/projects/product_service/#create-products","text":"Request: POST /products { \"name\": \"iPhone 14 Pro\", \"price\": 99.99, \"category\": \"smartphones\" } Response: POST /products: 200 1 Request: POST /products { \"name\": \"iPhone 12 Pro\", \"price\": 999.99, \"category\": \"smartphones\" } Response: POST /products: 200 2 Request: POST /products { \"price\": 999.99, \"category\": \"smartphones\" } Response: POST /products: 400 { \"error\": \"Key: 'ProductBody.Name' Error:Field validation for 'Name' failed on the 'required' tag\" }","title":"Create products"},{"location":"exercises/go/projects/product_service/#get-products","text":"Request: GET /products Response: GET /products: 200 [ { \"id\": 1, \"name\": \"iPhone 14 Pro\", \"category\": \"smartphones\", \"price\": \"99.99\" }, { \"id\": 2, \"name\": \"iPhone 13 Pro\", \"category\": \"smartphones\", \"price\": \"999.99\" } ]","title":"Get products"},{"location":"exercises/go/projects/product_service/#get-a-specific-product","text":"Request: GET /products/1 Response: GET /products/1: 200 { \"id\": 1, \"name\": \"iPhone 14 Pro\", \"category\": \"smartphones\", \"price\": \"99.99\" } Request: GET /products/999 Response: GET /products/999: 404 { \"error\": \"could not find product with id: 999\" }","title":"Get a specific product"},{"location":"exercises/go/projects/product_service/#update-a-product","text":"Request: PUT /products/1 { \"name\": \"iPhone 11 Pro\", \"category\": \"smartphones\", \"price\": \"999.99\" } Response: PUT /products/1: 200 { \"name\": \"iPhone 11 Pro\", \"category\": \"smartphones\", \"price\": \"999.99\" }","title":"Update a product"},{"location":"exercises/go/projects/product_service/#delete-a-product","text":"Request: DELETE /products/1 Response: DELETE /products/1: 204","title":"Delete a product"},{"location":"exercises/go/projects/school/","text":"School A school needs a programm, to store pupils, teachers, lessons and classrooms. The program should have a menu to display it: *** School Program *** Choose one of the following options: 1. Add a pupil 2. Add a teacher 3. Add a classroom 4. Add a lesson 5. Add pupils to lesson 6. List all pupils 7. List all teachers 8. List all classrooms 9. List all lessons 10. List lessons of classroom (11. List lessons of pupil) (12. List lessons of teacher) Your choice: Program 11 and 12 are Bonus parts. If you choose menu 1, following should be printed: Add a pupil: > Enter first name: Michael > Enter last name: Bykovsi > Enter grade: 10 > Pupil #1 Michael Bykovski successfully added Add a pupil: > Enter first name: Tanja > Enter last name: Stark > Enter grade: 10 > Pupil #2 Tanja Stark successfully added If you choose menu 2: Add a teacher: > Enter first name: Peter > Enter last name: Lustig > Enter teaching area: Deutsch und Biologie > Teacher #1 Peter Lustig successfully added If you choose menu 3: Add a classroom: > Enter room number: 405 > Enter location: Hauptgeb\u00e4ude > Classroom #1 405 Hauptgeb\u00e4ude successfully added If you choose menu 4 the following input should be Add a lesson: > Enter lesson name: Deutsche Grammatik #2 > Enter semester: SS22 > Enter classroom id: 1 > Enter teacher id: 2 > Teacher with id 2 does not exist, please choose an existing teacher id! > Enter teacher id: 1 > Lesson #1 Deutsche Grammatik #2 successfully added If you choose menu 5: Add pupils to lesson: > Enter lesson id: 1 > Enter pupils separated by comma: 1,2 > Pupils: - #1 Michel Bykovski - #2 Tanja Stark were added to the lesson #1 Deutsche Grammatik #2 If you choose menu 6: List of pupils: #1 Michael Bykovski (10) #2 Tanja Stark (10) If you choose menu 7: List of teachers: #1 Peter Lustig - Teaching Area: Deutsch und Biologie If you choose menu 8: List of classrooms: #1 405 Hauptgeb\u00e4ude If you choose menu 9: List of lessons: #1 Deutsche Grammatik #2 - Semester: SS22 - Classroom: #1 405 Hauptgeb\u00e4ude - Teacher: #1 Peter Lustig If you choose menu 10: > Which classroom you would like to see? > 1 #1 405 Hauptgeb\u00e4ude - #1 Deutsche Grammatik #2 - Teacher: #1 Peter Lustig - Pupils: - #1 Michael Bykovski - #2 Tanja Stark Bonus task: If you choose menu 11: > Which pupil you would like to see? > 2 #2 Tanja Stark - #1 Deutsche Grammatik #2 - Teacher: #1 Peter Lustig - Classroom: #1 405 Hauptgeb\u00e4ude If you choose menu 12: > Which teacher you would like to see? > 1 #1 Peter Lustig - #1 Deutsche Grammatik #2 - Classroom: #1 405 Hauptgeb\u00e4ude Start with this: main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \"bufio\" \"fmt\" \"os\" ) func main () { for { reader := bufio . NewReader ( os . Stdin ) fmt . Printf ( \"Your choice: \" ) command , _ := reader . ReadString ( '\\n' ) fmt . Println ( command ) } }","title":"School"},{"location":"exercises/go/projects/school/#school","text":"A school needs a programm, to store pupils, teachers, lessons and classrooms. The program should have a menu to display it: *** School Program *** Choose one of the following options: 1. Add a pupil 2. Add a teacher 3. Add a classroom 4. Add a lesson 5. Add pupils to lesson 6. List all pupils 7. List all teachers 8. List all classrooms 9. List all lessons 10. List lessons of classroom (11. List lessons of pupil) (12. List lessons of teacher) Your choice: Program 11 and 12 are Bonus parts. If you choose menu 1, following should be printed: Add a pupil: > Enter first name: Michael > Enter last name: Bykovsi > Enter grade: 10 > Pupil #1 Michael Bykovski successfully added Add a pupil: > Enter first name: Tanja > Enter last name: Stark > Enter grade: 10 > Pupil #2 Tanja Stark successfully added If you choose menu 2: Add a teacher: > Enter first name: Peter > Enter last name: Lustig > Enter teaching area: Deutsch und Biologie > Teacher #1 Peter Lustig successfully added If you choose menu 3: Add a classroom: > Enter room number: 405 > Enter location: Hauptgeb\u00e4ude > Classroom #1 405 Hauptgeb\u00e4ude successfully added If you choose menu 4 the following input should be Add a lesson: > Enter lesson name: Deutsche Grammatik #2 > Enter semester: SS22 > Enter classroom id: 1 > Enter teacher id: 2 > Teacher with id 2 does not exist, please choose an existing teacher id! > Enter teacher id: 1 > Lesson #1 Deutsche Grammatik #2 successfully added If you choose menu 5: Add pupils to lesson: > Enter lesson id: 1 > Enter pupils separated by comma: 1,2 > Pupils: - #1 Michel Bykovski - #2 Tanja Stark were added to the lesson #1 Deutsche Grammatik #2 If you choose menu 6: List of pupils: #1 Michael Bykovski (10) #2 Tanja Stark (10) If you choose menu 7: List of teachers: #1 Peter Lustig - Teaching Area: Deutsch und Biologie If you choose menu 8: List of classrooms: #1 405 Hauptgeb\u00e4ude If you choose menu 9: List of lessons: #1 Deutsche Grammatik #2 - Semester: SS22 - Classroom: #1 405 Hauptgeb\u00e4ude - Teacher: #1 Peter Lustig If you choose menu 10: > Which classroom you would like to see? > 1 #1 405 Hauptgeb\u00e4ude - #1 Deutsche Grammatik #2 - Teacher: #1 Peter Lustig - Pupils: - #1 Michael Bykovski - #2 Tanja Stark Bonus task: If you choose menu 11: > Which pupil you would like to see? > 2 #2 Tanja Stark - #1 Deutsche Grammatik #2 - Teacher: #1 Peter Lustig - Classroom: #1 405 Hauptgeb\u00e4ude If you choose menu 12: > Which teacher you would like to see? > 1 #1 Peter Lustig - #1 Deutsche Grammatik #2 - Classroom: #1 405 Hauptgeb\u00e4ude Start with this: main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \"bufio\" \"fmt\" \"os\" ) func main () { for { reader := bufio . NewReader ( os . Stdin ) fmt . Printf ( \"Your choice: \" ) command , _ := reader . ReadString ( '\\n' ) fmt . Println ( command ) } }","title":"School"},{"location":"exercises/go/starter/","text":"Starter For some starter tasks just clone yourself the repository: https://github.com/bykof/golang-workshop-tasks If you want to see the solutions, just switch the branch to: solutions .","title":"Starter"},{"location":"exercises/go/starter/#starter","text":"For some starter tasks just clone yourself the repository: https://github.com/bykof/golang-workshop-tasks If you want to see the solutions, just switch the branch to: solutions .","title":"Starter"},{"location":"exercises/javascript-fundamentals/","text":"Introduction Here you will find some exercises for JavaScript Fundamentals. Starting with the exercises To start with the exercises I can recommend you following steps: install Node.JS Link create a folder: mkdir -p js-exercises/javascript-fundamentals/shop go to the folder: cd js-exercises/javascript-fundamentals/shop init a node package: npm init -y add a new script in the package.json see at the bottom : add an index.js : touch index.js write your code and start the index.js with npm run start package.json { \"name\" : \"shop\" , \"version\" : \"1.0.0\" , \"main\" : \"index.js\" , \"license\" : \"MIT\" , \"devDependencies\" : { \"jest\" : \"^26.5.3\" }, \"scripts\" : { \"start\" : \"node index.js\" } }","title":"Introduction"},{"location":"exercises/javascript-fundamentals/#introduction","text":"Here you will find some exercises for JavaScript Fundamentals.","title":"Introduction"},{"location":"exercises/javascript-fundamentals/#starting-with-the-exercises","text":"To start with the exercises I can recommend you following steps: install Node.JS Link create a folder: mkdir -p js-exercises/javascript-fundamentals/shop go to the folder: cd js-exercises/javascript-fundamentals/shop init a node package: npm init -y add a new script in the package.json see at the bottom : add an index.js : touch index.js write your code and start the index.js with npm run start","title":"Starting with the exercises"},{"location":"exercises/javascript-fundamentals/#packagejson","text":"{ \"name\" : \"shop\" , \"version\" : \"1.0.0\" , \"main\" : \"index.js\" , \"license\" : \"MIT\" , \"devDependencies\" : { \"jest\" : \"^26.5.3\" }, \"scripts\" : { \"start\" : \"node index.js\" } }","title":"package.json"},{"location":"exercises/javascript-fundamentals/shop/","text":"Shopping Exercise Online Shopping has a really heavy impact on all industries around the world. Therefore we try it ourselves and implement a small Node.JS shop, but in offline mode. Let's start! Add customer Add a customer and ask for firstname, lastname, street, city, phone, email and then print out an incrementing customer number. Example *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit > 1 Firstname: Michael Lastname: Tester Street: Shoppingstreet 12 Postal Code: 123456 City: Shop Phone: 0174 123 123 Email: tester@test.com Customer #1 was added! *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit > Add Product Add a product with a product number, name, and a product price in cent amount. If you use a product number, which was already used, just overwrite it. Example *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit > 2 Number: s1 Name: Nintendo Switch Price (in cents): 19999 Product #s1 was added! Errors If the Price in cents is not an integer , let the customer enter an integer until it's correct: Number: 1 Name: Switch Price (in cents): asdf Please reenter a correct price as cents. Price (in cents): Add New Order Create a new order and store the draft order in the current application until the user is able to save it with menu item 8 . Example *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit > 3 Please enter the customer number: 1 1 Order #1 was created *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders 7: Add OrderItem 8: Save order x: Exit Errors If the customer could not be found, let the user reenter the customer number until the correct customer number is entered: Please enter the customer number: f Customer could not be found. Please enter the customer number: Add OrderItem Add an product with a specific amount to the current draft order. Example *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders 7: Add OrderItem 8: Save order x: Exit > 7 Please enter the product number: 1 Please enter the amount: 3 Errors If the product number does not exist, let the user reenter until the product can be found: Please enter the product number: 3 Product could not be found. Please enter the product number: If the amount is not an integer, let the user reenter until it's an integer: Please enter the amount: asd Please enter a number as amount. Please enter the amount: Save order Saving the order just removes the possibility to add OrderItems to the current draft order. Example *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders 7: Add OrderItem 8: Save order x: Exit > 8 Order was saved! *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit Print Customers Just print out all customers. Hint: Use console.table Example *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit > 4 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 (index) \u2502 number \u2502 firstName \u2502 lastName \u2502 street \u2502 city \u2502 postalCode \u2502 email \u2502 phone \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 '1' \u2502 'Test' \u2502 'Tester' \u2502 'Teststreet 12' \u2502 '123456' \u2502 'Testcity' \u2502 'test@test.com' \u2502 '0123456789' \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Print products Print all products. Example > 5 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 (index) \u2502 number \u2502 name \u2502 price \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 's1' \u2502 'Switch' \u2502 Price { amount: 19999 } \u2502 \u2502 1 \u2502 'p1' \u2502 'Playstation 4' \u2502 Price { amount: 39999 } \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Print orders Print all orders Hint: Don't use console.table here! Example > 6 > 6 -------------------------------------------------- Order #1 for 1 - Test Tester ------------------------- 1x #s1 Switch - 199.99 ------------------------- 3x #p1 Playstation 4 - 399.99 Sum: 1399.96 -------------------------------------------------- -------------------------------------------------- Order #2 for 2 - Another Testy ------------------------- 2x #s1 Switch - 199.99 ------------------------- 1x #p1 Playstation 4 - 399.99 Sum: 799.97 --------------------------------------------------","title":"Shopping Exercise"},{"location":"exercises/javascript-fundamentals/shop/#shopping-exercise","text":"Online Shopping has a really heavy impact on all industries around the world. Therefore we try it ourselves and implement a small Node.JS shop, but in offline mode. Let's start!","title":"Shopping Exercise"},{"location":"exercises/javascript-fundamentals/shop/#add-customer","text":"Add a customer and ask for firstname, lastname, street, city, phone, email and then print out an incrementing customer number.","title":"Add customer"},{"location":"exercises/javascript-fundamentals/shop/#example","text":"*** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit > 1 Firstname: Michael Lastname: Tester Street: Shoppingstreet 12 Postal Code: 123456 City: Shop Phone: 0174 123 123 Email: tester@test.com Customer #1 was added! *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit >","title":"Example"},{"location":"exercises/javascript-fundamentals/shop/#add-product","text":"Add a product with a product number, name, and a product price in cent amount. If you use a product number, which was already used, just overwrite it.","title":"Add Product"},{"location":"exercises/javascript-fundamentals/shop/#example_1","text":"*** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit > 2 Number: s1 Name: Nintendo Switch Price (in cents): 19999 Product #s1 was added!","title":"Example"},{"location":"exercises/javascript-fundamentals/shop/#errors","text":"If the Price in cents is not an integer , let the customer enter an integer until it's correct: Number: 1 Name: Switch Price (in cents): asdf Please reenter a correct price as cents. Price (in cents):","title":"Errors"},{"location":"exercises/javascript-fundamentals/shop/#add-new-order","text":"Create a new order and store the draft order in the current application until the user is able to save it with menu item 8 .","title":"Add New Order"},{"location":"exercises/javascript-fundamentals/shop/#example_2","text":"*** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit > 3 Please enter the customer number: 1 1 Order #1 was created *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders 7: Add OrderItem 8: Save order x: Exit","title":"Example"},{"location":"exercises/javascript-fundamentals/shop/#errors_1","text":"If the customer could not be found, let the user reenter the customer number until the correct customer number is entered: Please enter the customer number: f Customer could not be found. Please enter the customer number:","title":"Errors"},{"location":"exercises/javascript-fundamentals/shop/#add-orderitem","text":"Add an product with a specific amount to the current draft order.","title":"Add OrderItem"},{"location":"exercises/javascript-fundamentals/shop/#example_3","text":"*** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders 7: Add OrderItem 8: Save order x: Exit > 7 Please enter the product number: 1 Please enter the amount: 3","title":"Example"},{"location":"exercises/javascript-fundamentals/shop/#errors_2","text":"If the product number does not exist, let the user reenter until the product can be found: Please enter the product number: 3 Product could not be found. Please enter the product number: If the amount is not an integer, let the user reenter until it's an integer: Please enter the amount: asd Please enter a number as amount. Please enter the amount:","title":"Errors"},{"location":"exercises/javascript-fundamentals/shop/#save-order","text":"Saving the order just removes the possibility to add OrderItems to the current draft order.","title":"Save order"},{"location":"exercises/javascript-fundamentals/shop/#example_4","text":"*** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders 7: Add OrderItem 8: Save order x: Exit > 8 Order was saved! *** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit","title":"Example"},{"location":"exercises/javascript-fundamentals/shop/#print-customers","text":"Just print out all customers. Hint: Use console.table","title":"Print Customers"},{"location":"exercises/javascript-fundamentals/shop/#example_5","text":"*** Menu *** 1: Add Customer 2: Add Product 3: New Order 4: Print Customers 5: Print Products 6: Print Orders x: Exit > 4 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 (index) \u2502 number \u2502 firstName \u2502 lastName \u2502 street \u2502 city \u2502 postalCode \u2502 email \u2502 phone \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 '1' \u2502 'Test' \u2502 'Tester' \u2502 'Teststreet 12' \u2502 '123456' \u2502 'Testcity' \u2502 'test@test.com' \u2502 '0123456789' \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Example"},{"location":"exercises/javascript-fundamentals/shop/#print-products","text":"Print all products.","title":"Print products"},{"location":"exercises/javascript-fundamentals/shop/#example_6","text":"> 5 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 (index) \u2502 number \u2502 name \u2502 price \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 's1' \u2502 'Switch' \u2502 Price { amount: 19999 } \u2502 \u2502 1 \u2502 'p1' \u2502 'Playstation 4' \u2502 Price { amount: 39999 } \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Example"},{"location":"exercises/javascript-fundamentals/shop/#print-orders","text":"Print all orders Hint: Don't use console.table here!","title":"Print orders"},{"location":"exercises/javascript-fundamentals/shop/#example_7","text":"> 6 > 6 -------------------------------------------------- Order #1 for 1 - Test Tester ------------------------- 1x #s1 Switch - 199.99 ------------------------- 3x #p1 Playstation 4 - 399.99 Sum: 1399.96 -------------------------------------------------- -------------------------------------------------- Order #2 for 2 - Another Testy ------------------------- 2x #s1 Switch - 199.99 ------------------------- 1x #p1 Playstation 4 - 399.99 Sum: 799.97 --------------------------------------------------","title":"Example"},{"location":"golang/","text":"Introduction Welcome to my Golang lectures. On the left side you will find several topics of this lecture.","title":"Introduction"},{"location":"golang/#introduction","text":"Welcome to my Golang lectures. On the left side you will find several topics of this lecture.","title":"Introduction"},{"location":"golang/architecture/","text":"Architecture and Best Practices in Go For best practices written by the Go team check out Effective Go Currently the best architecture for Go applications, in my opinion, is the domain driven hexagonal architecture: Link . It's so suitable because Go provides loosely coupled interface implementation to use dependency injection and packaging makes it clear, which struct belongs to which \"layer\". Two Known Architecture Principles There are two known architecture principles in Go. The \"flat\" architecture and the \"domain driven\" architecture. Let's take a look at two examples: Cobra Go Cache Cobra uses the flat architecture. Go Cache uses the domain driven approach, at least it utilizes packages. Mostly the flat architecture is used, when the Go programm is small and does just one thing. If the Go program becomes more complicated and does several things, I would suggest to use the domain driven hexagonal approach.","title":"Architecture and Best Practices in Go"},{"location":"golang/architecture/#architecture-and-best-practices-in-go","text":"For best practices written by the Go team check out Effective Go Currently the best architecture for Go applications, in my opinion, is the domain driven hexagonal architecture: Link . It's so suitable because Go provides loosely coupled interface implementation to use dependency injection and packaging makes it clear, which struct belongs to which \"layer\".","title":"Architecture and Best Practices in Go"},{"location":"golang/architecture/#two-known-architecture-principles","text":"There are two known architecture principles in Go. The \"flat\" architecture and the \"domain driven\" architecture. Let's take a look at two examples: Cobra Go Cache Cobra uses the flat architecture. Go Cache uses the domain driven approach, at least it utilizes packages. Mostly the flat architecture is used, when the Go programm is small and does just one thing. If the Go program becomes more complicated and does several things, I would suggest to use the domain driven hexagonal approach.","title":"Two Known Architecture Principles"},{"location":"golang/dependency_injection/","text":"Dependency Injection in Go Dependency Injection in Go is a really important topic, because the programming language has a perfect basis to do dependency injection. Interfaces and Structs can decouple your application perfectly. Let's say we have a service which just redirects a call from a client to another service. First we define our core logic and values: core/value_objects/ttl_say_body.go 1 2 3 4 5 6 7 8 9 10 11 12 13 package valueobjects type TTSVoiceType string const ( TTSMaleVoice TTSVoiceType = \"male\" TTSFemaleVoid TTSVoiceType = \"female\" ) type TTSSayBody struct { Message string `json:\"message\"` TTSVoiceType TTSVoiceType `json:\"ttsVoiceType\"` } core/value_objects/ttl_say_response.go 1 2 3 4 5 6 package valueobjects type TTSSayResponse struct { Message string Status int } core/ports/ttl_service_port.go 1 2 3 4 5 6 7 package ports import valueobjects \"dependency_injection/core/value_objects\" type TTSServicePort interface { Say ( ttsRequestBody valueobjects . TTSSayBody ) ( valueobjects . TTSSayResponse , error ) } Then we implement the ports: infrastructure/services/real_ttl_service.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package services import ( \"bytes\" \"dependency_injection/core/ports\" valueobjects \"dependency_injection/core/value_objects\" \"encoding/json\" \"fmt\" \"io/ioutil\" \"net/http\" ) type RealTTSService struct { url string } var _ ports . TTSServicePort = RealTTSService {} func ( r RealTTSService ) formatEndpoint ( endpoint string ) string { return fmt . Sprintf ( \"%s/%s\" , r . url , endpoint ) } func ( r RealTTSService ) Say ( ttsRequestBody valueobjects . TTSSayBody ) ( valueobjects . TTSSayResponse , error ) { var ttsSayResponse valueobjects . TTSSayResponse postBody , _ := json . Marshal ( ttsRequestBody ) resp , err := http . Post ( r . formatEndpoint ( \"say\" ), \"application/json\" , bytes . NewBuffer ( postBody )) defer resp . Body . Close () if err != nil { return valueobjects . TTSSayResponse {}, err } responseBody , err := ioutil . ReadAll ( resp . Body ) if err != nil { return valueobjects . TTSSayResponse {}, err } err = json . Unmarshal ( responseBody , & ttsSayResponse ) if err != nil { return valueobjects . TTSSayResponse {}, err } return ttsSayResponse , nil } func NewRealTTSService () * RealTTSService { fmt . Println ( \"Init RealTTSService\" ) return & RealTTSService {} } infrastructure/services/fake_ttl_service.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package services import ( \"dependency_injection/core/ports\" valueobjects \"dependency_injection/core/value_objects\" \"errors\" \"fmt\" ) type FakeTTSService struct { } var _ ports . TTSServicePort = RealTTSService {} func ( f FakeTTSService ) Say ( ttsRequestBody valueobjects . TTSSayBody ) ( valueobjects . TTSSayResponse , error ) { if ttsRequestBody . Message == \"_Error!\" { return valueobjects . TTSSayResponse {}, errors . New ( \"custom error\" ) } return valueobjects . TTSSayResponse { Message : fmt . Sprintf ( \"Said: \\\"%s\\\" with voice %s\" , ttsRequestBody . Message , ttsRequestBody . TTSVoiceType ), Status : 200 , }, nil } func NewFakeTTSService () * FakeTTSService { fmt . Println ( \"Init FakeTTSService\" ) return & FakeTTSService {} } Now we can implement the interfaces for the application. Here we inject the TTSServicePort into the MainController. We execute a specific application functionality and receive a defined struct TTSSayResponse interface/controllers/main_controller.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package controllers import ( \"dependency_injection/core/ports\" valueobjects \"dependency_injection/core/value_objects\" \"encoding/json\" \"io/ioutil\" \"net/http\" ) type MainController struct { ttsService ports . TTSServicePort } func NewMainController ( ttsService ports . TTSServicePort ) * MainController { return & MainController { ttsService : ttsService , } } func ( mc * MainController ) Say ( w http . ResponseWriter , r * http . Request ) { var ttsSayBody valueobjects . TTSSayBody body , err := ioutil . ReadAll ( r . Body ) defer r . Body . Close () if err != nil { _ , _ = w . Write ([] byte ( err . Error ())) return } err = json . Unmarshal ( body , & ttsSayBody ) if err != nil { _ , _ = w . Write ([] byte ( err . Error ())) return } ttsSayResponse , err := mc . ttsService . Say ( ttsSayBody ) if err != nil { _ , _ = w . Write ([] byte ( err . Error ())) return } jsonResponse , err := json . Marshal ( ttsSayResponse ) if err != nil { _ , _ = w . Write ([] byte ( err . Error ())) return } _ , _ = w . Write ( jsonResponse ) return } Now we wrap everything up in our main.go file and inject the dependencies now. Here we inject a specific TTSServicePort depending on the environment variable: main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \"dependency_injection/core/ports\" \"dependency_injection/infrastructure/services\" \"dependency_injection/interface/controllers\" \"log\" \"net/http\" \"os\" ) func main () { var ttsService ports . TTSServicePort if os . Getenv ( \"ENV\" ) == \"prod\" { ttsService = services . NewRealTTSService () } else { ttsService = services . NewFakeTTSService () } mainController := controllers . NewMainController ( ttsService ) http . HandleFunc ( \"/say\" , mainController . Say ) log . Println ( \"Running server on http://localhost:8081\" ) log . Fatal ( http . ListenAndServe ( \":8081\" , nil )) } We have the following structure now: |-- core | |-- ports | | `-- ttl_service_port.go | `-- value_objects | |-- tts_say_body.go | `-- tts_say_response.go |-- go.mod |-- infrastructure | `-- services | |-- fake_tts_service.go | `-- real_tts_service.go |-- interface | `-- controllers | `-- main_controller.go `-- main.go There are teams who use this kind of dependency injection. But if it becomes more complex, its easier to use a tooling like wire. Let's check in the next chapter, how to do this.","title":"Dependency Injection in Go"},{"location":"golang/dependency_injection/#dependency-injection-in-go","text":"Dependency Injection in Go is a really important topic, because the programming language has a perfect basis to do dependency injection. Interfaces and Structs can decouple your application perfectly. Let's say we have a service which just redirects a call from a client to another service. First we define our core logic and values: core/value_objects/ttl_say_body.go 1 2 3 4 5 6 7 8 9 10 11 12 13 package valueobjects type TTSVoiceType string const ( TTSMaleVoice TTSVoiceType = \"male\" TTSFemaleVoid TTSVoiceType = \"female\" ) type TTSSayBody struct { Message string `json:\"message\"` TTSVoiceType TTSVoiceType `json:\"ttsVoiceType\"` } core/value_objects/ttl_say_response.go 1 2 3 4 5 6 package valueobjects type TTSSayResponse struct { Message string Status int } core/ports/ttl_service_port.go 1 2 3 4 5 6 7 package ports import valueobjects \"dependency_injection/core/value_objects\" type TTSServicePort interface { Say ( ttsRequestBody valueobjects . TTSSayBody ) ( valueobjects . TTSSayResponse , error ) } Then we implement the ports: infrastructure/services/real_ttl_service.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package services import ( \"bytes\" \"dependency_injection/core/ports\" valueobjects \"dependency_injection/core/value_objects\" \"encoding/json\" \"fmt\" \"io/ioutil\" \"net/http\" ) type RealTTSService struct { url string } var _ ports . TTSServicePort = RealTTSService {} func ( r RealTTSService ) formatEndpoint ( endpoint string ) string { return fmt . Sprintf ( \"%s/%s\" , r . url , endpoint ) } func ( r RealTTSService ) Say ( ttsRequestBody valueobjects . TTSSayBody ) ( valueobjects . TTSSayResponse , error ) { var ttsSayResponse valueobjects . TTSSayResponse postBody , _ := json . Marshal ( ttsRequestBody ) resp , err := http . Post ( r . formatEndpoint ( \"say\" ), \"application/json\" , bytes . NewBuffer ( postBody )) defer resp . Body . Close () if err != nil { return valueobjects . TTSSayResponse {}, err } responseBody , err := ioutil . ReadAll ( resp . Body ) if err != nil { return valueobjects . TTSSayResponse {}, err } err = json . Unmarshal ( responseBody , & ttsSayResponse ) if err != nil { return valueobjects . TTSSayResponse {}, err } return ttsSayResponse , nil } func NewRealTTSService () * RealTTSService { fmt . Println ( \"Init RealTTSService\" ) return & RealTTSService {} } infrastructure/services/fake_ttl_service.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package services import ( \"dependency_injection/core/ports\" valueobjects \"dependency_injection/core/value_objects\" \"errors\" \"fmt\" ) type FakeTTSService struct { } var _ ports . TTSServicePort = RealTTSService {} func ( f FakeTTSService ) Say ( ttsRequestBody valueobjects . TTSSayBody ) ( valueobjects . TTSSayResponse , error ) { if ttsRequestBody . Message == \"_Error!\" { return valueobjects . TTSSayResponse {}, errors . New ( \"custom error\" ) } return valueobjects . TTSSayResponse { Message : fmt . Sprintf ( \"Said: \\\"%s\\\" with voice %s\" , ttsRequestBody . Message , ttsRequestBody . TTSVoiceType ), Status : 200 , }, nil } func NewFakeTTSService () * FakeTTSService { fmt . Println ( \"Init FakeTTSService\" ) return & FakeTTSService {} } Now we can implement the interfaces for the application. Here we inject the TTSServicePort into the MainController. We execute a specific application functionality and receive a defined struct TTSSayResponse interface/controllers/main_controller.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package controllers import ( \"dependency_injection/core/ports\" valueobjects \"dependency_injection/core/value_objects\" \"encoding/json\" \"io/ioutil\" \"net/http\" ) type MainController struct { ttsService ports . TTSServicePort } func NewMainController ( ttsService ports . TTSServicePort ) * MainController { return & MainController { ttsService : ttsService , } } func ( mc * MainController ) Say ( w http . ResponseWriter , r * http . Request ) { var ttsSayBody valueobjects . TTSSayBody body , err := ioutil . ReadAll ( r . Body ) defer r . Body . Close () if err != nil { _ , _ = w . Write ([] byte ( err . Error ())) return } err = json . Unmarshal ( body , & ttsSayBody ) if err != nil { _ , _ = w . Write ([] byte ( err . Error ())) return } ttsSayResponse , err := mc . ttsService . Say ( ttsSayBody ) if err != nil { _ , _ = w . Write ([] byte ( err . Error ())) return } jsonResponse , err := json . Marshal ( ttsSayResponse ) if err != nil { _ , _ = w . Write ([] byte ( err . Error ())) return } _ , _ = w . Write ( jsonResponse ) return } Now we wrap everything up in our main.go file and inject the dependencies now. Here we inject a specific TTSServicePort depending on the environment variable: main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \"dependency_injection/core/ports\" \"dependency_injection/infrastructure/services\" \"dependency_injection/interface/controllers\" \"log\" \"net/http\" \"os\" ) func main () { var ttsService ports . TTSServicePort if os . Getenv ( \"ENV\" ) == \"prod\" { ttsService = services . NewRealTTSService () } else { ttsService = services . NewFakeTTSService () } mainController := controllers . NewMainController ( ttsService ) http . HandleFunc ( \"/say\" , mainController . Say ) log . Println ( \"Running server on http://localhost:8081\" ) log . Fatal ( http . ListenAndServe ( \":8081\" , nil )) } We have the following structure now: |-- core | |-- ports | | `-- ttl_service_port.go | `-- value_objects | |-- tts_say_body.go | `-- tts_say_response.go |-- go.mod |-- infrastructure | `-- services | |-- fake_tts_service.go | `-- real_tts_service.go |-- interface | `-- controllers | `-- main_controller.go `-- main.go There are teams who use this kind of dependency injection. But if it becomes more complex, its easier to use a tooling like wire. Let's check in the next chapter, how to do this.","title":"Dependency Injection in Go"},{"location":"golang/dependency_injection/wire/","text":"Wire Google's own compile time dependency injection framework is called: Wire . Wire works a little bit different from guice for example. Wire generates code from a file called wire.go to a file called wire_gen.go , which can be used in the main.go file to initialize and start the application. Install wire first: go install github.com/google/wire/cmd/wire@latest Let's take our example from the chapter before. We first just create a file called wire.go : wire.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //go:build wireinject // +build wireinject package main import ( \"dependency_injection/core/ports\" \"dependency_injection/infrastructure/services\" \"dependency_injection/interface/controllers\" \"github.com/google/wire\" \"os\" ) func NewTTSService () ports . TTSServicePort { if os . Getenv ( \"ENV\" ) == \"prod\" { return services . NewRealTTSService () } else { return services . NewFakeTTSService () } } func InitializeMainController () * controllers . MainController { wire . Build ( NewTTSService , controllers . NewMainController ) return & controllers . MainController {} } After that we can run wire to generate a wire_gen.go file: Run in project root wire wire_gen.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // Code generated by Wire. DO NOT EDIT. //go:generate go run github.com/google/wire/cmd/wire //go:build !wireinject // +build !wireinject package main import ( \"dependency_injection/core/ports\" \"dependency_injection/infrastructure/services\" \"dependency_injection/interface/controllers\" \"os\" ) // Injectors from wire.go: func InitializeMainController () * controllers . MainController { ttsServicePort := NewTTSService () mainController := controllers . NewMainController ( ttsServicePort ) return mainController } // wire.go: func NewTTSService () ports . TTSServicePort { if os . Getenv ( \"ENV\" ) == \"prod\" { return services . NewRealTTSService () } else { return services . NewFakeTTSService () } } And now we can adapt the main.go file: main.go 1 2 3 4 5 6 func main () { mainController := InitializeMainController () http . HandleFunc ( \"/say\" , mainController . Say ) log . Println ( \"Running server on http://localhost:8081\" ) log . Fatal ( http . ListenAndServe ( \":8081\" , nil )) } Since we have now two files for the main package, we need to adapt our start line. This is important because otherwise it won't compile properly: go run main.go wire_gen.go","title":"Wire"},{"location":"golang/dependency_injection/wire/#wire","text":"Google's own compile time dependency injection framework is called: Wire . Wire works a little bit different from guice for example. Wire generates code from a file called wire.go to a file called wire_gen.go , which can be used in the main.go file to initialize and start the application. Install wire first: go install github.com/google/wire/cmd/wire@latest Let's take our example from the chapter before. We first just create a file called wire.go : wire.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //go:build wireinject // +build wireinject package main import ( \"dependency_injection/core/ports\" \"dependency_injection/infrastructure/services\" \"dependency_injection/interface/controllers\" \"github.com/google/wire\" \"os\" ) func NewTTSService () ports . TTSServicePort { if os . Getenv ( \"ENV\" ) == \"prod\" { return services . NewRealTTSService () } else { return services . NewFakeTTSService () } } func InitializeMainController () * controllers . MainController { wire . Build ( NewTTSService , controllers . NewMainController ) return & controllers . MainController {} } After that we can run wire to generate a wire_gen.go file: Run in project root wire wire_gen.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // Code generated by Wire. DO NOT EDIT. //go:generate go run github.com/google/wire/cmd/wire //go:build !wireinject // +build !wireinject package main import ( \"dependency_injection/core/ports\" \"dependency_injection/infrastructure/services\" \"dependency_injection/interface/controllers\" \"os\" ) // Injectors from wire.go: func InitializeMainController () * controllers . MainController { ttsServicePort := NewTTSService () mainController := controllers . NewMainController ( ttsServicePort ) return mainController } // wire.go: func NewTTSService () ports . TTSServicePort { if os . Getenv ( \"ENV\" ) == \"prod\" { return services . NewRealTTSService () } else { return services . NewFakeTTSService () } } And now we can adapt the main.go file: main.go 1 2 3 4 5 6 func main () { mainController := InitializeMainController () http . HandleFunc ( \"/say\" , mainController . Say ) log . Println ( \"Running server on http://localhost:8081\" ) log . Fatal ( http . ListenAndServe ( \":8081\" , nil )) } Since we have now two files for the main package, we need to adapt our start line. This is important because otherwise it won't compile properly: go run main.go wire_gen.go","title":"Wire"},{"location":"golang/design_patterns/","text":"Design Patterns in Go In this chapter we will look at some design patterns in Go. All code example are taken from here: https://refactoring.guru/design-patterns/go Singleton Just hold a package variable, which is a pointer to your preferred struct. Then expose a function SingleInstance to retrieve the singleton. Note to use sync.Mutex to lock the creation for the singleInstance, otherwise you could create multiple instances within several goroutines. single.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import ( \"fmt\" \"sync\" ) var lock = & sync . Mutex {} type single struct { } var singleInstance * single func SingleInstance () * single { if singleInstance == nil { lock . Lock () defer lock . Unlock () if singleInstance == nil { fmt . Println ( \"Creating single instance now.\" ) singleInstance = & single {} } else { fmt . Println ( \"Single instance already created.\" ) } } else { fmt . Println ( \"Single instance already created.\" ) } return singleInstance } Decorator The decorator pattern allows adding new behaviours to objects dynamically. Let's see how we can do that by creating a pizza decorator pattern: First we create the decorator functionality pizza.go 1 2 3 type Pricer interface { getPrice () int } then we create create a concrete component: 1 2 3 4 5 type Pizza struct {} func ( p Pizza ) getPrice () int { return 3 } now we create some decorators: toppings.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type Cheese struct { pricer Pricer } func ( c Cheese ) getPrice () int { return c . pricer . getPrice () + 2 } type Tomato struct { pricer Pricer } func ( t Tomato ) getPrice () int { return t . pricer . getPrice () + 1 } and now we stack the decorators: main.go 1 2 3 4 5 6 7 8 func main () { price := Cheese { pricer : Tomato { pricer : Pizza {}, }, }. getPrice () fmt . Println ( price ) }","title":"Design Patterns in Go"},{"location":"golang/design_patterns/#design-patterns-in-go","text":"In this chapter we will look at some design patterns in Go. All code example are taken from here: https://refactoring.guru/design-patterns/go","title":"Design Patterns in Go"},{"location":"golang/design_patterns/#singleton","text":"Just hold a package variable, which is a pointer to your preferred struct. Then expose a function SingleInstance to retrieve the singleton. Note to use sync.Mutex to lock the creation for the singleInstance, otherwise you could create multiple instances within several goroutines. single.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import ( \"fmt\" \"sync\" ) var lock = & sync . Mutex {} type single struct { } var singleInstance * single func SingleInstance () * single { if singleInstance == nil { lock . Lock () defer lock . Unlock () if singleInstance == nil { fmt . Println ( \"Creating single instance now.\" ) singleInstance = & single {} } else { fmt . Println ( \"Single instance already created.\" ) } } else { fmt . Println ( \"Single instance already created.\" ) } return singleInstance }","title":"Singleton"},{"location":"golang/design_patterns/#decorator","text":"The decorator pattern allows adding new behaviours to objects dynamically. Let's see how we can do that by creating a pizza decorator pattern: First we create the decorator functionality pizza.go 1 2 3 type Pricer interface { getPrice () int } then we create create a concrete component: 1 2 3 4 5 type Pizza struct {} func ( p Pizza ) getPrice () int { return 3 } now we create some decorators: toppings.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type Cheese struct { pricer Pricer } func ( c Cheese ) getPrice () int { return c . pricer . getPrice () + 2 } type Tomato struct { pricer Pricer } func ( t Tomato ) getPrice () int { return t . pricer . getPrice () + 1 } and now we stack the decorators: main.go 1 2 3 4 5 6 7 8 func main () { price := Cheese { pricer : Tomato { pricer : Pizza {}, }, }. getPrice () fmt . Println ( price ) }","title":"Decorator"},{"location":"golang/docker/","text":"Docker Images for Go Surprisingly Docker was built with the programming language Go. Go Application Let's start with a simple Go webserver and init a go application: go mod init go-webserver Now we write the main.go file. main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \"fmt\" \"html\" \"log\" \"net/http\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { fmt . Fprintf ( w , \"Hello, %q\" , html . EscapeString ( r . URL . Path )) }) http . HandleFunc ( \"/hi\" , func ( w http . ResponseWriter , r * http . Request ){ fmt . Fprintf ( w , \"Hi\" ) }) log . Fatal ( http . ListenAndServe ( \":8081\" , nil )) } If we run it with go run main.go and access the URL with http://localhost:8081/go we get Hello, \"/go\" as response. Writing the Dockerfile We have a working Go application, now let's start to build it as a Docker image. For that we need first a Dockerfile in the same location, where the main.go file is located. Let's create a Dockerfile for that to build images: Dockerfile FROM golang:1.18.1-alpine RUN mkdir /app WORKDIR /app COPY . . RUN go build -o main . CMD [ \"/app/main\" ] Build the image Now we have a Dockerfile and can build the image: docker build . -t go-webserver:latest Start or push the image From that point we can start the image or push it onto an image repository. Here is a demonstration, how to start the image: docker run --rm -it -p 8081 :8081 go-webserver Now we can access again the browser: http://localhost:8081/go and the response should be Hello, \"/go\" . Smaller images Since we compile the go application, we actually don't need the Go files anymore in the image. To save some space we can build the image in two stages (multistage). Here is an example to do that: Dockerfile FROM golang:1.18.1-alpine AS BUILDER WORKDIR /app COPY . . RUN go build -o app main.go FROM alpine:latest WORKDIR /app COPY --from = BUILDER /app ./ CMD [ \"./app\" ] Since we built the Go application on an alpine, we can use instead of golang:alpine just alpine , which is a smaller image.\\ We built and start the image: docker build . -t go-webserver-alpine docker run --rm -it -p 8081 :8081 go-webserver-alpine If we compare those two images, there is a significant difference: go-webserver-alpine latest 4fe92b6799b2 38 seconds ago 11.4MB go-webserver latest c67bfbfc1bba 7 minutes ago 332MB","title":"Docker Images for Go"},{"location":"golang/docker/#docker-images-for-go","text":"Surprisingly Docker was built with the programming language Go.","title":"Docker Images for Go"},{"location":"golang/docker/#go-application","text":"Let's start with a simple Go webserver and init a go application: go mod init go-webserver Now we write the main.go file. main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \"fmt\" \"html\" \"log\" \"net/http\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { fmt . Fprintf ( w , \"Hello, %q\" , html . EscapeString ( r . URL . Path )) }) http . HandleFunc ( \"/hi\" , func ( w http . ResponseWriter , r * http . Request ){ fmt . Fprintf ( w , \"Hi\" ) }) log . Fatal ( http . ListenAndServe ( \":8081\" , nil )) } If we run it with go run main.go and access the URL with http://localhost:8081/go we get Hello, \"/go\" as response.","title":"Go Application"},{"location":"golang/docker/#writing-the-dockerfile","text":"We have a working Go application, now let's start to build it as a Docker image. For that we need first a Dockerfile in the same location, where the main.go file is located. Let's create a Dockerfile for that to build images: Dockerfile FROM golang:1.18.1-alpine RUN mkdir /app WORKDIR /app COPY . . RUN go build -o main . CMD [ \"/app/main\" ]","title":"Writing the Dockerfile"},{"location":"golang/docker/#build-the-image","text":"Now we have a Dockerfile and can build the image: docker build . -t go-webserver:latest","title":"Build the image"},{"location":"golang/docker/#start-or-push-the-image","text":"From that point we can start the image or push it onto an image repository. Here is a demonstration, how to start the image: docker run --rm -it -p 8081 :8081 go-webserver Now we can access again the browser: http://localhost:8081/go and the response should be Hello, \"/go\" .","title":"Start or push the image"},{"location":"golang/docker/#smaller-images","text":"Since we compile the go application, we actually don't need the Go files anymore in the image. To save some space we can build the image in two stages (multistage). Here is an example to do that: Dockerfile FROM golang:1.18.1-alpine AS BUILDER WORKDIR /app COPY . . RUN go build -o app main.go FROM alpine:latest WORKDIR /app COPY --from = BUILDER /app ./ CMD [ \"./app\" ] Since we built the Go application on an alpine, we can use instead of golang:alpine just alpine , which is a smaller image.\\ We built and start the image: docker build . -t go-webserver-alpine docker run --rm -it -p 8081 :8081 go-webserver-alpine If we compare those two images, there is a significant difference: go-webserver-alpine latest 4fe92b6799b2 38 seconds ago 11.4MB go-webserver latest c67bfbfc1bba 7 minutes ago 332MB","title":"Smaller images"},{"location":"golang/golang-fundamentals/composite_types/","text":"Composite Types Composite types in Go contain more functionality than the primitive types. There are builtin functions in Go to support composite types. Let's see how to use them and what are the best practices. Comparable Types This types are comparable: Boolean Numeric String, Pointer Channel Interface types Structs \u2013 if all it\u2019s field type is comparable Array \u2013 if the type of value of array element is comparable This are not comparable types: Slice Map Function Arrays Arrays aren't used directly. Normally Go developers use Slices, we will see why in the next chapter, but let's first check what Arrays are and how to use them. First we look at the declaration of an array: 1 var x [ 3 ] int This creates an array of three ints ( x[0] , x[1] , x[2] ), each initialized to a zero value ( 0 ). If you want to define the values for all array elements use the array literal: 1 var x = [ 3 ] int { 1 , 2 , 3 } If can specify the indices of a new array: 1 2 3 4 5 var x = [ 10 ] int { 1 : 1 , 3 : 2 , 5 : 3 , } This will create the following array: [0 1 0 2 0 3 0 0 0 0] If you want to initialize an array with a dynamic number of values use the variadic keyword ... . 1 2 3 4 5 6 var x = [ ... ] int { 1 : 1 , 3 : 2 , 5 : 3 , } fmt . Println ( x ) This will create the following array: [0 1 0 2 0 3] You can also define multi-dimensional arrays: 1 var x [ 2 ][ 3 ] int An array can be compared to other arrays with the same type: 1 2 3 var x = [ 3 ] int { 1 , 2 , 3 } var y = [ ... ] int { 1 , 2 , 3 } fmt . Println ( x == y ) // true Use the known bracket syntax to access array indices: 1 2 3 var x = [ 3 ] int { 1 , 2 , 3 } x [ 0 ] = 5 fmt . Println ( x [ 2 ]) Note You cannot read or write past an array or use negative indices. If you do it, this will result in a compile time error. An out-of-bound read or write during the execution time will result in a panic . We will talk about that later. The builtin function len gives us the length of an array: 1 2 var x = [ 3 ] int { 1 , 2 , 3 } fmt . Println ( len ( x )) will output: 3 Array are used rarely and explcitly. If you define an array with the size [3]int another array with the size [4]int is a different type. This means you cannot use a variable to specify the size, because Go resolves the size at compile time. You cannot use type conversion to convert arrays. For example this won't work: Failure 1 2 3 4 5 6 7 8 9 10 package main import \"fmt\" func main () { var x [ 3 ] int var y = [ 4 ] int ( x ) fmt . Println ( x ) fmt . Println ( y ) } will result in: ./prog.go:7:16: cannot convert x (variable of type [3]int) to type [4]int Therefore you should use arrays only, if you really know the exact length of your array. Slices If you want to use arrays and you do not have a fixed size of elements, use slices. The length is not part of a slice. 1 var x = [] int { 1 , 2 , 3 } Note Using [...] makes arrays, using [] makes slices. Also use the same syntax for slices as for arrays just without the size specifier: 1 2 var x = [] int { 1 : 1 , 3 : 2 , 5 : 3 } var y [][] int You can read and write slices with the bracket syntax. Read or write past a slice or using negative syntax is not allowed: 1 2 x [ 0 ] = 20 fmt . Println ( x [ 1 ]) If you declare a slice without initializing it the zero value for a slice is nil . So if you want to check if a slice has been initialized use: 1 2 var x [] int fmt . Println ( x != nil ) // -> false A slice is not a comparable. You can use following built-in functions for slices: len append cap make As for arrays you can use len to get the length of a slice: 1 2 var x [] int fmt . Println ( len ( x )) // 0 The built-in append function can add elements to slices: 1 2 var x [] int x = append ( x , 1 ) The append function takes at least two parameters, a slice of any type and a value of that type. It returns a new slice of the same type and the appended element at the end. You can append more than one value: 1 2 var x = [] int { 0 } x = append ( x , 1 , 2 , 3 ) You can also append one slice to another by using variadic symbol: 1 2 3 4 var x = [] int { 1 , 2 , 3 } var y = [] int { 4 , 5 , 6 } x = append ( x , y ... ) fmt . Println ( x ) output: [1 2 3 4 5 6] If you do not assign the return value of an append call, it will result in a compile time error: Failure 1 2 3 4 var x = [] int { 1 , 2 , 3 } var y = [] int { 4 , 5 , 6 } append ( x , y ... ) fmt . Println ( x ) will result in: append(x, y...) (value of type []int) is not used Go is a call by value language, therefore Go makes a copy of the slice that you pass in, adds an element and return the new copy. Capacity With capacity you retrieve the reserved consecutive memory locations. This can be larger than the length of a slice. Each time you append to a slice Go checks if the capacity is reached and allocates more memory for your slice. It takes some time, if you append to a slice which has reached it's capacity and Go allocates a new bigger slice, copies the values to the new slice and garbage collects the old slice. Therefore has following rule for handling with capacities: from 0 to 1024 Go doubles the sizes of the current capacity from 1024 to maximum default integer of the target built (32bit or 64bit) increase by 25% cap returns the current capacity of a slice. Let's see how append and cap changes: 1 2 3 4 5 6 7 8 9 10 11 12 var x [] int fmt . Println ( x , len ( x ), cap ( x )) x = append ( x , 1 ) fmt . Println ( x , len ( x ), cap ( x )) x = append ( x , 2 ) fmt . Println ( x , len ( x ), cap ( x )) x = append ( x , 3 ) fmt . Println ( x , len ( x ), cap ( x )) x = append ( x , 4 ) fmt . Println ( x , len ( x ), cap ( x )) x = append ( x , 5 ) fmt . Println ( x , len ( x ), cap ( x )) output: [] 0 0 [1] 1 1 [1 2] 2 2 [1 2 3] 3 4 [1 2 3 4] 4 4 [1 2 3 4 5] 5 8 This is just a syntactic sugar, to not care about sizes. But if you need to make the code more efficient and especially work with big data inside your slices use make . With make you create a slice with a defined length : x := make([]int, 5) This creates a slice with an initial length of 5. x is not nil and is already initialized with zero values from index 0 to 4. If you try to use append , because you want to start to fill the slice, it can be a mistake: 1 2 x := make ([] int , 5 ) x = append ( x , 1 ) would append to an initialized slice, which would have 5 int zero values and an appended element: [0, 0, 0, 0, 0, 1] With the cap function you can also optionally specify the capacity of a slice. 1 x := make ([] int , 5 , 10 ) This would create a slice of length 5 and a capacity of 10. If you want to initial the slice with append just make a slice if the initial length of 0 and a preferred capacity: 1 2 3 4 5 x := make ([] int , 0 , 4 ) x = append ( x , 1 ) x = append ( x , 2 ) x = append ( x , 3 , 4 ) fmt . Println ( x ) output: [1 2 3 4] Slicing You can use slicing with slices to define a \"from\" \"to\" (excluded) range. If you do not the \"from\" range 0 will be assumed, as for \"to\". 1 2 3 4 5 x := [] int { 1 , 2 , 3 , 4 } fmt . Println ( x [: 2 ]) fmt . Println ( x [ 1 :]) fmt . Println ( x [ 1 : 2 ]) fmt . Println ( x [:]) output: [1 2] [2 3 4] [2] [1 2 3 4] Note You will not make a copy of a slice, if you use slicing. Slicings of a slice share the same memory and can be modified. Let's see how we modify the sliced slice to the original slice: 1 2 3 4 x := [] int { 1 , 2 , 3 , 4 } y := x [: 1 ] y [ 0 ] = 9 fmt . Println ( x ) output: [9 2 3 4] If you have arrays, you can convert them to a slice by using slicing. 1 2 3 4 5 x := [ 4 ] int { 1 , 2 , 3 , 4 } y := x [:] y = append ( y , 1 ) fmt . Println ( x ) fmt . Println ( y ) Output: [1 2 3 4] [1 2 3 4 1] If you want to copy a slice you can use the built-in function. It copies all values from a source slice into a destination slice, but consider that the parameters are swapped: copy(destination, source) . copy is limited to the length of the smaller slice (the capacity doesn't matter). So for example: 1 2 3 4 x := [] int { 1 , 2 , 3 , 4 } y := make ([] int , 2 ) num := copy ( x , y ) fmt . Println ( num , y ) output: 2 [1 2] Maps Maps are key-value variables. Maps are not comparable. Let's see how to declare one: 1 2 3 var myMap map [ string ] int fmt . Println ( myMap == nil ) // -> true If you want to create a map you have several options: 1 2 3 4 5 6 7 8 classes := map [ string ][] string { \"Class 1\" : [] string { \"Sarah\" , \"Peter\" , \"Justin\" , }, \"Class 2\" : [] string { \"Fred\" , \"Ralph\" , \"Lea\" , }, } or use the built-int make function. This will create a 10 length key-value pair map. But, other than slices, it will have a length of 0. 1 classes := make ( map [ string ] int , 10 ) The key of a slice can be a comparable type . Reading and writing to a map is similar to reading and writing to slices: 1 2 3 4 5 6 7 8 9 10 11 12 13 class1 := \"Class 1\" class2 := \"Class 2\" classes := map [ string ][] string { class1 : [] string { \"Sarah\" , \"Peter\" , \"Justin\" , }, class2 : [] string { \"Fred\" , \"Ralph\" , \"Lea\" , }, } fmt . Println ( classes ) classes [ class1 ] = append ( classes [ class1 ], \"Christian\" ) fmt . Println ( classes [ class1 ]) output: map[Class 1:[Sarah Peter Justin] Class 2:[Fred Ralph Lea]] [Sarah Peter Justin Christian] If you access a key which is not assigned to the map, it will return the zero value to that type: 1 2 3 4 5 6 7 8 9 10 11 classes := map [ string ][] string { \"Class 1\" : [] string { \"Sarah\" , \"Peter\" , \"Justin\" }, } fmt . Println ( classes [ \"Not exist\" ]) fmt . Println ( classes [ \"Not exist\" ] == nil ) ages := map [ string ] int { \"Tester\" : 31 , } fmt . Println ( ages [ \"Not exist\" ]) fmt . Println ( ages [ \"Not exist\" ] == 0 ) output: [] true 0 true variable, ok := idiom Sometimes you don't want to explicitly check for the zero value like \"\" for strings or 0 for numeric values. There is a syntactic sugar, which helps to do that properly: 1 2 3 4 5 6 7 8 9 10 example := map [ string ] int { \"Hello\" : 119 , \"World\" : 312 , } value , ok := example [ \"Hello\" ] fmt . Println ( value , ok ) value , ok = example [ \"NotExist\" ] fmt . Println ( value , ok ) output: 119 true 0 false If the key is present it will return the value as first return value and a boolean true in the second return value. If the key is not preset it will return the zero value as first return value and a boolean false in the second return value. If you need to delete from maps you can use the built-in delete function. The delete function takes a map and the key. If the key is not present or the map is nil nothing happens. The delete function does not return any value. 1 2 3 4 5 6 example := map [ string ] int { \"Hello\" : 119 , \"World\" : 312 , } delete ( example , \"Hello\" ) delete ( example , \"Test\" ) Structs With maps you can define dynamic data, but they have limitations. All values have to have the same type and you cannot define which keys are public or private. If you know already what classes are, this is probably what you are searching for: a struct Here is a struct: 1 2 3 4 5 type person struct { firstName string lastName string age int } You can define structs inside or outside functions (respecting the scopes). If you declared a struct type, you can use it: 1 var michael person The variable gets the zero value of a struct which the nil value. If you want to initialize a struct use {} , this will initialize the struct with zero values for all fields. 1 2 3 4 5 var michael = person { \"Michael\" , \"Bykovski\" , 28 , } alternatively you can use the field names to make it explicit: 1 2 3 4 5 var michael = person { firstName : \"Michael\" , lastName : \"Bykovski\" , age : 28 , } Access a struct field by punctuation: 1 2 3 4 5 6 7 var michael = person { firstName : \"Michael\" , lastName : \"Bykovski\" , age : 28 , } michael . age ++ fmt . Println ( michael ) output: {Michael Bykovski 29} Anonymous structs An anonymous struct is a struct without a name. Let's look at an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 var person struct { firstName string lastName string age int } pet := struct { name string kind string } { name : \"Jukes\" , kind : \"cat\" , } Anonymous structs are useful if you want to serialize and deserialize data, which is called \"marshal\" and \"unmarshal\" in Go. Comparing and Converting Structs If you want to compare structs, Go only compares structs if the fields of a given struct are all comparable . So if you have a list or a map in a struct, it becomes not comparable. If you want to have a custom compare function, you can write your own method. If you compare two different type structs Go will falsify it. But you can do a type conversion between two type structs if they have the same field signatures . Let's first look at a successful type conversion but failed comparison. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 type firstPet struct { name string kind string } type secondPet struct { name string kind string } pet := firstPet { name : \"Jukes\" , kind : \"cat\" , } var pet2 secondPet pet2 = secondPet ( pet ) fmt . Println ( pet2 ) //fmt.Println(pet2 == pet) Type conversion on line 16 would work. But it would fail on line 18 because invalid operation: pet2 == pet (mismatched types secondPet and firstPet) Now let's look at failed type conversions and therefore failed comparisons. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 type firstPet struct { name string kind string } // wrong order type thirdPet struct { kind string name string } // wrong name type fourthPet struct { name string race string } // wrong signatures type fifthPet struct { name string kind string age int } pet := firstPet { name : \"Jukes\" , kind : \"cat\" , } var pet3 thirdPet var pet4 fourthPet var pet5 fifthPet pet3 = thirdPet ( pet ) pet4 = fourthPet ( pet ) pet5 = fifthPet ( pet ) Cannot type convert to any type, because all field signatures are wrong: ./prog.go:41:17: cannot convert pet (variable of type firstPet) to type thirdPet ./prog.go:42:18: cannot convert pet (variable of type firstPet) to type fourthPet ./prog.go:43:17: cannot convert pet (variable of type firstPet) to type fifthPet Now we look at a successfull type conversion and comparison: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type firstPet struct { name string kind string } var anonymousPet struct { name string kind string } pet := firstPet { name : \"Jukes\" , kind : \"cat\" , } anonymousPet = pet fmt . Println ( pet , anonymousPet , anonymousPet == pet ) output: {Jukes cat} {Jukes cat} true","title":"Composite Types"},{"location":"golang/golang-fundamentals/composite_types/#composite-types","text":"Composite types in Go contain more functionality than the primitive types. There are builtin functions in Go to support composite types. Let's see how to use them and what are the best practices.","title":"Composite Types"},{"location":"golang/golang-fundamentals/composite_types/#comparable-types","text":"This types are comparable: Boolean Numeric String, Pointer Channel Interface types Structs \u2013 if all it\u2019s field type is comparable Array \u2013 if the type of value of array element is comparable This are not comparable types: Slice Map Function","title":"Comparable Types"},{"location":"golang/golang-fundamentals/composite_types/#arrays","text":"Arrays aren't used directly. Normally Go developers use Slices, we will see why in the next chapter, but let's first check what Arrays are and how to use them. First we look at the declaration of an array: 1 var x [ 3 ] int This creates an array of three ints ( x[0] , x[1] , x[2] ), each initialized to a zero value ( 0 ). If you want to define the values for all array elements use the array literal: 1 var x = [ 3 ] int { 1 , 2 , 3 } If can specify the indices of a new array: 1 2 3 4 5 var x = [ 10 ] int { 1 : 1 , 3 : 2 , 5 : 3 , } This will create the following array: [0 1 0 2 0 3 0 0 0 0] If you want to initialize an array with a dynamic number of values use the variadic keyword ... . 1 2 3 4 5 6 var x = [ ... ] int { 1 : 1 , 3 : 2 , 5 : 3 , } fmt . Println ( x ) This will create the following array: [0 1 0 2 0 3] You can also define multi-dimensional arrays: 1 var x [ 2 ][ 3 ] int An array can be compared to other arrays with the same type: 1 2 3 var x = [ 3 ] int { 1 , 2 , 3 } var y = [ ... ] int { 1 , 2 , 3 } fmt . Println ( x == y ) // true Use the known bracket syntax to access array indices: 1 2 3 var x = [ 3 ] int { 1 , 2 , 3 } x [ 0 ] = 5 fmt . Println ( x [ 2 ]) Note You cannot read or write past an array or use negative indices. If you do it, this will result in a compile time error. An out-of-bound read or write during the execution time will result in a panic . We will talk about that later. The builtin function len gives us the length of an array: 1 2 var x = [ 3 ] int { 1 , 2 , 3 } fmt . Println ( len ( x )) will output: 3 Array are used rarely and explcitly. If you define an array with the size [3]int another array with the size [4]int is a different type. This means you cannot use a variable to specify the size, because Go resolves the size at compile time. You cannot use type conversion to convert arrays. For example this won't work: Failure 1 2 3 4 5 6 7 8 9 10 package main import \"fmt\" func main () { var x [ 3 ] int var y = [ 4 ] int ( x ) fmt . Println ( x ) fmt . Println ( y ) } will result in: ./prog.go:7:16: cannot convert x (variable of type [3]int) to type [4]int Therefore you should use arrays only, if you really know the exact length of your array.","title":"Arrays"},{"location":"golang/golang-fundamentals/composite_types/#slices","text":"If you want to use arrays and you do not have a fixed size of elements, use slices. The length is not part of a slice. 1 var x = [] int { 1 , 2 , 3 } Note Using [...] makes arrays, using [] makes slices. Also use the same syntax for slices as for arrays just without the size specifier: 1 2 var x = [] int { 1 : 1 , 3 : 2 , 5 : 3 } var y [][] int You can read and write slices with the bracket syntax. Read or write past a slice or using negative syntax is not allowed: 1 2 x [ 0 ] = 20 fmt . Println ( x [ 1 ]) If you declare a slice without initializing it the zero value for a slice is nil . So if you want to check if a slice has been initialized use: 1 2 var x [] int fmt . Println ( x != nil ) // -> false A slice is not a comparable. You can use following built-in functions for slices: len append cap make As for arrays you can use len to get the length of a slice: 1 2 var x [] int fmt . Println ( len ( x )) // 0 The built-in append function can add elements to slices: 1 2 var x [] int x = append ( x , 1 ) The append function takes at least two parameters, a slice of any type and a value of that type. It returns a new slice of the same type and the appended element at the end. You can append more than one value: 1 2 var x = [] int { 0 } x = append ( x , 1 , 2 , 3 ) You can also append one slice to another by using variadic symbol: 1 2 3 4 var x = [] int { 1 , 2 , 3 } var y = [] int { 4 , 5 , 6 } x = append ( x , y ... ) fmt . Println ( x ) output: [1 2 3 4 5 6] If you do not assign the return value of an append call, it will result in a compile time error: Failure 1 2 3 4 var x = [] int { 1 , 2 , 3 } var y = [] int { 4 , 5 , 6 } append ( x , y ... ) fmt . Println ( x ) will result in: append(x, y...) (value of type []int) is not used Go is a call by value language, therefore Go makes a copy of the slice that you pass in, adds an element and return the new copy.","title":"Slices"},{"location":"golang/golang-fundamentals/composite_types/#capacity","text":"With capacity you retrieve the reserved consecutive memory locations. This can be larger than the length of a slice. Each time you append to a slice Go checks if the capacity is reached and allocates more memory for your slice. It takes some time, if you append to a slice which has reached it's capacity and Go allocates a new bigger slice, copies the values to the new slice and garbage collects the old slice. Therefore has following rule for handling with capacities: from 0 to 1024 Go doubles the sizes of the current capacity from 1024 to maximum default integer of the target built (32bit or 64bit) increase by 25% cap returns the current capacity of a slice. Let's see how append and cap changes: 1 2 3 4 5 6 7 8 9 10 11 12 var x [] int fmt . Println ( x , len ( x ), cap ( x )) x = append ( x , 1 ) fmt . Println ( x , len ( x ), cap ( x )) x = append ( x , 2 ) fmt . Println ( x , len ( x ), cap ( x )) x = append ( x , 3 ) fmt . Println ( x , len ( x ), cap ( x )) x = append ( x , 4 ) fmt . Println ( x , len ( x ), cap ( x )) x = append ( x , 5 ) fmt . Println ( x , len ( x ), cap ( x )) output: [] 0 0 [1] 1 1 [1 2] 2 2 [1 2 3] 3 4 [1 2 3 4] 4 4 [1 2 3 4 5] 5 8 This is just a syntactic sugar, to not care about sizes. But if you need to make the code more efficient and especially work with big data inside your slices use make . With make you create a slice with a defined length : x := make([]int, 5) This creates a slice with an initial length of 5. x is not nil and is already initialized with zero values from index 0 to 4. If you try to use append , because you want to start to fill the slice, it can be a mistake: 1 2 x := make ([] int , 5 ) x = append ( x , 1 ) would append to an initialized slice, which would have 5 int zero values and an appended element: [0, 0, 0, 0, 0, 1] With the cap function you can also optionally specify the capacity of a slice. 1 x := make ([] int , 5 , 10 ) This would create a slice of length 5 and a capacity of 10. If you want to initial the slice with append just make a slice if the initial length of 0 and a preferred capacity: 1 2 3 4 5 x := make ([] int , 0 , 4 ) x = append ( x , 1 ) x = append ( x , 2 ) x = append ( x , 3 , 4 ) fmt . Println ( x ) output: [1 2 3 4]","title":"Capacity"},{"location":"golang/golang-fundamentals/composite_types/#slicing","text":"You can use slicing with slices to define a \"from\" \"to\" (excluded) range. If you do not the \"from\" range 0 will be assumed, as for \"to\". 1 2 3 4 5 x := [] int { 1 , 2 , 3 , 4 } fmt . Println ( x [: 2 ]) fmt . Println ( x [ 1 :]) fmt . Println ( x [ 1 : 2 ]) fmt . Println ( x [:]) output: [1 2] [2 3 4] [2] [1 2 3 4] Note You will not make a copy of a slice, if you use slicing. Slicings of a slice share the same memory and can be modified. Let's see how we modify the sliced slice to the original slice: 1 2 3 4 x := [] int { 1 , 2 , 3 , 4 } y := x [: 1 ] y [ 0 ] = 9 fmt . Println ( x ) output: [9 2 3 4] If you have arrays, you can convert them to a slice by using slicing. 1 2 3 4 5 x := [ 4 ] int { 1 , 2 , 3 , 4 } y := x [:] y = append ( y , 1 ) fmt . Println ( x ) fmt . Println ( y ) Output: [1 2 3 4] [1 2 3 4 1] If you want to copy a slice you can use the built-in function. It copies all values from a source slice into a destination slice, but consider that the parameters are swapped: copy(destination, source) . copy is limited to the length of the smaller slice (the capacity doesn't matter). So for example: 1 2 3 4 x := [] int { 1 , 2 , 3 , 4 } y := make ([] int , 2 ) num := copy ( x , y ) fmt . Println ( num , y ) output: 2 [1 2]","title":"Slicing"},{"location":"golang/golang-fundamentals/composite_types/#maps","text":"Maps are key-value variables. Maps are not comparable. Let's see how to declare one: 1 2 3 var myMap map [ string ] int fmt . Println ( myMap == nil ) // -> true If you want to create a map you have several options: 1 2 3 4 5 6 7 8 classes := map [ string ][] string { \"Class 1\" : [] string { \"Sarah\" , \"Peter\" , \"Justin\" , }, \"Class 2\" : [] string { \"Fred\" , \"Ralph\" , \"Lea\" , }, } or use the built-int make function. This will create a 10 length key-value pair map. But, other than slices, it will have a length of 0. 1 classes := make ( map [ string ] int , 10 ) The key of a slice can be a comparable type . Reading and writing to a map is similar to reading and writing to slices: 1 2 3 4 5 6 7 8 9 10 11 12 13 class1 := \"Class 1\" class2 := \"Class 2\" classes := map [ string ][] string { class1 : [] string { \"Sarah\" , \"Peter\" , \"Justin\" , }, class2 : [] string { \"Fred\" , \"Ralph\" , \"Lea\" , }, } fmt . Println ( classes ) classes [ class1 ] = append ( classes [ class1 ], \"Christian\" ) fmt . Println ( classes [ class1 ]) output: map[Class 1:[Sarah Peter Justin] Class 2:[Fred Ralph Lea]] [Sarah Peter Justin Christian] If you access a key which is not assigned to the map, it will return the zero value to that type: 1 2 3 4 5 6 7 8 9 10 11 classes := map [ string ][] string { \"Class 1\" : [] string { \"Sarah\" , \"Peter\" , \"Justin\" }, } fmt . Println ( classes [ \"Not exist\" ]) fmt . Println ( classes [ \"Not exist\" ] == nil ) ages := map [ string ] int { \"Tester\" : 31 , } fmt . Println ( ages [ \"Not exist\" ]) fmt . Println ( ages [ \"Not exist\" ] == 0 ) output: [] true 0 true","title":"Maps"},{"location":"golang/golang-fundamentals/composite_types/#variable-ok-idiom","text":"Sometimes you don't want to explicitly check for the zero value like \"\" for strings or 0 for numeric values. There is a syntactic sugar, which helps to do that properly: 1 2 3 4 5 6 7 8 9 10 example := map [ string ] int { \"Hello\" : 119 , \"World\" : 312 , } value , ok := example [ \"Hello\" ] fmt . Println ( value , ok ) value , ok = example [ \"NotExist\" ] fmt . Println ( value , ok ) output: 119 true 0 false If the key is present it will return the value as first return value and a boolean true in the second return value. If the key is not preset it will return the zero value as first return value and a boolean false in the second return value. If you need to delete from maps you can use the built-in delete function. The delete function takes a map and the key. If the key is not present or the map is nil nothing happens. The delete function does not return any value. 1 2 3 4 5 6 example := map [ string ] int { \"Hello\" : 119 , \"World\" : 312 , } delete ( example , \"Hello\" ) delete ( example , \"Test\" )","title":"variable, ok := idiom"},{"location":"golang/golang-fundamentals/composite_types/#structs","text":"With maps you can define dynamic data, but they have limitations. All values have to have the same type and you cannot define which keys are public or private. If you know already what classes are, this is probably what you are searching for: a struct Here is a struct: 1 2 3 4 5 type person struct { firstName string lastName string age int } You can define structs inside or outside functions (respecting the scopes). If you declared a struct type, you can use it: 1 var michael person The variable gets the zero value of a struct which the nil value. If you want to initialize a struct use {} , this will initialize the struct with zero values for all fields. 1 2 3 4 5 var michael = person { \"Michael\" , \"Bykovski\" , 28 , } alternatively you can use the field names to make it explicit: 1 2 3 4 5 var michael = person { firstName : \"Michael\" , lastName : \"Bykovski\" , age : 28 , } Access a struct field by punctuation: 1 2 3 4 5 6 7 var michael = person { firstName : \"Michael\" , lastName : \"Bykovski\" , age : 28 , } michael . age ++ fmt . Println ( michael ) output: {Michael Bykovski 29}","title":"Structs"},{"location":"golang/golang-fundamentals/composite_types/#anonymous-structs","text":"An anonymous struct is a struct without a name. Let's look at an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 var person struct { firstName string lastName string age int } pet := struct { name string kind string } { name : \"Jukes\" , kind : \"cat\" , } Anonymous structs are useful if you want to serialize and deserialize data, which is called \"marshal\" and \"unmarshal\" in Go.","title":"Anonymous structs"},{"location":"golang/golang-fundamentals/composite_types/#comparing-and-converting-structs","text":"If you want to compare structs, Go only compares structs if the fields of a given struct are all comparable . So if you have a list or a map in a struct, it becomes not comparable. If you want to have a custom compare function, you can write your own method. If you compare two different type structs Go will falsify it. But you can do a type conversion between two type structs if they have the same field signatures . Let's first look at a successful type conversion but failed comparison. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 type firstPet struct { name string kind string } type secondPet struct { name string kind string } pet := firstPet { name : \"Jukes\" , kind : \"cat\" , } var pet2 secondPet pet2 = secondPet ( pet ) fmt . Println ( pet2 ) //fmt.Println(pet2 == pet) Type conversion on line 16 would work. But it would fail on line 18 because invalid operation: pet2 == pet (mismatched types secondPet and firstPet) Now let's look at failed type conversions and therefore failed comparisons. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 type firstPet struct { name string kind string } // wrong order type thirdPet struct { kind string name string } // wrong name type fourthPet struct { name string race string } // wrong signatures type fifthPet struct { name string kind string age int } pet := firstPet { name : \"Jukes\" , kind : \"cat\" , } var pet3 thirdPet var pet4 fourthPet var pet5 fifthPet pet3 = thirdPet ( pet ) pet4 = fourthPet ( pet ) pet5 = fifthPet ( pet ) Cannot type convert to any type, because all field signatures are wrong: ./prog.go:41:17: cannot convert pet (variable of type firstPet) to type thirdPet ./prog.go:42:18: cannot convert pet (variable of type firstPet) to type fourthPet ./prog.go:43:17: cannot convert pet (variable of type firstPet) to type fifthPet Now we look at a successfull type conversion and comparison: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type firstPet struct { name string kind string } var anonymousPet struct { name string kind string } pet := firstPet { name : \"Jukes\" , kind : \"cat\" , } anonymousPet = pet fmt . Println ( pet , anonymousPet , anonymousPet == pet ) output: {Jukes cat} {Jukes cat} true","title":"Comparing and Converting Structs"},{"location":"golang/golang-fundamentals/concurrency/","text":"Concurrency When to use concurrency More Concurrency != More Speed Concurrency != Parallelism Concurrency is doing a lot of things at once, Parallelism is doing a lot of things at the same time. Generalizing on that a bit, any producer-consumer problem is a natural fit for 2 goroutines using a channel to pass outputs from the producer to the consumer. Another good use for concurrency is interacting with multiple input/output sources (disks, network, terminal, etc.). Your program should be able to wake up and do some work whenever a result comes from any of these sources. It is possible to do this with one thread and a system call like poll(2) or select(2). When your thread wakes up, it must figure out which result came in, find where it left off in the relevant task, and pick up from there. That's a lot of code you need to write. Writing that code is much easier using one goroutine per task. Then the state of that task is captured implicitly in the goroutine, and picking up where it left off is as simple as waking up and running. Source Go Concurrency Guide Scheduler Every programm gets executed as a process and every process has one or many threads. The scheduler of an operating system decides which process (and the threads within a process) gets a specific amount of time to calculate. Go has it's own scheduler which creates some threads at the start of your Go application. The main function is actually the first Goroutine running in your Go application. Go schedules and assigns Goroutines to the created threads so that the system-overhead can be minimized. There are some benefits by doing that: Goroutines are created faster than usual system threads Goroutines stack sizes are smaller than usual system threads Switching between Goroutines is faster than switching betweens system threads because it happens within the Go programm (process), avoiding system calls The Go scheduler can optimize goroutines by themselves, because it's part of the Go process. It can decide to pause and resume a goroutine because it could have a blocking go operation (channel, mutex) or a blocking system call (ntework, IO, garbage collection). By implementing an own scheduler, this allows to spawn more than ten thousand of simultaneous goroutines. Try so spawn ten thousand system threads, this would result in a mess. Goroutines Goroutines are executed by the keyword go before a function invocation. Don't see it as a async/await, it's more a \"go and never come back\" execution. If you want to return values from your goroutine don't use return, use it with Channels . 1 2 3 4 5 6 7 8 9 10 func Compute () { for i := 0 ; i < 10 _000_000_000 ; i ++ {} fmt . Println ( \"Done\" ) } func main () { fmt . Println ( \"Starting\" ) go Compute () fmt . Println ( \"After Compute\" ) } output: Starting After Compute Channels Channels are like slices and maps, they are a built-in type and can be created using the make function. 1 ch := make ( chan int ) Channels are referenced, this means that channels are actually pointers. The zero value for channels are nil . Reading, Writing Channels The <- operator is used to read or write from channels. If you want to read from a channel, place the operator on the left side; writing on the right side. 1 2 val := <- ch // reading ch <- 3 // writing Values written to a channel can be read only once. If multiple goroutines try to read from a channel, only one will get the value. If you pass a channel into a function, indicate if the function will read or write from the channel. By doing this, you tell the compiler to check, if you only read or write to a channel. Usually a function read from one channel and writes into another. 1 2 3 4 5 6 7 8 func execute ( in <- chan int , out chan <- int ) { go func () { for val := range in { result := process ( val ) out <- result } }() } Go uses unbuffered channels by default. Every write to an open, unbuffered channel causes the writing goroutine to pause until another goroutine reads from this channel. Every read to an open, unbuffered channel causes the reading goroutine to pause until another goroutine writes from this channel. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import ( \"fmt\" \"time\" ) func hello ( done chan bool ) { fmt . Println ( \"Hello world goroutine\" ) time . Sleep ( 5 * time . Second ) done <- true } func main () { done := make ( chan bool ) go hello ( done ) fmt . Println ( \"waiting...\" ) <- done fmt . Println ( \"main function\" ) } will output: waiting... Hello world goroutine main function Buffered Channels Go has buffered channels. This means, that those channels have a limited number of writes without blocking. If the buffer fills before the channel was read from a goroutine, it will block until the channel is read. Reading from an empty buffer blocks also. Creating a buffered channel works the same way as creating an unbuffered channels, but you enter a capacity: 1 ch := make ( chan int , 10 ) len can be used to check, how many values are currently in the channel. cap ca be used to find out the maximum buffer size. Looping over a channel You can use the for-range loop. The loop loops until the channel is closed, until a break or return inside of the loop. 1 2 3 for v := range ch { fmt . Println ( v ) } Closing a channel Close a channel if you are done writing to it: 1 close ( ch ) If you attempt to write or try to close the channel again, Go will panic. Reading from a closed channel works, it will return the zero value of the channels type. When we can always read from a channel, how we can tell if the channel is closed or open and we just read a zero value? We can use the comma ok idiom to check if the channel is closed. If the channel is closed, ok is false; true otherwise: 1 v , ok := <- ch The responsibility to close a channel lies with the goroutine that writes to a channel. Closing is only required, if another goroutine waits for new inputs. This example would result in a deadlock: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import ( \"fmt\" \"time\" ) func hello ( done chan bool ) { fmt . Println ( \"Hello world goroutine\" ) fmt . Println ( \"Waiting 1 seconds\" ) time . Sleep ( 1 * time . Second ) done <- true fmt . Println ( \"Waiting 1 seconds\" ) time . Sleep ( 1 * time . Second ) done <- true } func main () { done := make ( chan bool ) go hello ( done ) for value := range done { fmt . Println ( value ) } } output: Hello world goroutine Waiting 1 seconds true Waiting 1 seconds true fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan receive]: main.main() /Users/michaelbykovski/workspace/daimler/golang_workshop/goroutines_sleep/main.go:21 +0xd0 exit status 2 Because the main function would wait for a new value which cannot be filled by any \"active\" goroutine. To fix that you should close the channel, so that the for-range loop stops: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import ( \"fmt\" \"time\" ) func hello ( done chan bool ) { fmt . Println ( \"Hello world goroutine\" ) fmt . Println ( \"Waiting 1 seconds\" ) time . Sleep ( 1 * time . Second ) done <- true fmt . Println ( \"Waiting 1 seconds\" ) time . Sleep ( 1 * time . Second ) done <- true close ( done ) } func main () { done := make ( chan bool ) go hello ( done ) for value := range done { fmt . Println ( value ) } } output: Hello world goroutine Waiting 1 seconds Waiting 1 seconds true true Select Select statements can be used, to wait for multiple channels simultaneously. Select blocks until one of it's cases fulfills. If multiple cases are ready, it chooses one randomly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import ( \"fmt\" \"time\" ) func main () { one := make ( chan string ) two := make ( chan string ) go func () { time . Sleep ( time . Second * 1 ) one <- \"One\" }() go func () { time . Sleep ( time . Second * 1 ) two <- \"Two\" }() select { case result := <- one : fmt . Println ( \"Received:\" , result ) case result := <- two : fmt . Println ( \"Received:\" , result ) } close ( one ) close ( two ) } This will output sometime two and sometimes one . output: Received: One The done channel pattern Sometimes you have multiple goroutines started, but you wait for only one to resolve and then you need to stop all the others. Then you need the done channel pattern: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import ( \"fmt\" \"math/rand\" \"time\" ) type searcherFunc func ( string ) string func searchData ( s string , searchers [] searcherFunc ) string { done := make ( chan bool ) result := make ( chan string ) for _ , searcher := range searchers { go func ( searcher searcherFunc ) { select { case result <- searcher ( s ): case <- done : } }( searcher ) } r := <- result close ( done ) return r } func RandomBetween ( min int , max int ) int { return rand . Intn ( max - min ) + min } func main () { searchers := [] searcherFunc { func ( s string ) string { sleepSeconds := time . Second * time . Duration ( RandomBetween ( 1 , 10 )) time . Sleep ( sleepSeconds ) return \"First!\" }, func ( s string ) string { sleepSeconds := time . Second * time . Duration ( RandomBetween ( 1 , 10 )) time . Sleep ( sleepSeconds ) return \"Second!\" }, func ( s string ) string { sleepSeconds := time . Second * time . Duration ( RandomBetween ( 1 , 10 )) time . Sleep ( sleepSeconds ) return \"Third!\" }, } data := searchData ( \"test\" , searchers ) fmt . Println ( data ) } WaitGroups WaitGroups are handy if you have multiple goroutines and you want to wait for all to finish. The sync package provides the WaitGroup struct. It has the following functions: Add(int) Done() Wait() Let's see the WaitGroup in practice: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import ( \"fmt\" \"sync\" ) func work ( wg * sync . WaitGroup ) { defer wg . Done () fmt . Println ( \"working...\" ) } func main () { var wg sync . WaitGroup wg . Add ( 4 ) go work ( & wg ) go work ( & wg ) go work ( & wg ) go work ( & wg ) fmt . Println ( \"Now lets wait for all to finish\" ) wg . Wait () fmt . Println ( \"All finished\" ) } output: Now lets wait for all to finish working... working... working... working... All finished Mutexes Mutexes are also located in the sync library. Mutexes help to Lock and Unlock critical sections, to prevent race conditions. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \"fmt\" \"sync\" ) type Counter struct { value int } func ( c * Counter ) Update ( n int , wg * sync . WaitGroup ) { value := c . value defer wg . Done () fmt . Printf ( \"Adding %d to %d\\n\" , n , value ) c . value = value + n } func main () { var wg sync . WaitGroup c := Counter {} wg . Add ( 4 ) go c . Update ( 10 , & wg ) go c . Update ( - 5 , & wg ) go c . Update ( 25 , & wg ) go c . Update ( 19 , & wg ) wg . Wait () fmt . Println ( c . value ) } c.Update() works on the c.value variable and since they are all running concurrent, you never now, which value is currently in c.value . output: Adding 19 to 0 Adding -5 to 0 Adding 10 to 0 Adding 25 to 0 25 You can fix that by using Mutex : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 type Counter struct { m sync . Mutex value int } func ( c * Counter ) Update ( n int , wg * sync . WaitGroup ) { c . m . Lock () defer wg . Done () fmt . Printf ( \"Adding %d to %d\\n\" , n , c . value ) c . value += n c . m . Unlock () } func main () { var wg sync . WaitGroup c := Counter {} wg . Add ( 4 ) go c . Update ( 10 , & wg ) go c . Update ( - 5 , & wg ) go c . Update ( 25 , & wg ) go c . Update ( 19 , & wg ) wg . Wait () fmt . Println ( c . value ) } Now the output is correct, because we Lock the critical section c.value and only one goroutine is allowed to work on it until it Unlock the Mutex again. Adding 19 to 0 Adding 10 to 19 Adding -5 to 29 Adding 25 to 24 49 Concurrency in Go Concurrency can be very frustrating, because a lot of things happen at the same time in your application and it can be very hard to predict or even debug, what is happening. For this there is a very good book by Katherine Cox-Buday it's called Concurrency in Go .","title":"Concurrency"},{"location":"golang/golang-fundamentals/concurrency/#concurrency","text":"","title":"Concurrency"},{"location":"golang/golang-fundamentals/concurrency/#when-to-use-concurrency","text":"More Concurrency != More Speed Concurrency != Parallelism Concurrency is doing a lot of things at once, Parallelism is doing a lot of things at the same time. Generalizing on that a bit, any producer-consumer problem is a natural fit for 2 goroutines using a channel to pass outputs from the producer to the consumer. Another good use for concurrency is interacting with multiple input/output sources (disks, network, terminal, etc.). Your program should be able to wake up and do some work whenever a result comes from any of these sources. It is possible to do this with one thread and a system call like poll(2) or select(2). When your thread wakes up, it must figure out which result came in, find where it left off in the relevant task, and pick up from there. That's a lot of code you need to write. Writing that code is much easier using one goroutine per task. Then the state of that task is captured implicitly in the goroutine, and picking up where it left off is as simple as waking up and running. Source Go Concurrency Guide","title":"When to use concurrency"},{"location":"golang/golang-fundamentals/concurrency/#scheduler","text":"Every programm gets executed as a process and every process has one or many threads. The scheduler of an operating system decides which process (and the threads within a process) gets a specific amount of time to calculate. Go has it's own scheduler which creates some threads at the start of your Go application. The main function is actually the first Goroutine running in your Go application. Go schedules and assigns Goroutines to the created threads so that the system-overhead can be minimized. There are some benefits by doing that: Goroutines are created faster than usual system threads Goroutines stack sizes are smaller than usual system threads Switching between Goroutines is faster than switching betweens system threads because it happens within the Go programm (process), avoiding system calls The Go scheduler can optimize goroutines by themselves, because it's part of the Go process. It can decide to pause and resume a goroutine because it could have a blocking go operation (channel, mutex) or a blocking system call (ntework, IO, garbage collection). By implementing an own scheduler, this allows to spawn more than ten thousand of simultaneous goroutines. Try so spawn ten thousand system threads, this would result in a mess.","title":"Scheduler"},{"location":"golang/golang-fundamentals/concurrency/#goroutines","text":"Goroutines are executed by the keyword go before a function invocation. Don't see it as a async/await, it's more a \"go and never come back\" execution. If you want to return values from your goroutine don't use return, use it with Channels . 1 2 3 4 5 6 7 8 9 10 func Compute () { for i := 0 ; i < 10 _000_000_000 ; i ++ {} fmt . Println ( \"Done\" ) } func main () { fmt . Println ( \"Starting\" ) go Compute () fmt . Println ( \"After Compute\" ) } output: Starting After Compute","title":"Goroutines"},{"location":"golang/golang-fundamentals/concurrency/#channels","text":"Channels are like slices and maps, they are a built-in type and can be created using the make function. 1 ch := make ( chan int ) Channels are referenced, this means that channels are actually pointers. The zero value for channels are nil .","title":"Channels"},{"location":"golang/golang-fundamentals/concurrency/#reading-writing-channels","text":"The <- operator is used to read or write from channels. If you want to read from a channel, place the operator on the left side; writing on the right side. 1 2 val := <- ch // reading ch <- 3 // writing Values written to a channel can be read only once. If multiple goroutines try to read from a channel, only one will get the value. If you pass a channel into a function, indicate if the function will read or write from the channel. By doing this, you tell the compiler to check, if you only read or write to a channel. Usually a function read from one channel and writes into another. 1 2 3 4 5 6 7 8 func execute ( in <- chan int , out chan <- int ) { go func () { for val := range in { result := process ( val ) out <- result } }() } Go uses unbuffered channels by default. Every write to an open, unbuffered channel causes the writing goroutine to pause until another goroutine reads from this channel. Every read to an open, unbuffered channel causes the reading goroutine to pause until another goroutine writes from this channel. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import ( \"fmt\" \"time\" ) func hello ( done chan bool ) { fmt . Println ( \"Hello world goroutine\" ) time . Sleep ( 5 * time . Second ) done <- true } func main () { done := make ( chan bool ) go hello ( done ) fmt . Println ( \"waiting...\" ) <- done fmt . Println ( \"main function\" ) } will output: waiting... Hello world goroutine main function","title":"Reading, Writing Channels"},{"location":"golang/golang-fundamentals/concurrency/#buffered-channels","text":"Go has buffered channels. This means, that those channels have a limited number of writes without blocking. If the buffer fills before the channel was read from a goroutine, it will block until the channel is read. Reading from an empty buffer blocks also. Creating a buffered channel works the same way as creating an unbuffered channels, but you enter a capacity: 1 ch := make ( chan int , 10 ) len can be used to check, how many values are currently in the channel. cap ca be used to find out the maximum buffer size.","title":"Buffered Channels"},{"location":"golang/golang-fundamentals/concurrency/#looping-over-a-channel","text":"You can use the for-range loop. The loop loops until the channel is closed, until a break or return inside of the loop. 1 2 3 for v := range ch { fmt . Println ( v ) }","title":"Looping over a channel"},{"location":"golang/golang-fundamentals/concurrency/#closing-a-channel","text":"Close a channel if you are done writing to it: 1 close ( ch ) If you attempt to write or try to close the channel again, Go will panic. Reading from a closed channel works, it will return the zero value of the channels type. When we can always read from a channel, how we can tell if the channel is closed or open and we just read a zero value? We can use the comma ok idiom to check if the channel is closed. If the channel is closed, ok is false; true otherwise: 1 v , ok := <- ch The responsibility to close a channel lies with the goroutine that writes to a channel. Closing is only required, if another goroutine waits for new inputs. This example would result in a deadlock: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import ( \"fmt\" \"time\" ) func hello ( done chan bool ) { fmt . Println ( \"Hello world goroutine\" ) fmt . Println ( \"Waiting 1 seconds\" ) time . Sleep ( 1 * time . Second ) done <- true fmt . Println ( \"Waiting 1 seconds\" ) time . Sleep ( 1 * time . Second ) done <- true } func main () { done := make ( chan bool ) go hello ( done ) for value := range done { fmt . Println ( value ) } } output: Hello world goroutine Waiting 1 seconds true Waiting 1 seconds true fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan receive]: main.main() /Users/michaelbykovski/workspace/daimler/golang_workshop/goroutines_sleep/main.go:21 +0xd0 exit status 2 Because the main function would wait for a new value which cannot be filled by any \"active\" goroutine. To fix that you should close the channel, so that the for-range loop stops: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import ( \"fmt\" \"time\" ) func hello ( done chan bool ) { fmt . Println ( \"Hello world goroutine\" ) fmt . Println ( \"Waiting 1 seconds\" ) time . Sleep ( 1 * time . Second ) done <- true fmt . Println ( \"Waiting 1 seconds\" ) time . Sleep ( 1 * time . Second ) done <- true close ( done ) } func main () { done := make ( chan bool ) go hello ( done ) for value := range done { fmt . Println ( value ) } } output: Hello world goroutine Waiting 1 seconds Waiting 1 seconds true true","title":"Closing a channel"},{"location":"golang/golang-fundamentals/concurrency/#select","text":"Select statements can be used, to wait for multiple channels simultaneously. Select blocks until one of it's cases fulfills. If multiple cases are ready, it chooses one randomly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import ( \"fmt\" \"time\" ) func main () { one := make ( chan string ) two := make ( chan string ) go func () { time . Sleep ( time . Second * 1 ) one <- \"One\" }() go func () { time . Sleep ( time . Second * 1 ) two <- \"Two\" }() select { case result := <- one : fmt . Println ( \"Received:\" , result ) case result := <- two : fmt . Println ( \"Received:\" , result ) } close ( one ) close ( two ) } This will output sometime two and sometimes one . output: Received: One","title":"Select"},{"location":"golang/golang-fundamentals/concurrency/#the-done-channel-pattern","text":"Sometimes you have multiple goroutines started, but you wait for only one to resolve and then you need to stop all the others. Then you need the done channel pattern: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import ( \"fmt\" \"math/rand\" \"time\" ) type searcherFunc func ( string ) string func searchData ( s string , searchers [] searcherFunc ) string { done := make ( chan bool ) result := make ( chan string ) for _ , searcher := range searchers { go func ( searcher searcherFunc ) { select { case result <- searcher ( s ): case <- done : } }( searcher ) } r := <- result close ( done ) return r } func RandomBetween ( min int , max int ) int { return rand . Intn ( max - min ) + min } func main () { searchers := [] searcherFunc { func ( s string ) string { sleepSeconds := time . Second * time . Duration ( RandomBetween ( 1 , 10 )) time . Sleep ( sleepSeconds ) return \"First!\" }, func ( s string ) string { sleepSeconds := time . Second * time . Duration ( RandomBetween ( 1 , 10 )) time . Sleep ( sleepSeconds ) return \"Second!\" }, func ( s string ) string { sleepSeconds := time . Second * time . Duration ( RandomBetween ( 1 , 10 )) time . Sleep ( sleepSeconds ) return \"Third!\" }, } data := searchData ( \"test\" , searchers ) fmt . Println ( data ) }","title":"The done channel pattern"},{"location":"golang/golang-fundamentals/concurrency/#waitgroups","text":"WaitGroups are handy if you have multiple goroutines and you want to wait for all to finish. The sync package provides the WaitGroup struct. It has the following functions: Add(int) Done() Wait() Let's see the WaitGroup in practice: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import ( \"fmt\" \"sync\" ) func work ( wg * sync . WaitGroup ) { defer wg . Done () fmt . Println ( \"working...\" ) } func main () { var wg sync . WaitGroup wg . Add ( 4 ) go work ( & wg ) go work ( & wg ) go work ( & wg ) go work ( & wg ) fmt . Println ( \"Now lets wait for all to finish\" ) wg . Wait () fmt . Println ( \"All finished\" ) } output: Now lets wait for all to finish working... working... working... working... All finished","title":"WaitGroups"},{"location":"golang/golang-fundamentals/concurrency/#mutexes","text":"Mutexes are also located in the sync library. Mutexes help to Lock and Unlock critical sections, to prevent race conditions. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \"fmt\" \"sync\" ) type Counter struct { value int } func ( c * Counter ) Update ( n int , wg * sync . WaitGroup ) { value := c . value defer wg . Done () fmt . Printf ( \"Adding %d to %d\\n\" , n , value ) c . value = value + n } func main () { var wg sync . WaitGroup c := Counter {} wg . Add ( 4 ) go c . Update ( 10 , & wg ) go c . Update ( - 5 , & wg ) go c . Update ( 25 , & wg ) go c . Update ( 19 , & wg ) wg . Wait () fmt . Println ( c . value ) } c.Update() works on the c.value variable and since they are all running concurrent, you never now, which value is currently in c.value . output: Adding 19 to 0 Adding -5 to 0 Adding 10 to 0 Adding 25 to 0 25 You can fix that by using Mutex : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 type Counter struct { m sync . Mutex value int } func ( c * Counter ) Update ( n int , wg * sync . WaitGroup ) { c . m . Lock () defer wg . Done () fmt . Printf ( \"Adding %d to %d\\n\" , n , c . value ) c . value += n c . m . Unlock () } func main () { var wg sync . WaitGroup c := Counter {} wg . Add ( 4 ) go c . Update ( 10 , & wg ) go c . Update ( - 5 , & wg ) go c . Update ( 25 , & wg ) go c . Update ( 19 , & wg ) wg . Wait () fmt . Println ( c . value ) } Now the output is correct, because we Lock the critical section c.value and only one goroutine is allowed to work on it until it Unlock the Mutex again. Adding 19 to 0 Adding 10 to 19 Adding -5 to 29 Adding 25 to 24 49","title":"Mutexes"},{"location":"golang/golang-fundamentals/concurrency/#concurrency-in-go","text":"Concurrency can be very frustrating, because a lot of things happen at the same time in your application and it can be very hard to predict or even debug, what is happening. For this there is a very good book by Katherine Cox-Buday it's called Concurrency in Go .","title":"Concurrency in Go"},{"location":"golang/golang-fundamentals/context/","text":"Context Context is the idea to have a request scoped value storage ( Source ). Let's start by taking a look at the context interface: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // A Context carries a deadline, cancellation signal, and request-scoped values // across API boundaries. Its methods are safe for simultaneous use by multiple // goroutines. type Context interface { // Done returns a channel that is closed when this Context is canceled // or times out. Done () <- chan struct {} // Err indicates why this context was canceled, after the Done channel // is closed. Err () error // Deadline returns the time when this Context will be canceled, if any. Deadline () ( deadline time . Time , ok bool ) // Value returns the value associated with key or nil if none. Value ( key interface {}) interface {} } Mostly Context is used to set values within a request and to cancel long running requests. Let's first take a look a simple example: main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func process ( ctx context . Context ) { fmt . Println ( \"Processing user id: \" , ctx . Value ( \"user_id\" )) select { case <- time . After ( 10 * time . Second ): fmt . Println ( \"Processing finished\" ) case <- ctx . Done (): fmt . Println ( \"Processing cancelled\" ) } } func hello ( w http . ResponseWriter , req * http . Request ) { ctx := req . Context () _ , cancelFunc := context . WithCancel ( ctx ) ctx = context . WithValue ( ctx , \"user_id\" , 123 ) go process ( ctx ) select { case <- time . After ( 3 * time . Second ): cancelFunc () fmt . Fprint ( w , \"Cancelled\" ) case <- ctx . Done (): err := ctx . Err () fmt . Println ( \"server:\" , err ) internalError := http . StatusInternalServerError http . Error ( w , err . Error (), internalError ) } } func main () { http . HandleFunc ( \"/hello\" , hello ) http . ListenAndServe ( \":8080\" , nil ) } If you are not in a request-response loop, you can use the built-in functions to create a context for other purposes: main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import ( \"context\" \"fmt\" \"time\" ) func fastRequest ( ctx context . Context , result chan <- string ) { select { case <- ctx . Done (): return case <- time . After ( 5 * time . Second ): result <- \"fast\" return } } func slowRequest ( ctx context . Context , result chan <- string ) { select { case <- ctx . Done (): return case <- time . After ( 30 * time . Second ): result <- \"slow\" return } } func main () { ctx := context . Background () ctx , _ = context . WithDeadline ( ctx , time . Now (). Add ( 7 * time . Second )) data := make ( chan string ) fmt . Println ( \"Startig fast request\" ) go fastRequest ( ctx , data ) fmt . Println ( \"Startig slow request\" ) go slowRequest ( ctx , data ) for { select { case <- ctx . Done (): fmt . Println ( \"Canceled context, quiting\" ) return case result := <- data : fmt . Println ( result ) return } } } output is: Startig fast request Startig slow request fast","title":"Context"},{"location":"golang/golang-fundamentals/context/#context","text":"Context is the idea to have a request scoped value storage ( Source ). Let's start by taking a look at the context interface: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // A Context carries a deadline, cancellation signal, and request-scoped values // across API boundaries. Its methods are safe for simultaneous use by multiple // goroutines. type Context interface { // Done returns a channel that is closed when this Context is canceled // or times out. Done () <- chan struct {} // Err indicates why this context was canceled, after the Done channel // is closed. Err () error // Deadline returns the time when this Context will be canceled, if any. Deadline () ( deadline time . Time , ok bool ) // Value returns the value associated with key or nil if none. Value ( key interface {}) interface {} } Mostly Context is used to set values within a request and to cancel long running requests. Let's first take a look a simple example: main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func process ( ctx context . Context ) { fmt . Println ( \"Processing user id: \" , ctx . Value ( \"user_id\" )) select { case <- time . After ( 10 * time . Second ): fmt . Println ( \"Processing finished\" ) case <- ctx . Done (): fmt . Println ( \"Processing cancelled\" ) } } func hello ( w http . ResponseWriter , req * http . Request ) { ctx := req . Context () _ , cancelFunc := context . WithCancel ( ctx ) ctx = context . WithValue ( ctx , \"user_id\" , 123 ) go process ( ctx ) select { case <- time . After ( 3 * time . Second ): cancelFunc () fmt . Fprint ( w , \"Cancelled\" ) case <- ctx . Done (): err := ctx . Err () fmt . Println ( \"server:\" , err ) internalError := http . StatusInternalServerError http . Error ( w , err . Error (), internalError ) } } func main () { http . HandleFunc ( \"/hello\" , hello ) http . ListenAndServe ( \":8080\" , nil ) } If you are not in a request-response loop, you can use the built-in functions to create a context for other purposes: main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import ( \"context\" \"fmt\" \"time\" ) func fastRequest ( ctx context . Context , result chan <- string ) { select { case <- ctx . Done (): return case <- time . After ( 5 * time . Second ): result <- \"fast\" return } } func slowRequest ( ctx context . Context , result chan <- string ) { select { case <- ctx . Done (): return case <- time . After ( 30 * time . Second ): result <- \"slow\" return } } func main () { ctx := context . Background () ctx , _ = context . WithDeadline ( ctx , time . Now (). Add ( 7 * time . Second )) data := make ( chan string ) fmt . Println ( \"Startig fast request\" ) go fastRequest ( ctx , data ) fmt . Println ( \"Startig slow request\" ) go slowRequest ( ctx , data ) for { select { case <- ctx . Done (): fmt . Println ( \"Canceled context, quiting\" ) return case result := <- data : fmt . Println ( result ) return } } } output is: Startig fast request Startig slow request fast","title":"Context"},{"location":"golang/golang-fundamentals/control_structures/","text":"Control Structures We studied the grammar, primitive types and composite types. Now we are able to work with variables, but they are nothing without \"algorithms\" (without control structures). Let's dive in and see how we do what in Go. Blocks Blocks define the scope of constants, variables, functions and types. Therefore there are several blocks, where one of these can exist. There is a package , file , function , and {} block. All constants, variables, functions and types declared outside of a function are in a package block . All imported constants, variables, functions and types are called file block . All constants, variables, functions and types (parameters included) declared in a function are in a function block . All constants, variables, functions and types declared in curly braces in a function are in a {} block . Shadowing variables Shadowing variables is setting the variable value shortly in a {} block inside of a function block. It only works if you use the same name of the \"shadow\" variable. Here is an example: 1 2 3 4 5 6 7 8 9 func main () { x := 20 if x > 0 { fmt . Println ( x ) x := 5 fmt . Println ( x ) } fmt . Println ( x ) } the output is: 20 5 20 That's why it is so problematic to use := , we can shadow variables in inner scopes of a function, which makes it harder to really define, which value a variable has. Danger You can shadow imported package names. This can break your scope and you should never ever do this: 1 2 3 4 5 6 7 8 9 10 11 package main import ( \"fmt\" ) func main () { x := \"Hello World\" fmt := 20 fmt . Println ( x ) } will output: ./prog.go:10:6: fmt.Println undefined (type int has no field or method Println) Universe Block Golang has only 25 keywords (var, for, switch). Types (int, string), Constants (true, false) and Functions(make, close) are not included in the keyword list. They were defined in a universe block . This is the most outside block. Because they are defined in the most outside block, they can be shadowed. Danger 1 2 3 4 5 6 7 8 9 10 11 package main import ( \"fmt\" ) func main () { fmt . Println ( true ) true := 12 fmt . Println ( true ) } true will be shadowed and can result in big misbehaviour of the code. If If is actually pretty easy and works in the same way as in other programming languages. 1 2 3 4 5 6 7 8 n := 12 if n == 0 { fmt . Println ( \"N is 0\" ) } else if n > 0 { fmt . Println ( \"N is bigger than 0\" ) } else { fmt . Println ( \"N is lower than 0\" ) } Scoping variables in if statements If you want to declare a variable while checking for it's value you can declare a variable directly in an if statement. Variables defined as a scoped variable only exist in the defined scope. 1 2 3 4 5 6 7 if n := 12 ; n == 0 { fmt . Println ( \"N is 0\" ) } else if n > 0 { fmt . Println ( \"N is bigger than 0\" ) } else { fmt . Println ( \"N is lower than 0\" ) } For There is only one looping keywod called for . With for you can define 4 different formats in Go: C-style for Condition for Infinite for for-range C-style for This is probably known to you. The only thing to mention is that you can't use var keyword to define i. 1 2 3 for i := 0 ; i < 10 ; i ++ { fmt . Println ( i ) } Condition for Go has the ability to run a go loop forever until a certain variable because false . This pattern is known as while loops in other programming languages: 1 2 3 4 5 i := 1 for i < 10 { i ++ fmt . Println ( i ) } Infinite for The infinite for works the same way as for the condition for, you just have to leave the condition. This would force the for loop to run forever. 1 2 3 for { fmt . Println ( \"Run forever\" ) } break and continue break helps you to stop a for loop. continue helps you to skip the rest of the scope and start a new loop 1 2 3 4 5 6 for { ... if ! condition { break } } 1 2 3 4 5 6 7 8 9 for { ... if ! condition { ... continue } fmt . Println ( \"This is skipped when condition is false\" ) } for-range for-range loops are designed to make a foreach loop in Go. You can use strings, arrays, slices and maps with foreach loops. Later on we will talk about Channels wher for-range loops can be handy too. 1 2 3 4 values := [] int { 1 , 3 , 5 , 7 , 9 } for i , v := range values { fmt . Println ( i , v ) } output: 0 1 1 3 2 5 3 7 4 9 In a for-range loop you always get two variables. The first one is the index (strings, arrays, slices) or key (maps). The second one is the actual value. If you don't need the key or value in a for-range loop, you can use _ to let Go know, that it should ignore this variable. 1 2 3 4 values := [] int { 1 , 3 , 5 , 7 , 9 } for _ , v := range values { fmt . Println ( v ) } output: 1 3 5 7 9 If you just want the key, you can use the first variable and leave the second not declared. 1 2 3 4 values := [] int { 1 , 3 , 5 , 7 , 9 } for i := range values { fmt . Println ( i ) } for-range variables are copies Go iterates over copies of your variable. Therefore modifying the for-range variables directly is useless. You have to overwrite outer scopes variables: 1 2 3 4 5 6 7 8 9 10 11 12 values := [] int { 1 , 3 , 5 , 7 , 9 } for _ , v := range values { v ++ fmt . Println ( v ) } fmt . Println ( values ) for i := range values { values [ i ] ++ fmt . Println ( values [ i ]) } fmt . Println ( values ) output: 2 4 6 8 10 [1 3 5 7 9] 2 4 6 8 10 [2 4 6 8 10] Labeling for statements You can break or continue in for loops by using labels . This example continues the outer for loop. You will find labeled for loops very rare in the Go ecosystem. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main () { values := [] string { \"hello\" , \"world\" } outer : for _ , value := range values { for i , r := range value { fmt . Println ( i , r , string ( r )) if r == 'l' { continue outer } } fmt . Println ( \"\\n\" ) } } output: 0 104 h 1 101 e 2 108 l 0 119 w 1 111 o 2 114 r 3 108 l switch Switch statements in Go are very useful though in other languages they are more avoided. Let's see an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 words := [] string { \"a\" , \"hello\" , \"gopher\" , \"go\" , \"github\" , \"javascript\" } for _ , word := range words { switch size := len ( word ); size { case 1 , 2 , 3 , 4 : fmt . Println ( word , \"is less than 5 characters long\" ) case 5 : fmt . Println ( word , \"is 5 characters long\" ) case 6 , 7 , 8 , 9 : default : fmt . Println ( word , \"is more than 5 characters long\" ) } } output: a is less than 5 characters long hello is 5 characters long go is less than 5 characters long javascript is more than 5 characters long Duplicate cases You cannot define multiple cases: 1 2 3 4 5 6 7 8 for _ , word := range words { switch size := len ( word ); size { case 1 , 2 , 3 , 4 : fmt . Println ( word , \"is less than 5 characters long\" ) case 1 : fmt . Println ( word , \"\" ) } } Break switch in for loop Sometimes you have to break a for loop. But break inside a switch would result in breaking the switch scope and not the for loop. In that case you can use labels to break explicitly the loop. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func main () { for i := 0 ; i < 10 ; i ++ { switch { case i % 2 == 0 : fmt . Println ( i , \"is even\" ) case i % 3 == 0 : fmt . Println ( i , \"is divisible by 3\" ) case i % 7 == 0 : fmt . Println ( \"exit\" ) break default : fmt . Println ( \"don't know what to do\" ) } } } output: 0 is even don't know what to do 2 is even 3 is divisible by 3 4 is even don't know what to do 6 is even exit 8 is even 9 is divisible by 3 We can fix that by using labeled for loops: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main () { outer : for i := 0 ; i < 10 ; i ++ { switch { case i % 2 == 0 : fmt . Println ( i , \"is even\" ) case i % 3 == 0 : fmt . Println ( i , \"is divisible by 3\" ) case i % 7 == 0 : fmt . Println ( \"exit\" ) break outer default : fmt . Println ( \"don't know what to do\" ) } } } output: 0 is even don't know what to do 2 is even 3 is divisible by 3 4 is even don't know what to do 6 is even exit Blank Switches You can use a variable to switch on the value of it or use a blank switch to switch for boolean expression: 1 2 3 4 5 6 7 8 n := 2 switch n { case 2 : fmt . Println ( \"n is two\" ) default : fmt . Println ( \"n is not two\" ) } 1 2 3 4 5 6 7 8 n := 2 switch { case n == 2 : fmt . Println ( \"n is two\" ) default : fmt . Println ( \"n is not two\" ) } Surely the first one is more explicit. goto Go has the support to use goto statements. You will probably never use goto, but I will show an example here anyway: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func main () { a := 10 goto skip b := 20 skip : c := 30 fmt . Println ( a , b , c ) if c > a { goto inner } if a < b { inner : fmt . Println ( \"a is less than b\" ) } } output: ./prog.go:9:10: goto skip jumps over declaration of b at ./prog.go:10:7 ./prog.go:18:14: goto inner jumps into block starting at ./prog.go:21:14","title":"Control Structures"},{"location":"golang/golang-fundamentals/control_structures/#control-structures","text":"We studied the grammar, primitive types and composite types. Now we are able to work with variables, but they are nothing without \"algorithms\" (without control structures). Let's dive in and see how we do what in Go.","title":"Control Structures"},{"location":"golang/golang-fundamentals/control_structures/#blocks","text":"Blocks define the scope of constants, variables, functions and types. Therefore there are several blocks, where one of these can exist. There is a package , file , function , and {} block. All constants, variables, functions and types declared outside of a function are in a package block . All imported constants, variables, functions and types are called file block . All constants, variables, functions and types (parameters included) declared in a function are in a function block . All constants, variables, functions and types declared in curly braces in a function are in a {} block .","title":"Blocks"},{"location":"golang/golang-fundamentals/control_structures/#shadowing-variables","text":"Shadowing variables is setting the variable value shortly in a {} block inside of a function block. It only works if you use the same name of the \"shadow\" variable. Here is an example: 1 2 3 4 5 6 7 8 9 func main () { x := 20 if x > 0 { fmt . Println ( x ) x := 5 fmt . Println ( x ) } fmt . Println ( x ) } the output is: 20 5 20 That's why it is so problematic to use := , we can shadow variables in inner scopes of a function, which makes it harder to really define, which value a variable has. Danger You can shadow imported package names. This can break your scope and you should never ever do this: 1 2 3 4 5 6 7 8 9 10 11 package main import ( \"fmt\" ) func main () { x := \"Hello World\" fmt := 20 fmt . Println ( x ) } will output: ./prog.go:10:6: fmt.Println undefined (type int has no field or method Println)","title":"Shadowing variables"},{"location":"golang/golang-fundamentals/control_structures/#universe-block","text":"Golang has only 25 keywords (var, for, switch). Types (int, string), Constants (true, false) and Functions(make, close) are not included in the keyword list. They were defined in a universe block . This is the most outside block. Because they are defined in the most outside block, they can be shadowed. Danger 1 2 3 4 5 6 7 8 9 10 11 package main import ( \"fmt\" ) func main () { fmt . Println ( true ) true := 12 fmt . Println ( true ) } true will be shadowed and can result in big misbehaviour of the code.","title":"Universe Block"},{"location":"golang/golang-fundamentals/control_structures/#if","text":"If is actually pretty easy and works in the same way as in other programming languages. 1 2 3 4 5 6 7 8 n := 12 if n == 0 { fmt . Println ( \"N is 0\" ) } else if n > 0 { fmt . Println ( \"N is bigger than 0\" ) } else { fmt . Println ( \"N is lower than 0\" ) }","title":"If"},{"location":"golang/golang-fundamentals/control_structures/#scoping-variables-in-if-statements","text":"If you want to declare a variable while checking for it's value you can declare a variable directly in an if statement. Variables defined as a scoped variable only exist in the defined scope. 1 2 3 4 5 6 7 if n := 12 ; n == 0 { fmt . Println ( \"N is 0\" ) } else if n > 0 { fmt . Println ( \"N is bigger than 0\" ) } else { fmt . Println ( \"N is lower than 0\" ) }","title":"Scoping variables in if statements"},{"location":"golang/golang-fundamentals/control_structures/#for","text":"There is only one looping keywod called for . With for you can define 4 different formats in Go: C-style for Condition for Infinite for for-range","title":"For"},{"location":"golang/golang-fundamentals/control_structures/#c-style-for","text":"This is probably known to you. The only thing to mention is that you can't use var keyword to define i. 1 2 3 for i := 0 ; i < 10 ; i ++ { fmt . Println ( i ) }","title":"C-style for"},{"location":"golang/golang-fundamentals/control_structures/#condition-for","text":"Go has the ability to run a go loop forever until a certain variable because false . This pattern is known as while loops in other programming languages: 1 2 3 4 5 i := 1 for i < 10 { i ++ fmt . Println ( i ) }","title":"Condition for"},{"location":"golang/golang-fundamentals/control_structures/#infinite-for","text":"The infinite for works the same way as for the condition for, you just have to leave the condition. This would force the for loop to run forever. 1 2 3 for { fmt . Println ( \"Run forever\" ) }","title":"Infinite for"},{"location":"golang/golang-fundamentals/control_structures/#break-and-continue","text":"break helps you to stop a for loop. continue helps you to skip the rest of the scope and start a new loop 1 2 3 4 5 6 for { ... if ! condition { break } } 1 2 3 4 5 6 7 8 9 for { ... if ! condition { ... continue } fmt . Println ( \"This is skipped when condition is false\" ) }","title":"break and continue"},{"location":"golang/golang-fundamentals/control_structures/#for-range","text":"for-range loops are designed to make a foreach loop in Go. You can use strings, arrays, slices and maps with foreach loops. Later on we will talk about Channels wher for-range loops can be handy too. 1 2 3 4 values := [] int { 1 , 3 , 5 , 7 , 9 } for i , v := range values { fmt . Println ( i , v ) } output: 0 1 1 3 2 5 3 7 4 9 In a for-range loop you always get two variables. The first one is the index (strings, arrays, slices) or key (maps). The second one is the actual value. If you don't need the key or value in a for-range loop, you can use _ to let Go know, that it should ignore this variable. 1 2 3 4 values := [] int { 1 , 3 , 5 , 7 , 9 } for _ , v := range values { fmt . Println ( v ) } output: 1 3 5 7 9 If you just want the key, you can use the first variable and leave the second not declared. 1 2 3 4 values := [] int { 1 , 3 , 5 , 7 , 9 } for i := range values { fmt . Println ( i ) }","title":"for-range"},{"location":"golang/golang-fundamentals/control_structures/#for-range-variables-are-copies","text":"Go iterates over copies of your variable. Therefore modifying the for-range variables directly is useless. You have to overwrite outer scopes variables: 1 2 3 4 5 6 7 8 9 10 11 12 values := [] int { 1 , 3 , 5 , 7 , 9 } for _ , v := range values { v ++ fmt . Println ( v ) } fmt . Println ( values ) for i := range values { values [ i ] ++ fmt . Println ( values [ i ]) } fmt . Println ( values ) output: 2 4 6 8 10 [1 3 5 7 9] 2 4 6 8 10 [2 4 6 8 10]","title":"for-range variables are copies"},{"location":"golang/golang-fundamentals/control_structures/#labeling-for-statements","text":"You can break or continue in for loops by using labels . This example continues the outer for loop. You will find labeled for loops very rare in the Go ecosystem. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main () { values := [] string { \"hello\" , \"world\" } outer : for _ , value := range values { for i , r := range value { fmt . Println ( i , r , string ( r )) if r == 'l' { continue outer } } fmt . Println ( \"\\n\" ) } } output: 0 104 h 1 101 e 2 108 l 0 119 w 1 111 o 2 114 r 3 108 l","title":"Labeling for statements"},{"location":"golang/golang-fundamentals/control_structures/#switch","text":"Switch statements in Go are very useful though in other languages they are more avoided. Let's see an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 words := [] string { \"a\" , \"hello\" , \"gopher\" , \"go\" , \"github\" , \"javascript\" } for _ , word := range words { switch size := len ( word ); size { case 1 , 2 , 3 , 4 : fmt . Println ( word , \"is less than 5 characters long\" ) case 5 : fmt . Println ( word , \"is 5 characters long\" ) case 6 , 7 , 8 , 9 : default : fmt . Println ( word , \"is more than 5 characters long\" ) } } output: a is less than 5 characters long hello is 5 characters long go is less than 5 characters long javascript is more than 5 characters long","title":"switch"},{"location":"golang/golang-fundamentals/control_structures/#duplicate-cases","text":"You cannot define multiple cases: 1 2 3 4 5 6 7 8 for _ , word := range words { switch size := len ( word ); size { case 1 , 2 , 3 , 4 : fmt . Println ( word , \"is less than 5 characters long\" ) case 1 : fmt . Println ( word , \"\" ) } }","title":"Duplicate cases"},{"location":"golang/golang-fundamentals/control_structures/#break-switch-in-for-loop","text":"Sometimes you have to break a for loop. But break inside a switch would result in breaking the switch scope and not the for loop. In that case you can use labels to break explicitly the loop. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func main () { for i := 0 ; i < 10 ; i ++ { switch { case i % 2 == 0 : fmt . Println ( i , \"is even\" ) case i % 3 == 0 : fmt . Println ( i , \"is divisible by 3\" ) case i % 7 == 0 : fmt . Println ( \"exit\" ) break default : fmt . Println ( \"don't know what to do\" ) } } } output: 0 is even don't know what to do 2 is even 3 is divisible by 3 4 is even don't know what to do 6 is even exit 8 is even 9 is divisible by 3 We can fix that by using labeled for loops: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main () { outer : for i := 0 ; i < 10 ; i ++ { switch { case i % 2 == 0 : fmt . Println ( i , \"is even\" ) case i % 3 == 0 : fmt . Println ( i , \"is divisible by 3\" ) case i % 7 == 0 : fmt . Println ( \"exit\" ) break outer default : fmt . Println ( \"don't know what to do\" ) } } } output: 0 is even don't know what to do 2 is even 3 is divisible by 3 4 is even don't know what to do 6 is even exit","title":"Break switch in for loop"},{"location":"golang/golang-fundamentals/control_structures/#blank-switches","text":"You can use a variable to switch on the value of it or use a blank switch to switch for boolean expression: 1 2 3 4 5 6 7 8 n := 2 switch n { case 2 : fmt . Println ( \"n is two\" ) default : fmt . Println ( \"n is not two\" ) } 1 2 3 4 5 6 7 8 n := 2 switch { case n == 2 : fmt . Println ( \"n is two\" ) default : fmt . Println ( \"n is not two\" ) } Surely the first one is more explicit.","title":"Blank Switches"},{"location":"golang/golang-fundamentals/control_structures/#goto","text":"Go has the support to use goto statements. You will probably never use goto, but I will show an example here anyway: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func main () { a := 10 goto skip b := 20 skip : c := 30 fmt . Println ( a , b , c ) if c > a { goto inner } if a < b { inner : fmt . Println ( \"a is less than b\" ) } } output: ./prog.go:9:10: goto skip jumps over declaration of b at ./prog.go:10:7 ./prog.go:18:14: goto inner jumps into block starting at ./prog.go:21:14","title":"goto"},{"location":"golang/golang-fundamentals/errors/","text":"Errors Handling errors in Go can lead to a strange feeling, the concepts in Go are pretty well-thought. A lot of programmers might Handling Errors If a programm calculates an error or comes in an error state, the specific function should return an error. It is absolute convention to return the error as last return value and let it nil, if there is no error. Use the package errors to create new errors or wrap them. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import ( \"errors\" \"fmt\" ) func divide ( dividend float64 , divisor float64 ) ( float64 , error ) { if divisor == 0 { return 0 , errors . New ( \"divisor is 0\" ) } return dividend / divisor , nil } func main () { result , err := divide ( 12 , 0 ) if err != nil { fmt . Println ( err ) return } fmt . Println ( result ) } The error interface error is a built-in interface which is quiet simple ( link ): 1 2 3 type error interface { Error () string } That's why we can return nil for an error, because it's an interface type. Simple Errors: Strings In Go you can create errors with two built-in libraries: error and fmt . Here is an example: 1 2 3 4 5 6 7 8 import \"errors\" func divide ( dividend float64 , divisor float64 ) ( float64 , error ) { if divisor == 0 { return 0 , errors . New ( \"divisor is 0\" ) } return dividend / divisor , nil } or if you need some data in the error string: 1 2 3 4 5 6 7 8 import \"fmt\" func divide ( dividend float64 , divisor float64 ) ( float64 , error ) { if divisor == 0 { return 0 , fmt . Errorf ( \"divisor is %d\" , divisor ) } return dividend / divisor , nil } Sentinel Errors Sentinel Errors are constants defined for a whole package (we will talk about packages later). It's convention to start the name with Err . Let's see an example: 1 2 3 4 5 6 7 8 9 10 type CustomError string func ( ce CustomerError ) Error () string { return string ( ce ) } const ( ErrFileNotFound CustomError ( \"File was not found\" ) ErrFileCorrupted CustomError ( \"File is corrupted\" ) ) Errors with data Since error is an interface, you can create your own struct to hold more data than just a string. Please mark, that you always return error type and do not specifiy a specific type StatusError because this would minimize abstraction. Let's look at following example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 type Status int const ( InvalidLogin Status = iota + 1 NotFound ) type StatusError struct { Status Status Message string } func ( se StatusError ) Error () string { return se . Message } func Login ( username string , password string ) User , error { loginService := LoginService {} userService := UserService {} id , err := loginService . login ( username , password ) if err != nil { return User {}, StatusError { Status : InvalidLogin , Message : err . Error (), } } user , err := userService . User ( id ) if err != nil { return User {}, StatusError { Status : NotFound , Message : err . Error (), } } return user , nil } Wrapping Errors Sometimes you want to add additional information to an error, for example the location where the error happened. There is a builtin function called fmt.Errorf with the special verb %w to add an error into an error string. With another built-in library you can 'unwrap' the error from another one. It's called errors.Unwrap . It will return an error if it unwraps an error, otherwise nil . Let's see an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \"errors\" \"fmt\" \"os\" ) func fileChecker ( name string ) error { f , err := os . Open ( name ) if err != nil { return fmt . Errorf ( \"in fileChecker: %w\" , err ) } f . Close () return nil } func main () { err := fileChecker ( \"doesNotExist.txt\" ) if err != nil { fmt . Println ( err ) if wrappedErr := errors . Unwrap ( err ); wrappedErr != nil { fmt . Println ( wrappedErr ) } } } output: in fileChecker: open doesNotExist.txt: no such file or directory open doesNotExist.txt: no such file or directory Error Is, Error As Multiple Wrapped Errors \"hide\" the errors they wrapped. There is a solution to check, if an error variable wrapped another error. Let's use our fileChecker example again: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \"errors\" \"fmt\" \"os\" ) func fileChecker ( name string ) error { f , err := os . Open ( name ) if err != nil { return fmt . Errorf ( \"in fileChecker: %w\" , err ) } f . Close () return nil } func main () { err := fileChecker ( \"doesNotExist.txt\" ) if err != nil { fmt . Println ( err ) if errors . Is ( err , os . ErrNotExist ) { fmt . Println ( \"The file does not exist\" ) } } } With errors.As you can check, if an error has a custom error type: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import ( \"errors\" \"fmt\" \"os\" ) type FileCheckerError struct { name string err error } func ( fce FileCheckerError ) Error () string { return fmt . Sprintf ( \"FileCheckerError %s: %s\" , fce . name , fce . err ) } func fileChecker ( name string ) error { f , err := os . Open ( name ) if err != nil { return FileCheckerError { name : name , err : err , } } f . Close () return nil } func main () { err := fileChecker ( \"doesNotExist.txt\" ) if err != nil { var fileCheckerError FileCheckerError if errors . As ( err , & fileCheckerError ) { fmt . Println ( fileCheckerError ) } else { fmt . Println ( err ) } } } output: FileCheckerError doesNotExist.txt: open doesNotExist.txt: no such file or directory panic and recover Go programms run into panic when there is a state, where the Go programm does not know how to handle it. For example if the programm runs out of memory or if you accessed a slice past it's index. Let's check an example: 1 2 3 4 5 6 7 func doPanic ( msg string ) { panic ( msg ) } func main () { doPanic ( \"What is happening?\" ) } output: panic: What is happening? goroutine 1 [running]: main.doPanic(...) /tmp/sandbox1809318792/prog.go:4 main.main() /tmp/sandbox1809318792/prog.go:8 +0x34 Program exited. You can recover from a panic. Call recover in a defer function, if recover returns the value of the given panic value, then you can handle the panic and the programm proceeds normaly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func div60 ( i int ) { defer func () { if v := recover (); v != nil { fmt . Println ( v ) } }() fmt . Println ( 60 / i ) } func main () { for _ , val := range [] int { 1 , 2 , 0 , 6 } { div60 ( val ) } } output is: 60 30 runtime error: integer divide by zero 10 Panic and Recover look like exception handling, but they are not. A panic indicates a really problematical state and should'nt be abused. Therefore use panic and especially recover if you really know what you are doing! Stacktrace from Errors Sometimes you want to see, where your error happened. For that you can just print out the error with the verb %+v . Here is an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 func divide ( dividend float64 , divisor float64 ) ( float64 , error ) { if divisor == 0 { return 0 , fmt . Errorf ( \"divisor is %d\" , divisor ) } return dividend / divisor , nil } func main () { err := divide ( 10 , 0 ) if err != nil { fmt . Printf ( \"%+v\" , err ) } } the output would be: ./prog.go:13:9: assignment mismatch: 1 variable but divide returns 2 values","title":"Errors"},{"location":"golang/golang-fundamentals/errors/#errors","text":"Handling errors in Go can lead to a strange feeling, the concepts in Go are pretty well-thought. A lot of programmers might","title":"Errors"},{"location":"golang/golang-fundamentals/errors/#handling-errors","text":"If a programm calculates an error or comes in an error state, the specific function should return an error. It is absolute convention to return the error as last return value and let it nil, if there is no error. Use the package errors to create new errors or wrap them. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import ( \"errors\" \"fmt\" ) func divide ( dividend float64 , divisor float64 ) ( float64 , error ) { if divisor == 0 { return 0 , errors . New ( \"divisor is 0\" ) } return dividend / divisor , nil } func main () { result , err := divide ( 12 , 0 ) if err != nil { fmt . Println ( err ) return } fmt . Println ( result ) }","title":"Handling Errors"},{"location":"golang/golang-fundamentals/errors/#the-error-interface","text":"error is a built-in interface which is quiet simple ( link ): 1 2 3 type error interface { Error () string } That's why we can return nil for an error, because it's an interface type.","title":"The error interface"},{"location":"golang/golang-fundamentals/errors/#simple-errors-strings","text":"In Go you can create errors with two built-in libraries: error and fmt . Here is an example: 1 2 3 4 5 6 7 8 import \"errors\" func divide ( dividend float64 , divisor float64 ) ( float64 , error ) { if divisor == 0 { return 0 , errors . New ( \"divisor is 0\" ) } return dividend / divisor , nil } or if you need some data in the error string: 1 2 3 4 5 6 7 8 import \"fmt\" func divide ( dividend float64 , divisor float64 ) ( float64 , error ) { if divisor == 0 { return 0 , fmt . Errorf ( \"divisor is %d\" , divisor ) } return dividend / divisor , nil }","title":"Simple Errors: Strings"},{"location":"golang/golang-fundamentals/errors/#sentinel-errors","text":"Sentinel Errors are constants defined for a whole package (we will talk about packages later). It's convention to start the name with Err . Let's see an example: 1 2 3 4 5 6 7 8 9 10 type CustomError string func ( ce CustomerError ) Error () string { return string ( ce ) } const ( ErrFileNotFound CustomError ( \"File was not found\" ) ErrFileCorrupted CustomError ( \"File is corrupted\" ) )","title":"Sentinel Errors"},{"location":"golang/golang-fundamentals/errors/#errors-with-data","text":"Since error is an interface, you can create your own struct to hold more data than just a string. Please mark, that you always return error type and do not specifiy a specific type StatusError because this would minimize abstraction. Let's look at following example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 type Status int const ( InvalidLogin Status = iota + 1 NotFound ) type StatusError struct { Status Status Message string } func ( se StatusError ) Error () string { return se . Message } func Login ( username string , password string ) User , error { loginService := LoginService {} userService := UserService {} id , err := loginService . login ( username , password ) if err != nil { return User {}, StatusError { Status : InvalidLogin , Message : err . Error (), } } user , err := userService . User ( id ) if err != nil { return User {}, StatusError { Status : NotFound , Message : err . Error (), } } return user , nil }","title":"Errors with data"},{"location":"golang/golang-fundamentals/errors/#wrapping-errors","text":"Sometimes you want to add additional information to an error, for example the location where the error happened. There is a builtin function called fmt.Errorf with the special verb %w to add an error into an error string. With another built-in library you can 'unwrap' the error from another one. It's called errors.Unwrap . It will return an error if it unwraps an error, otherwise nil . Let's see an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \"errors\" \"fmt\" \"os\" ) func fileChecker ( name string ) error { f , err := os . Open ( name ) if err != nil { return fmt . Errorf ( \"in fileChecker: %w\" , err ) } f . Close () return nil } func main () { err := fileChecker ( \"doesNotExist.txt\" ) if err != nil { fmt . Println ( err ) if wrappedErr := errors . Unwrap ( err ); wrappedErr != nil { fmt . Println ( wrappedErr ) } } } output: in fileChecker: open doesNotExist.txt: no such file or directory open doesNotExist.txt: no such file or directory","title":"Wrapping Errors"},{"location":"golang/golang-fundamentals/errors/#error-is-error-as","text":"Multiple Wrapped Errors \"hide\" the errors they wrapped. There is a solution to check, if an error variable wrapped another error. Let's use our fileChecker example again: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \"errors\" \"fmt\" \"os\" ) func fileChecker ( name string ) error { f , err := os . Open ( name ) if err != nil { return fmt . Errorf ( \"in fileChecker: %w\" , err ) } f . Close () return nil } func main () { err := fileChecker ( \"doesNotExist.txt\" ) if err != nil { fmt . Println ( err ) if errors . Is ( err , os . ErrNotExist ) { fmt . Println ( \"The file does not exist\" ) } } } With errors.As you can check, if an error has a custom error type: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import ( \"errors\" \"fmt\" \"os\" ) type FileCheckerError struct { name string err error } func ( fce FileCheckerError ) Error () string { return fmt . Sprintf ( \"FileCheckerError %s: %s\" , fce . name , fce . err ) } func fileChecker ( name string ) error { f , err := os . Open ( name ) if err != nil { return FileCheckerError { name : name , err : err , } } f . Close () return nil } func main () { err := fileChecker ( \"doesNotExist.txt\" ) if err != nil { var fileCheckerError FileCheckerError if errors . As ( err , & fileCheckerError ) { fmt . Println ( fileCheckerError ) } else { fmt . Println ( err ) } } } output: FileCheckerError doesNotExist.txt: open doesNotExist.txt: no such file or directory","title":"Error Is, Error As"},{"location":"golang/golang-fundamentals/errors/#panic-and-recover","text":"Go programms run into panic when there is a state, where the Go programm does not know how to handle it. For example if the programm runs out of memory or if you accessed a slice past it's index. Let's check an example: 1 2 3 4 5 6 7 func doPanic ( msg string ) { panic ( msg ) } func main () { doPanic ( \"What is happening?\" ) } output: panic: What is happening? goroutine 1 [running]: main.doPanic(...) /tmp/sandbox1809318792/prog.go:4 main.main() /tmp/sandbox1809318792/prog.go:8 +0x34 Program exited. You can recover from a panic. Call recover in a defer function, if recover returns the value of the given panic value, then you can handle the panic and the programm proceeds normaly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func div60 ( i int ) { defer func () { if v := recover (); v != nil { fmt . Println ( v ) } }() fmt . Println ( 60 / i ) } func main () { for _ , val := range [] int { 1 , 2 , 0 , 6 } { div60 ( val ) } } output is: 60 30 runtime error: integer divide by zero 10 Panic and Recover look like exception handling, but they are not. A panic indicates a really problematical state and should'nt be abused. Therefore use panic and especially recover if you really know what you are doing!","title":"panic and recover"},{"location":"golang/golang-fundamentals/errors/#stacktrace-from-errors","text":"Sometimes you want to see, where your error happened. For that you can just print out the error with the verb %+v . Here is an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 func divide ( dividend float64 , divisor float64 ) ( float64 , error ) { if divisor == 0 { return 0 , fmt . Errorf ( \"divisor is %d\" , divisor ) } return dividend / divisor , nil } func main () { err := divide ( 10 , 0 ) if err != nil { fmt . Printf ( \"%+v\" , err ) } } the output would be: ./prog.go:13:9: assignment mismatch: 1 variable but divide returns 2 values","title":"Stacktrace from Errors"},{"location":"golang/golang-fundamentals/functions/","text":"Functions Functions are defined with the func keyword, then the function name, input parameters and their types and the return types. 1 2 3 func sum ( a int , b int ) int { return a + b } There can be also functions without parameters and return types like the main function: 1 2 3 func main () { fmt . Println ( \"Hello World\" ) } Named and Optional Parameters Go doesn't have named and optional parameters. If you want to simulate such a feature, you have create a struct for that. When you want to explicitly set a value to nil, you should use Pointers (Zero Value vs. No Value) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type Options struct { a int b int } func sum ( options Options ) int { return options . a + options . b } func main () { fmt . Println ( sum ( Options { a : 1 })) fmt . Println ( sum ( Options { b : 2 })) fmt . Println ( sum ( Options { a : 1 , b : 2 })) } output: 1 2 3 Variadic Input Parameters and Slices Go supports variadic parametes. Which means, that you can pass an undefined number of parameters of the same type into a function and it will be stored as a slice of the specified parameter type. Let's have a look at variadic functions: 1 2 3 4 5 6 7 func sum ( values ... int ) int { var result int for _ , value := range values { result += value } return result } Multiple Return Values Go allows multiple return values. It works nearly the same way as in Python. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func divAndRemainder ( numerator int , denominator int ) ( int , int , error ) { if denominator == 0 { return 0 , 0 , errors . New ( \"cannot divide by zero\" ) } return numerator / denominator , numerator % denominator , nil } func main () { result , remainder , err := divAndRemainder ( 7 , 4 ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } fmt . Println ( result , remainder ) } Danger You cannot assign multiple return values to one variable. 1 2 3 4 5 6 7 8 9 10 11 func divAndRemainder ( numerator int , denominator int ) ( int , int , error ) { if denominator == 0 { return 0 , 0 , errors . New ( \"cannot divide by zero\" ) } return numerator / denominator , numerator % denominator , nil } func main () { results := divAndRemainder ( 7 , 4 ) } output: ./prog.go:18:13: assignment mismatch: 1 variable but divAndRemainder returns 3 values Ignoring Return Values Surely you can use _ to ignore are value as in variable declarations: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func divAndRemainder ( numerator int , denominator int ) ( int , int , error ) { if denominator == 0 { return 0 , 0 , errors . New ( \"cannot divide by zero\" ) } return numerator / denominator , numerator % denominator , nil } func main () { result , _ , err := divAndRemainder ( 7 , 4 ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } fmt . Println ( result ) } Named Return Values You can use named return values to predeclare variables, which can be used inside of the function to return them later. Those variables will be initialized with zero values, therefore you can return them directly without overwriting the value. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func divAndRemainder ( numerator int , denominator int ) ( result int , remainder int , err error ) { if denominator == 0 { err = errors . New ( \"cannot divide by zero\" ) return result , remainder , err } result = numerator / denominator remainder = numerator % denominator return result , remainder , err } func main () { result , _ , err := divAndRemainder ( 7 , 4 ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } fmt . Println ( result ) } You don't have to return the specified named return values but be careful. If you specified named return values, then you can use return , but you should never ever do this. Functions are values As in other languages functions are values. Therefore you can store functions in variables and work with them. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package main import ( \"fmt\" \"strconv\" ) func add ( i int , j int ) int { return i + j } func sub ( i int , j int ) int { return i - j } func mult ( i int , j int ) int { return i * j } func div ( i int , j int ) int { return i / j } var operatorMap = map [ string ] func ( int , int ) int { \"+\" : add , \"-\" : sub , \"*\" : mult , \"/\" : div , } func main () { operations := [][] string {{ \"2\" , \"+\" , \"4\" }, { \"43\" , \"-\" , \"17\" }} for _ , operation := range operations { n1 , err := strconv . Atoi ( operation [ 0 ]) if err != nil { fmt . Println ( err ) continue } operatorFunc , ok := operatorMap [ operation [ 1 ]] if ! ok { fmt . Println ( \"unsupported operator: \" , operation [ 1 ]) continue } n2 , err := strconv . Atoi ( operation [ 2 ]) if err != nil { fmt . Println ( err ) continue } result := operatorFunc ( n1 , n2 ) fmt . Println ( result ) } } output: 6 26 Function Type Declarations As we see in Functions are values you can use functions in variables. But to use a function as variable you have to define the type of the function. In Go you can define a function as type. Let's look at the following example: 1 2 3 4 5 6 7 8 type operatorFunction func ( int , int ) int var operatorMap = map [ string ] operatorFunction { \"+\" : add , \"-\" : sub , \"*\" : mult , \"/\" : div , } Anonymous functions Anonymous functions can be declared right in the middle of you code. You can declare and call the function directly. Let's face an example: 1 2 3 4 5 6 7 8 func main () { a := 1 b := 3 sum := func ( a int , b int ) int { return a + b }( a , b ) fmt . Println ( sum ) } Passing Functions as Parameters Anonymous functions can be passed as parameters. The interesting thing is here, that those functions inside of a function create a closure . Which means, that the inner anonymous function can access and modify variables in the outer function. Let's see an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type Cat struct { Name string Age int } cats := [] Cat { { \"Mitsu\" , 2 }, { \"Yuki\" , 1 }, { \"Fred\" , 12 }, { \"Bob\" , 8 }, } fmt . Println ( cats ) sort . Slice ( cats , func ( i int , j int ) bool { return cats [ i ]. Age < cats [ j ]. Age }) fmt . Println ( cats ) output: [{Mitsu 2} {Yuki 1} {Fred 12} {Bob 8}] [{Yuki 1} {Mitsu 2} {Bob 8} {Fred 12}] defer Since Go has no try-catch-finally keywords, we need some kind of functionality, to \"cleanup\" things or to run commands, even when everything breaks. In Go you use defer and pass a function call : 1 2 3 4 5 6 7 8 9 10 11 12 13 import ( \"fmt\" ) func main () { defer func () { fmt . Println ( \"Closing\" ) }() a := 1 b := 2 fmt . Println ( \"Sum is: \" , a + b ) } Most of the time, you will use defer cleanup open sockets, file handlers or similar. Since defer can be a anonymous function, you can use it to read or set variables after the outer function has been executed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import ( \"fmt\" ) func outer ( a int , b int ) ( result int ) { defer func () { a = 10 result = a + b fmt . Println ( \"Closing function\" ) }() return result } func main () { result := outer ( 1 , 2 ) fmt . Println ( \"Sum is: \" , result ) } output would be: Closing function Sum is: 12 There is a pattern in Go, which you will find quiet often. A function that allocates a resource and returns a \"cleanup\" function, to free the resource again: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func getFile ( name string ) ( * os . File , func (), error ) { file , err := os . Open ( name ) if err != nil { return nil , nil , err } return file , func () { file . Close () }, nil } f , closer , err := getFile ( os . Args [ 1 ]) if err != nil { log . Fatal ( err ) } defer closer () Go is Call by Value Go is call by value. If you pass a variable into a function and modify it within the function it will modify a copied value and not the passed in value itself. Let's check: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 type person struct { age int name string } func modify ( number int , value string , person person ) { number = 123 value = \"Blah\" person . name = \"Test\" } func main () { number := 321 value := \"Test\" person := person { age : 28 , name : \"Michael\" , } fmt . Println ( number , value , person ) modify ( number , value , person ) fmt . Println ( number , value , person ) }","title":"Functions"},{"location":"golang/golang-fundamentals/functions/#functions","text":"Functions are defined with the func keyword, then the function name, input parameters and their types and the return types. 1 2 3 func sum ( a int , b int ) int { return a + b } There can be also functions without parameters and return types like the main function: 1 2 3 func main () { fmt . Println ( \"Hello World\" ) }","title":"Functions"},{"location":"golang/golang-fundamentals/functions/#named-and-optional-parameters","text":"Go doesn't have named and optional parameters. If you want to simulate such a feature, you have create a struct for that. When you want to explicitly set a value to nil, you should use Pointers (Zero Value vs. No Value) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type Options struct { a int b int } func sum ( options Options ) int { return options . a + options . b } func main () { fmt . Println ( sum ( Options { a : 1 })) fmt . Println ( sum ( Options { b : 2 })) fmt . Println ( sum ( Options { a : 1 , b : 2 })) } output: 1 2 3","title":"Named and Optional Parameters"},{"location":"golang/golang-fundamentals/functions/#variadic-input-parameters-and-slices","text":"Go supports variadic parametes. Which means, that you can pass an undefined number of parameters of the same type into a function and it will be stored as a slice of the specified parameter type. Let's have a look at variadic functions: 1 2 3 4 5 6 7 func sum ( values ... int ) int { var result int for _ , value := range values { result += value } return result }","title":"Variadic Input Parameters and Slices"},{"location":"golang/golang-fundamentals/functions/#multiple-return-values","text":"Go allows multiple return values. It works nearly the same way as in Python. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func divAndRemainder ( numerator int , denominator int ) ( int , int , error ) { if denominator == 0 { return 0 , 0 , errors . New ( \"cannot divide by zero\" ) } return numerator / denominator , numerator % denominator , nil } func main () { result , remainder , err := divAndRemainder ( 7 , 4 ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } fmt . Println ( result , remainder ) } Danger You cannot assign multiple return values to one variable. 1 2 3 4 5 6 7 8 9 10 11 func divAndRemainder ( numerator int , denominator int ) ( int , int , error ) { if denominator == 0 { return 0 , 0 , errors . New ( \"cannot divide by zero\" ) } return numerator / denominator , numerator % denominator , nil } func main () { results := divAndRemainder ( 7 , 4 ) } output: ./prog.go:18:13: assignment mismatch: 1 variable but divAndRemainder returns 3 values","title":"Multiple Return Values"},{"location":"golang/golang-fundamentals/functions/#ignoring-return-values","text":"Surely you can use _ to ignore are value as in variable declarations: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func divAndRemainder ( numerator int , denominator int ) ( int , int , error ) { if denominator == 0 { return 0 , 0 , errors . New ( \"cannot divide by zero\" ) } return numerator / denominator , numerator % denominator , nil } func main () { result , _ , err := divAndRemainder ( 7 , 4 ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } fmt . Println ( result ) }","title":"Ignoring Return Values"},{"location":"golang/golang-fundamentals/functions/#named-return-values","text":"You can use named return values to predeclare variables, which can be used inside of the function to return them later. Those variables will be initialized with zero values, therefore you can return them directly without overwriting the value. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func divAndRemainder ( numerator int , denominator int ) ( result int , remainder int , err error ) { if denominator == 0 { err = errors . New ( \"cannot divide by zero\" ) return result , remainder , err } result = numerator / denominator remainder = numerator % denominator return result , remainder , err } func main () { result , _ , err := divAndRemainder ( 7 , 4 ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } fmt . Println ( result ) } You don't have to return the specified named return values but be careful. If you specified named return values, then you can use return , but you should never ever do this.","title":"Named Return Values"},{"location":"golang/golang-fundamentals/functions/#functions-are-values","text":"As in other languages functions are values. Therefore you can store functions in variables and work with them. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package main import ( \"fmt\" \"strconv\" ) func add ( i int , j int ) int { return i + j } func sub ( i int , j int ) int { return i - j } func mult ( i int , j int ) int { return i * j } func div ( i int , j int ) int { return i / j } var operatorMap = map [ string ] func ( int , int ) int { \"+\" : add , \"-\" : sub , \"*\" : mult , \"/\" : div , } func main () { operations := [][] string {{ \"2\" , \"+\" , \"4\" }, { \"43\" , \"-\" , \"17\" }} for _ , operation := range operations { n1 , err := strconv . Atoi ( operation [ 0 ]) if err != nil { fmt . Println ( err ) continue } operatorFunc , ok := operatorMap [ operation [ 1 ]] if ! ok { fmt . Println ( \"unsupported operator: \" , operation [ 1 ]) continue } n2 , err := strconv . Atoi ( operation [ 2 ]) if err != nil { fmt . Println ( err ) continue } result := operatorFunc ( n1 , n2 ) fmt . Println ( result ) } } output: 6 26","title":"Functions are values"},{"location":"golang/golang-fundamentals/functions/#function-type-declarations","text":"As we see in Functions are values you can use functions in variables. But to use a function as variable you have to define the type of the function. In Go you can define a function as type. Let's look at the following example: 1 2 3 4 5 6 7 8 type operatorFunction func ( int , int ) int var operatorMap = map [ string ] operatorFunction { \"+\" : add , \"-\" : sub , \"*\" : mult , \"/\" : div , }","title":"Function Type Declarations"},{"location":"golang/golang-fundamentals/functions/#anonymous-functions","text":"Anonymous functions can be declared right in the middle of you code. You can declare and call the function directly. Let's face an example: 1 2 3 4 5 6 7 8 func main () { a := 1 b := 3 sum := func ( a int , b int ) int { return a + b }( a , b ) fmt . Println ( sum ) }","title":"Anonymous functions"},{"location":"golang/golang-fundamentals/functions/#passing-functions-as-parameters","text":"Anonymous functions can be passed as parameters. The interesting thing is here, that those functions inside of a function create a closure . Which means, that the inner anonymous function can access and modify variables in the outer function. Let's see an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type Cat struct { Name string Age int } cats := [] Cat { { \"Mitsu\" , 2 }, { \"Yuki\" , 1 }, { \"Fred\" , 12 }, { \"Bob\" , 8 }, } fmt . Println ( cats ) sort . Slice ( cats , func ( i int , j int ) bool { return cats [ i ]. Age < cats [ j ]. Age }) fmt . Println ( cats ) output: [{Mitsu 2} {Yuki 1} {Fred 12} {Bob 8}] [{Yuki 1} {Mitsu 2} {Bob 8} {Fred 12}]","title":"Passing Functions as Parameters"},{"location":"golang/golang-fundamentals/functions/#defer","text":"Since Go has no try-catch-finally keywords, we need some kind of functionality, to \"cleanup\" things or to run commands, even when everything breaks. In Go you use defer and pass a function call : 1 2 3 4 5 6 7 8 9 10 11 12 13 import ( \"fmt\" ) func main () { defer func () { fmt . Println ( \"Closing\" ) }() a := 1 b := 2 fmt . Println ( \"Sum is: \" , a + b ) } Most of the time, you will use defer cleanup open sockets, file handlers or similar. Since defer can be a anonymous function, you can use it to read or set variables after the outer function has been executed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import ( \"fmt\" ) func outer ( a int , b int ) ( result int ) { defer func () { a = 10 result = a + b fmt . Println ( \"Closing function\" ) }() return result } func main () { result := outer ( 1 , 2 ) fmt . Println ( \"Sum is: \" , result ) } output would be: Closing function Sum is: 12 There is a pattern in Go, which you will find quiet often. A function that allocates a resource and returns a \"cleanup\" function, to free the resource again: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func getFile ( name string ) ( * os . File , func (), error ) { file , err := os . Open ( name ) if err != nil { return nil , nil , err } return file , func () { file . Close () }, nil } f , closer , err := getFile ( os . Args [ 1 ]) if err != nil { log . Fatal ( err ) } defer closer ()","title":"defer"},{"location":"golang/golang-fundamentals/functions/#go-is-call-by-value","text":"Go is call by value. If you pass a variable into a function and modify it within the function it will modify a copied value and not the passed in value itself. Let's check: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 type person struct { age int name string } func modify ( number int , value string , person person ) { number = 123 value = \"Blah\" person . name = \"Test\" } func main () { number := 321 value := \"Test\" person := person { age : 28 , name : \"Michael\" , } fmt . Println ( number , value , person ) modify ( number , value , person ) fmt . Println ( number , value , person ) }","title":"Go is Call by Value"},{"location":"golang/golang-fundamentals/generics/","text":"Generics Generics can be used, if you want to do similar operations with the same function, but you have different variable types. Let's check an example first: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // SumInts adds together the values of m. func SumInts ( m map [ string ] int64 ) int64 { var s int64 for _ , v := range m { s += v } return s } // SumFloats adds together the values of m. func SumFloats ( m map [ string ] float64 ) float64 { var s float64 for _ , v := range m { s += v } return s } func main () { // Initialize a map for the integer values ints := map [ string ] int64 { \"first\" : 34 , \"second\" : 12 , } // Initialize a map for the float values floats := map [ string ] float64 { \"first\" : 35.98 , \"second\" : 26.99 , } fmt . Printf ( \"Non-Generic Sums: %v and %v\\n\" , SumInts ( ints ), SumFloats ( floats )) } output: Non-Generic Sums: 46 and 62.97 Now let's transform the function into a generic one: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func SumIntsOrFloats [ K comparable , V int64 | float64 ]( m map [ K ] V ) V { var s V for _ , v := range m { s += v } return s } func main () { // Initialize a map for the integer values ints := map [ string ] int64 { \"first\" : 34 , \"second\" : 12 , } // Initialize a map for the float values floats := map [ string ] float64 { \"first\" : 35.98 , \"second\" : 26.99 , } fmt . Printf ( \"Generic Sums: %v and %v\\n\" , SumIntsOrFloats ( ints ), SumIntsOrFloats ( floats )) } output: Generic Sums: 46 and 62.97 Type Constraints We can define type constraints by defining new interfaces and use interface embedding . For example we define: 1 2 3 type Number interface { int64 | float64 } now we can use: 1 2 3 4 5 6 7 func SumNumbers [ K comparable , V Number ]( m map [ K ] V ) V { var s V for _ , v := range m { s += v } return s } Which Types? You can use built-in types for generics, but also interfaces: 1 2 3 4 5 6 7 8 9 10 11 type Stringer interface { String () string } func Join [ E Stringer ]( things [] E ) string { var result string for _ , value := range things { result += value . String () } return result } There are also new keywords invented for generics like: any and comparable Constraints Package The constraints package provides some useful interfaces to use for Generics. For example User defined generic types We can also define user-defined generic types. Check the example here: 1 2 3 type Bunch [ E any ] [] E var myBunch := Bunch [ int ]{ 1 , 2 , 3 } Also you can use the Bunch now as parameter type: 1 2 3 4 5 6 7 8 9 type Bunch [ E any ] [] E func PrintBunch [ E any ]( bunch Bunch [ E ]) { //... } func [ b Bunch [ E ]] Print () { // ... } or as a struct: 1 2 3 4 5 6 7 8 9 type List [ T any ] struct { next * List [ T ] value T } func main () { myList := List [ int ]{ value : 2 } fmt . Println ( myList ) }","title":"Generics"},{"location":"golang/golang-fundamentals/generics/#generics","text":"Generics can be used, if you want to do similar operations with the same function, but you have different variable types. Let's check an example first: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // SumInts adds together the values of m. func SumInts ( m map [ string ] int64 ) int64 { var s int64 for _ , v := range m { s += v } return s } // SumFloats adds together the values of m. func SumFloats ( m map [ string ] float64 ) float64 { var s float64 for _ , v := range m { s += v } return s } func main () { // Initialize a map for the integer values ints := map [ string ] int64 { \"first\" : 34 , \"second\" : 12 , } // Initialize a map for the float values floats := map [ string ] float64 { \"first\" : 35.98 , \"second\" : 26.99 , } fmt . Printf ( \"Non-Generic Sums: %v and %v\\n\" , SumInts ( ints ), SumFloats ( floats )) } output: Non-Generic Sums: 46 and 62.97 Now let's transform the function into a generic one: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func SumIntsOrFloats [ K comparable , V int64 | float64 ]( m map [ K ] V ) V { var s V for _ , v := range m { s += v } return s } func main () { // Initialize a map for the integer values ints := map [ string ] int64 { \"first\" : 34 , \"second\" : 12 , } // Initialize a map for the float values floats := map [ string ] float64 { \"first\" : 35.98 , \"second\" : 26.99 , } fmt . Printf ( \"Generic Sums: %v and %v\\n\" , SumIntsOrFloats ( ints ), SumIntsOrFloats ( floats )) } output: Generic Sums: 46 and 62.97","title":"Generics"},{"location":"golang/golang-fundamentals/generics/#type-constraints","text":"We can define type constraints by defining new interfaces and use interface embedding . For example we define: 1 2 3 type Number interface { int64 | float64 } now we can use: 1 2 3 4 5 6 7 func SumNumbers [ K comparable , V Number ]( m map [ K ] V ) V { var s V for _ , v := range m { s += v } return s }","title":"Type Constraints"},{"location":"golang/golang-fundamentals/generics/#which-types","text":"You can use built-in types for generics, but also interfaces: 1 2 3 4 5 6 7 8 9 10 11 type Stringer interface { String () string } func Join [ E Stringer ]( things [] E ) string { var result string for _ , value := range things { result += value . String () } return result } There are also new keywords invented for generics like: any and comparable","title":"Which Types?"},{"location":"golang/golang-fundamentals/generics/#constraints-package","text":"The constraints package provides some useful interfaces to use for Generics. For example","title":"Constraints Package"},{"location":"golang/golang-fundamentals/generics/#user-defined-generic-types","text":"We can also define user-defined generic types. Check the example here: 1 2 3 type Bunch [ E any ] [] E var myBunch := Bunch [ int ]{ 1 , 2 , 3 } Also you can use the Bunch now as parameter type: 1 2 3 4 5 6 7 8 9 type Bunch [ E any ] [] E func PrintBunch [ E any ]( bunch Bunch [ E ]) { //... } func [ b Bunch [ E ]] Print () { // ... } or as a struct: 1 2 3 4 5 6 7 8 9 type List [ T any ] struct { next * List [ T ] value T } func main () { myList := List [ int ]{ value : 2 } fmt . Println ( myList ) }","title":"User defined generic types"},{"location":"golang/golang-fundamentals/grammar/","text":"Grammar Introduction Comments Line comments start with the character sequence // and stop at the end of the line. General comments start with the character sequence /* and stop with the first subsequent character sequence */ . A comment cannot start inside a rune or string literal, or inside a comment. A general comment containing no newlines acts like a space. Any other comment acts like a newline. 1 2 3 4 5 6 7 8 9 10 11 12 package main import \"fmt\" func main () { /* This is a multi line comment. You can type within this section */ fmt . Println ( \"Go!\" ) // single line comment fmt . Println ( \"Lang!\" ) } Semicolons Semicolons in Go are added automatically by the compiler in Go. They are added between the following token and a newline: An identifier (includes words like int, float64) A basic literal (a number or a string constant) One of the tokens: break , continue , fallthrough , return , ++ , -- , ) or } This rule makes it easy to check if a code works imaginary. Check the following code: 1 2 3 4 func main () { fmt . Println ( \"Hello World!\" ) } With the rules from above it would prerpend a semicolon to the ) at the end of line 1. 1 2 3 4 func main (); { fmt . Println ( \"Hello World!\" ); } This is not valid Go code and would result in in a compiler error. Identifiers Identifiers name program entities such as variables and types. An identifier is a sequence of one or more letters and digits. The first character in an identifier must be a letter. identifier = letter { letter | unicode_digit } . a _x9 ThisVariableIsExported \u03b1\u03b2 Some identifiers are predeclared, you will find them in the next chapter Keywords . Keywords The following keywords are reserved and may not be used as identifiers. break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var Types any bool byte comparable complex64 complex128 error float32 float64 int int8 int16 int32 int64 rune string uint uint8 uint16 uint32 uint64 uintptr Constants true false iota Zero value: nil Functions append cap close complex copy delete imag len make new panic print println real recover Operators and punctuation Following operators, assignment operators and puctuation is defined in Go. + & += &= && == != ( ) - | -= |= || < <= [ ] * ^ *= ^= <- > >= { } / << /= <<= ++ = := , ; % >> %= >>= -- ! ... . : &^ &^= ~ Integer literals An integer literal is a sequence of digits representing an integer constant. An optional prefix sets a non-decimal base: 0b or 0B for binary, 0, 0o, or 0O for octal, and 0x or 0X for hexadecimal. A single 0 is considered a decimal zero. In hexadecimal literals, letters a through f and A through F represent values 10 through 15. For readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal's value. int_lit = decimal_lit | binary_lit | octal_lit | hex_lit . decimal_lit = \"0\" | ( \"1\" \u2026 \"9\" ) [ [ \"_\" ] decimal_digits ] . binary_lit = \"0\" ( \"b\" | \"B\" ) [ \"_\" ] binary_digits . octal_lit = \"0\" [ \"o\" | \"O\" ] [ \"_\" ] octal_digits . hex_lit = \"0\" ( \"x\" | \"X\" ) [ \"_\" ] hex_digits . decimal_digits = decimal_digit { [ \"_\" ] decimal_digit } . binary_digits = binary_digit { [ \"_\" ] binary_digit } . octal_digits = octal_digit { [ \"_\" ] octal_digit } . hex_digits = hex_digit { [ \"_\" ] hex_digit } . 42 4_2 0600 0_600 0o600 0O600 // second character is capital letter 'O' 0xBadFace 0xBad_Face 0x_67_7a_2f_cc_40_c6 170141183460469231731687303715884105727 170_141183_460469_231731_687303_715884_105727 _42 // an identifier, not an integer literal 42_ // invalid: _ must separate successive digits 4__2 // invalid: only one _ at a time 0_xBadFace // invalid: _ must separate successive digits Floating-point literals A floating-point literal is a decimal or hexadecimal representation of a floating-point constant. A decimal floating-point literal consists of an integer part (decimal digits), a decimal point, a fractional part (decimal digits), and an exponent part (e or E followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; one of the decimal point or the exponent part may be elided. An exponent value exp scales the mantissa (integer and fractional part) by 10exp. A hexadecimal floating-point literal consists of a 0x or 0X prefix, an integer part (hexadecimal digits), a radix point, a fractional part (hexadecimal digits), and an exponent part (p or P followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; the radix point may be elided as well, but the exponent part is required. (This syntax matches the one given in IEEE 754-2008 \u00a75.12.3.) An exponent value exp scales the mantissa (integer and fractional part) by 2exp. For readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal value. float_lit = decimal_float_lit | hex_float_lit . decimal_float_lit = decimal_digits \".\" [ decimal_digits ] [ decimal_exponent ] | decimal_digits decimal_exponent | \".\" decimal_digits [ decimal_exponent ] . decimal_exponent = ( \"e\" | \"E\" ) [ \"+\" | \"-\" ] decimal_digits . hex_float_lit = \"0\" ( \"x\" | \"X\" ) hex_mantissa hex_exponent . hex_mantissa = [ \"_\" ] hex_digits \".\" [ hex_digits ] | [ \"_\" ] hex_digits | \".\" hex_digits . hex_exponent = ( \"p\" | \"P\" ) [ \"+\" | \"-\" ] decimal_digits . 0. 72.40 072.40 // == 72.40 2.71828 1.e+0 6.67428e-11 1E6 .25 .12345E+5 1_5. // == 15.0 0.15e+0_2 // == 15.0 0x1p-2 // == 0.25 0x2.p10 // == 2048.0 0x1.Fp+0 // == 1.9375 0X.8p-0 // == 0.5 0X_1FFFP-16 // == 0.1249847412109375 0x15e-2 // == 0x15e - 2 (integer subtraction) 0x.p1 // invalid: mantissa has no digits 1p-2 // invalid: p exponent requires hexadecimal mantissa 0x1.5e-2 // invalid: hexadecimal mantissa requires p exponent 1_.5 // invalid: _ must separate successive digits 1._5 // invalid: _ must separate successive digits 1.5_e1 // invalid: _ must separate successive digits 1.5e_1 // invalid: _ must separate successive digits 1.5e1_ // invalid: _ must separate successive digits Imaginary literals An imaginary literal represents the imaginary part of a complex constant. It consists of an integer or floating-point literal followed by the lower-case letter i. The value of an imaginary literal is the value of the respective integer or floating-point literal multiplied by the imaginary unit i. imaginary_lit = (decimal_digits | int_lit | float_lit) \"i\" . For backward compatibility, an imaginary literal's integer part consisting entirely of decimal digits (and possibly underscores) is considered a decimal integer, even if it starts with a leading 0 . 0i 0123i // == 123i for backward-compatibility 0o123i // == 0o123 * 1i == 83i 0xabci // == 0xabc * 1i == 2748i 0.i 2.71828i 1.e+0i 6.67428e-11i 1E6i .25i .12345E+5i 0x1p-2i // == 0x1p-2 * Rune literals A rune literal represents a rune constant, an integer value identifying a Unicode code point. A rune literal is expressed as one or more characters enclosed in single quotes, as in 'x' or '\\n'. Within the quotes, any character may appear except newline and unescaped single quote. A single quoted character represents the Unicode value of the character itself, while multi-character sequences beginning with a backslash encode values in various formats. The simplest form represents the single character within the quotes; since Go source text is Unicode characters encoded in UTF-8, multiple UTF-8-encoded bytes may represent a single integer value. For instance, the literal 'a' holds a single byte representing a literal a, Unicode U+0061, value 0x61, while '\u00e4' holds two bytes (0xc3 0xa4) representing a literal a-dieresis, U+00E4, value 0xe4. Several backslash escapes allow arbitrary values to be encoded as ASCII text. There are four ways to represent the integer value as a numeric constant: \\x followed by exactly two hexadecimal digits; \\u followed by exactly four hexadecimal digits; \\U followed by exactly eight hexadecimal digits, and a plain backslash \\ followed by exactly three octal digits. In each case the value of the literal is the value represented by the digits in the corresponding base. Although these representations all result in an integer, they have different valid ranges. Octal escapes must represent a value between 0 and 255 inclusive. Hexadecimal escapes satisfy this condition by construction. The escapes \\u and \\U represent Unicode code points so within them some values are illegal, in particular those above 0x10FFFF and surrogate halves. After a backslash, certain single-character escapes represent special values: \\a U+0007 alert or bell \\b U+0008 backspace \\f U+000C form feed \\n U+000A line feed or newline \\r U+000D carriage return \\t U+0009 horizontal tab \\v U+000B vertical tab \\\\ U+005C backslash \\' U+0027 single quote (valid escape only within rune literals) \\\" U+0022 double quote (valid escape only within string literals) All other sequences starting with a backslash are illegal inside rune literals. rune_lit = \"'\" ( unicode_value | byte_value ) \"'\" . unicode_value = unicode_char | little_u_value | big_u_value | escaped_char . byte_value = octal_byte_value | hex_byte_value . octal_byte_value = `\\` octal_digit octal_digit octal_digit . hex_byte_value = `\\` \"x\" hex_digit hex_digit . little_u_value = `\\` \"u\" hex_digit hex_digit hex_digit hex_digit . big_u_value = `\\` \"U\" hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit . escaped_char = `\\` ( \"a\" | \"b\" | \"f\" | \"n\" | \"r\" | \"t\" | \"v\" | `\\` | \"'\" | `\"` ) . 'a' '\u00e4' '\u672c' '\\t' '\\000' '\\007' '\\377' '\\x07' '\\xff' '\\u12e4' '\\U00101234' '\\'' // rune literal containing single quote character 'aa' // illegal: too many characters '\\xa' // illegal: too few hexadecimal digits '\\0' // illegal: too few octal digits '\\uDFFF' // illegal: surrogate half '\\U00110000' // illegal: invalid Unicode code point String literals A string literal represents a string constant obtained from concatenating a sequence of characters. There are two forms: raw string literals and interpreted string literals. Raw string literals are character sequences between back quotes, as in foo . Within the quotes, any character may appear except back quote. The value of a raw string literal is the string composed of the uninterpreted (implicitly UTF-8-encoded) characters between the quotes; in particular, backslashes have no special meaning and the string may contain newlines. Carriage return characters ('\\r') inside raw string literals are discarded from the raw string value. Interpreted string literals are character sequences between double quotes, as in \"bar\". Within the quotes, any character may appear except newline and unescaped double quote. The text between the quotes forms the value of the literal, with backslash escapes interpreted as they are in rune literals (except that \\' is illegal and \\\" is legal), with the same restrictions. The three-digit octal (\\nnn) and two-digit hexadecimal (\\xnn) escapes represent individual bytes of the resulting string; all other escapes represent the (possibly multi-byte) UTF-8 encoding of individual characters. Thus inside a string literal \\377 and \\xFF represent a single byte of value 0xFF=255, while \u00ff, \\u00FF, \\U000000FF and \\xc3\\xbf represent the two bytes 0xc3 0xbf of the UTF-8 encoding of character U+00FF. string_lit = raw_string_lit | interpreted_string_lit . raw_string_lit = \"`\" { unicode_char | newline } \"`\" . interpreted_string_lit = `\"` { unicode_value | byte_value } `\"` . `abc` // same as \"abc\" `\\n \\n` // same as \"\\\\n\\n\\\\n\" \"\\n\" \"\\\"\" // same as `\"` \"Hello, world!\\n\" \"\u65e5\u672c\u8a9e\" \"\\u65e5\u672c\\U00008a9e\" \"\\xff\\u00FF\" \"\\uD800\" // illegal: surrogate half \"\\U00110000\" // illegal: invalid Unicode code point These examples all represent the same string: \"\u65e5\u672c\u8a9e\" // UTF-8 input text `\u65e5\u672c\u8a9e` // UTF-8 input text as a raw literal \"\\u65e5\\u672c\\u8a9e\" // the explicit Unicode code points \"\\U000065e5\\U0000672c\\U00008a9e\" // the explicit Unicode code points \"\\xe6\\x97\\xa5\\xe6\\x9c\\xac\\xe8\\xaa\\x9e\" // the explicit UTF-8 bytes If the source code represents a character as two code points, such as a combining form involving an accent and a letter, the result will be an error if placed in a rune literal (it is not a single code point), and will appear as two code points if placed in a string literal.","title":"Grammar"},{"location":"golang/golang-fundamentals/grammar/#grammar","text":"","title":"Grammar"},{"location":"golang/golang-fundamentals/grammar/#introduction","text":"","title":"Introduction"},{"location":"golang/golang-fundamentals/grammar/#comments","text":"Line comments start with the character sequence // and stop at the end of the line. General comments start with the character sequence /* and stop with the first subsequent character sequence */ . A comment cannot start inside a rune or string literal, or inside a comment. A general comment containing no newlines acts like a space. Any other comment acts like a newline. 1 2 3 4 5 6 7 8 9 10 11 12 package main import \"fmt\" func main () { /* This is a multi line comment. You can type within this section */ fmt . Println ( \"Go!\" ) // single line comment fmt . Println ( \"Lang!\" ) }","title":"Comments"},{"location":"golang/golang-fundamentals/grammar/#semicolons","text":"Semicolons in Go are added automatically by the compiler in Go. They are added between the following token and a newline: An identifier (includes words like int, float64) A basic literal (a number or a string constant) One of the tokens: break , continue , fallthrough , return , ++ , -- , ) or } This rule makes it easy to check if a code works imaginary. Check the following code: 1 2 3 4 func main () { fmt . Println ( \"Hello World!\" ) } With the rules from above it would prerpend a semicolon to the ) at the end of line 1. 1 2 3 4 func main (); { fmt . Println ( \"Hello World!\" ); } This is not valid Go code and would result in in a compiler error.","title":"Semicolons"},{"location":"golang/golang-fundamentals/grammar/#identifiers","text":"Identifiers name program entities such as variables and types. An identifier is a sequence of one or more letters and digits. The first character in an identifier must be a letter. identifier = letter { letter | unicode_digit } . a _x9 ThisVariableIsExported \u03b1\u03b2 Some identifiers are predeclared, you will find them in the next chapter Keywords .","title":"Identifiers"},{"location":"golang/golang-fundamentals/grammar/#keywords","text":"The following keywords are reserved and may not be used as identifiers. break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var","title":"Keywords"},{"location":"golang/golang-fundamentals/grammar/#types","text":"any bool byte comparable complex64 complex128 error float32 float64 int int8 int16 int32 int64 rune string uint uint8 uint16 uint32 uint64 uintptr","title":"Types"},{"location":"golang/golang-fundamentals/grammar/#constants","text":"true false iota Zero value: nil","title":"Constants"},{"location":"golang/golang-fundamentals/grammar/#functions","text":"append cap close complex copy delete imag len make new panic print println real recover","title":"Functions"},{"location":"golang/golang-fundamentals/grammar/#operators-and-punctuation","text":"Following operators, assignment operators and puctuation is defined in Go. + & += &= && == != ( ) - | -= |= || < <= [ ] * ^ *= ^= <- > >= { } / << /= <<= ++ = := , ; % >> %= >>= -- ! ... . : &^ &^= ~","title":"Operators and punctuation"},{"location":"golang/golang-fundamentals/grammar/#integer-literals","text":"An integer literal is a sequence of digits representing an integer constant. An optional prefix sets a non-decimal base: 0b or 0B for binary, 0, 0o, or 0O for octal, and 0x or 0X for hexadecimal. A single 0 is considered a decimal zero. In hexadecimal literals, letters a through f and A through F represent values 10 through 15. For readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal's value. int_lit = decimal_lit | binary_lit | octal_lit | hex_lit . decimal_lit = \"0\" | ( \"1\" \u2026 \"9\" ) [ [ \"_\" ] decimal_digits ] . binary_lit = \"0\" ( \"b\" | \"B\" ) [ \"_\" ] binary_digits . octal_lit = \"0\" [ \"o\" | \"O\" ] [ \"_\" ] octal_digits . hex_lit = \"0\" ( \"x\" | \"X\" ) [ \"_\" ] hex_digits . decimal_digits = decimal_digit { [ \"_\" ] decimal_digit } . binary_digits = binary_digit { [ \"_\" ] binary_digit } . octal_digits = octal_digit { [ \"_\" ] octal_digit } . hex_digits = hex_digit { [ \"_\" ] hex_digit } . 42 4_2 0600 0_600 0o600 0O600 // second character is capital letter 'O' 0xBadFace 0xBad_Face 0x_67_7a_2f_cc_40_c6 170141183460469231731687303715884105727 170_141183_460469_231731_687303_715884_105727 _42 // an identifier, not an integer literal 42_ // invalid: _ must separate successive digits 4__2 // invalid: only one _ at a time 0_xBadFace // invalid: _ must separate successive digits","title":"Integer literals"},{"location":"golang/golang-fundamentals/grammar/#floating-point-literals","text":"A floating-point literal is a decimal or hexadecimal representation of a floating-point constant. A decimal floating-point literal consists of an integer part (decimal digits), a decimal point, a fractional part (decimal digits), and an exponent part (e or E followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; one of the decimal point or the exponent part may be elided. An exponent value exp scales the mantissa (integer and fractional part) by 10exp. A hexadecimal floating-point literal consists of a 0x or 0X prefix, an integer part (hexadecimal digits), a radix point, a fractional part (hexadecimal digits), and an exponent part (p or P followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; the radix point may be elided as well, but the exponent part is required. (This syntax matches the one given in IEEE 754-2008 \u00a75.12.3.) An exponent value exp scales the mantissa (integer and fractional part) by 2exp. For readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal value. float_lit = decimal_float_lit | hex_float_lit . decimal_float_lit = decimal_digits \".\" [ decimal_digits ] [ decimal_exponent ] | decimal_digits decimal_exponent | \".\" decimal_digits [ decimal_exponent ] . decimal_exponent = ( \"e\" | \"E\" ) [ \"+\" | \"-\" ] decimal_digits . hex_float_lit = \"0\" ( \"x\" | \"X\" ) hex_mantissa hex_exponent . hex_mantissa = [ \"_\" ] hex_digits \".\" [ hex_digits ] | [ \"_\" ] hex_digits | \".\" hex_digits . hex_exponent = ( \"p\" | \"P\" ) [ \"+\" | \"-\" ] decimal_digits . 0. 72.40 072.40 // == 72.40 2.71828 1.e+0 6.67428e-11 1E6 .25 .12345E+5 1_5. // == 15.0 0.15e+0_2 // == 15.0 0x1p-2 // == 0.25 0x2.p10 // == 2048.0 0x1.Fp+0 // == 1.9375 0X.8p-0 // == 0.5 0X_1FFFP-16 // == 0.1249847412109375 0x15e-2 // == 0x15e - 2 (integer subtraction) 0x.p1 // invalid: mantissa has no digits 1p-2 // invalid: p exponent requires hexadecimal mantissa 0x1.5e-2 // invalid: hexadecimal mantissa requires p exponent 1_.5 // invalid: _ must separate successive digits 1._5 // invalid: _ must separate successive digits 1.5_e1 // invalid: _ must separate successive digits 1.5e_1 // invalid: _ must separate successive digits 1.5e1_ // invalid: _ must separate successive digits","title":"Floating-point literals"},{"location":"golang/golang-fundamentals/grammar/#imaginary-literals","text":"An imaginary literal represents the imaginary part of a complex constant. It consists of an integer or floating-point literal followed by the lower-case letter i. The value of an imaginary literal is the value of the respective integer or floating-point literal multiplied by the imaginary unit i. imaginary_lit = (decimal_digits | int_lit | float_lit) \"i\" . For backward compatibility, an imaginary literal's integer part consisting entirely of decimal digits (and possibly underscores) is considered a decimal integer, even if it starts with a leading 0 . 0i 0123i // == 123i for backward-compatibility 0o123i // == 0o123 * 1i == 83i 0xabci // == 0xabc * 1i == 2748i 0.i 2.71828i 1.e+0i 6.67428e-11i 1E6i .25i .12345E+5i 0x1p-2i // == 0x1p-2 *","title":"Imaginary literals"},{"location":"golang/golang-fundamentals/grammar/#rune-literals","text":"A rune literal represents a rune constant, an integer value identifying a Unicode code point. A rune literal is expressed as one or more characters enclosed in single quotes, as in 'x' or '\\n'. Within the quotes, any character may appear except newline and unescaped single quote. A single quoted character represents the Unicode value of the character itself, while multi-character sequences beginning with a backslash encode values in various formats. The simplest form represents the single character within the quotes; since Go source text is Unicode characters encoded in UTF-8, multiple UTF-8-encoded bytes may represent a single integer value. For instance, the literal 'a' holds a single byte representing a literal a, Unicode U+0061, value 0x61, while '\u00e4' holds two bytes (0xc3 0xa4) representing a literal a-dieresis, U+00E4, value 0xe4. Several backslash escapes allow arbitrary values to be encoded as ASCII text. There are four ways to represent the integer value as a numeric constant: \\x followed by exactly two hexadecimal digits; \\u followed by exactly four hexadecimal digits; \\U followed by exactly eight hexadecimal digits, and a plain backslash \\ followed by exactly three octal digits. In each case the value of the literal is the value represented by the digits in the corresponding base. Although these representations all result in an integer, they have different valid ranges. Octal escapes must represent a value between 0 and 255 inclusive. Hexadecimal escapes satisfy this condition by construction. The escapes \\u and \\U represent Unicode code points so within them some values are illegal, in particular those above 0x10FFFF and surrogate halves. After a backslash, certain single-character escapes represent special values: \\a U+0007 alert or bell \\b U+0008 backspace \\f U+000C form feed \\n U+000A line feed or newline \\r U+000D carriage return \\t U+0009 horizontal tab \\v U+000B vertical tab \\\\ U+005C backslash \\' U+0027 single quote (valid escape only within rune literals) \\\" U+0022 double quote (valid escape only within string literals) All other sequences starting with a backslash are illegal inside rune literals. rune_lit = \"'\" ( unicode_value | byte_value ) \"'\" . unicode_value = unicode_char | little_u_value | big_u_value | escaped_char . byte_value = octal_byte_value | hex_byte_value . octal_byte_value = `\\` octal_digit octal_digit octal_digit . hex_byte_value = `\\` \"x\" hex_digit hex_digit . little_u_value = `\\` \"u\" hex_digit hex_digit hex_digit hex_digit . big_u_value = `\\` \"U\" hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit . escaped_char = `\\` ( \"a\" | \"b\" | \"f\" | \"n\" | \"r\" | \"t\" | \"v\" | `\\` | \"'\" | `\"` ) . 'a' '\u00e4' '\u672c' '\\t' '\\000' '\\007' '\\377' '\\x07' '\\xff' '\\u12e4' '\\U00101234' '\\'' // rune literal containing single quote character 'aa' // illegal: too many characters '\\xa' // illegal: too few hexadecimal digits '\\0' // illegal: too few octal digits '\\uDFFF' // illegal: surrogate half '\\U00110000' // illegal: invalid Unicode code point","title":"Rune literals"},{"location":"golang/golang-fundamentals/grammar/#string-literals","text":"A string literal represents a string constant obtained from concatenating a sequence of characters. There are two forms: raw string literals and interpreted string literals. Raw string literals are character sequences between back quotes, as in foo . Within the quotes, any character may appear except back quote. The value of a raw string literal is the string composed of the uninterpreted (implicitly UTF-8-encoded) characters between the quotes; in particular, backslashes have no special meaning and the string may contain newlines. Carriage return characters ('\\r') inside raw string literals are discarded from the raw string value. Interpreted string literals are character sequences between double quotes, as in \"bar\". Within the quotes, any character may appear except newline and unescaped double quote. The text between the quotes forms the value of the literal, with backslash escapes interpreted as they are in rune literals (except that \\' is illegal and \\\" is legal), with the same restrictions. The three-digit octal (\\nnn) and two-digit hexadecimal (\\xnn) escapes represent individual bytes of the resulting string; all other escapes represent the (possibly multi-byte) UTF-8 encoding of individual characters. Thus inside a string literal \\377 and \\xFF represent a single byte of value 0xFF=255, while \u00ff, \\u00FF, \\U000000FF and \\xc3\\xbf represent the two bytes 0xc3 0xbf of the UTF-8 encoding of character U+00FF. string_lit = raw_string_lit | interpreted_string_lit . raw_string_lit = \"`\" { unicode_char | newline } \"`\" . interpreted_string_lit = `\"` { unicode_value | byte_value } `\"` . `abc` // same as \"abc\" `\\n \\n` // same as \"\\\\n\\n\\\\n\" \"\\n\" \"\\\"\" // same as `\"` \"Hello, world!\\n\" \"\u65e5\u672c\u8a9e\" \"\\u65e5\u672c\\U00008a9e\" \"\\xff\\u00FF\" \"\\uD800\" // illegal: surrogate half \"\\U00110000\" // illegal: invalid Unicode code point These examples all represent the same string: \"\u65e5\u672c\u8a9e\" // UTF-8 input text `\u65e5\u672c\u8a9e` // UTF-8 input text as a raw literal \"\\u65e5\\u672c\\u8a9e\" // the explicit Unicode code points \"\\U000065e5\\U0000672c\\U00008a9e\" // the explicit Unicode code points \"\\xe6\\x97\\xa5\\xe6\\x9c\\xac\\xe8\\xaa\\x9e\" // the explicit UTF-8 bytes If the source code represents a character as two code points, such as a combining form involving an accent and a letter, the result will be an error if placed in a rune literal (it is not a single code point), and will appear as two code points if placed in a string literal.","title":"String literals"},{"location":"golang/golang-fundamentals/introduction/","text":"Introduction History The Go programming language was conceived in late 2007 as an answer to some of the problems we were seeing developing software infrastructure at Google. The computing landscape today is almost unrelated to the environment in which the languages being used, mostly C++, Java, and Python, had been created. The problems introduced by multicore processors, networked systems, massive computation clusters, and the web programming model were being worked around rather than addressed head-on. Moreover, the scale has changed: today's server programs comprise tens of millions of lines of code, are worked on by hundreds or even thousands of programmers, and are updated literally every day. To make matters worse, build times, even on large compilation clusters, have stretched to many minutes, even hours. Go was designed and developed to make working in this environment more productive. Besides its better-known aspects such as built-in concurrency and garbage collection, Go's design considerations include rigorous dependency management, the adaptability of software architecture as systems grow, and robustness across the boundaries between components. Source Pain points at Google: slow builds uncontrolled dependencies each programmer using a different subset of the language poor program understanding (code hard to read, poorly documented, and so on) duplication of effort cost of updates version skew difficulty of writing automatic tools cross-language builds Gopher Original Gopher Funny Gophers from different projects Projects using Golang Docker Kubernetes Gogs InfluxDB Snappy Minio Mattermost OpenShift Key Benefits Deploy across platforms in record speed For enterprises, Go is preferred for providing rapid cross-platform deployment. With its goroutines, native compilation, and the URI-based package namespacing, Go code compiles to a single, small binary\u2014with zero dependencies\u2014making it very fast. Leverage Go\u2019s out-of-the-box performance to scale with ease Tigran Bayburtsyan, Co-Founder and CTO at Hexact Inc., summarizes five key reasons his company switched to Go: Compiles into a single binary \u2014 \u201cUsing static linking, Go actually combining all dependency libraries and modules into one single binary file based on OS type and architecture.\u201d Static type system \u2014 \u201cType system is really important for large scale applications.\u201d Performance \u2014 \u201cGo performed better because of its concurrency model and CPU scalability. Whenever we need to process some internal request, we are doing it with separate Goroutines which are 10x cheaper in resources than Python Threads.\u201d No need for a web framework \u2014 \u201cIn most of the cases you really don\u2019t need any third-party library.\u201d Great IDE support and debugging \u2014 \u201cAfter rewriting all projects to Go, we got 64 percent less code than we had earlier.\u201d The good Simplicity Fast Built-in Build and Package Management Type Switch Concurrency Values vs Pointers Simplicity Go aims to be a simple programming language. It has a minimal set of language constructs. It makes simple project and package module structures possible. The visibility control only relies on public or private exports. Data Structures can be easily defined by just a few possibilities: Structs, Maps, Arrays. Testing is very easy in Golang, thanks to built-in commands and libraries. Fast Go programs being compiled down to machine code, and having a static type system, makes it really fast during the execution. Also, the startup time is much less than to something like Java or any JVM language. Built-in Build and Package Management Golang has a built-in build and package management what makes it easy to maintain packages. This eliminates the requirement for a third-party package and build management systems like Gradle, Maven, make, etc., and makes life so much easier for developers. Type Switch In Golang it's possible to do easy type switches instead of doing expensive operations like instanceof (Java). Visibility Control Visibility Control can be managed by using public or private variables, constants, and methods. Concurrency Golangs concurrency model is really simple. Goroutines make it possible to start a managed concurrency model. Values vs. Pointers Go supports pass-by-value and pass-by-reference. The bad No Constructors Error Checking Confusing Design No Generics (No Inheritance) No constructors In Golang there are no constructors, you have to write constructors for structs by yourself. Error Checking Each and every error has to be checked. Confusing Design There are some patterns, like the public/private concept and error handling and many more, which can confuse the first time. No Generics This isn't true anymore :) No Inheritance There is a lot of rumor about Golang, that it does not support inheritance. This is not really correct, it actually has a concept for that, which is called embedding. But it just differs from known concepts about inheritance. Which IDE to choose? Jetbrains Goland - paid, preferred VSCode - free Go Extension - free LiteIDE - free, untested Installation To install Golang simply see: go.dev / Download and install Mac users can install golang with brew: brew install go Windows users can install golang with Chocolatey: choco install golang Hello World! main.go 1 2 3 4 5 6 7 package main import \"fmt\" func main () { fmt . Println ( \"Hello World!\" ) } To build and run it, simply run: go run main.go Playground You can always use Go Playground to play around with go or just use it as \"REPL\" editor. Is it \"Go\" or \"Golang\"? Usually you say: \"Go\". This is the official name of the programming language. The only reason why some people say \"Golang\" is, because it helps to identify the term more as programming language and to use it as google query. Also the first domain was reserved for golang.com but now it became go.dev . Books and Sources Effective Go Learning Go The Go Programming Language Go by Example Go Cookbook","title":"Introduction"},{"location":"golang/golang-fundamentals/introduction/#introduction","text":"","title":"Introduction"},{"location":"golang/golang-fundamentals/introduction/#history","text":"The Go programming language was conceived in late 2007 as an answer to some of the problems we were seeing developing software infrastructure at Google. The computing landscape today is almost unrelated to the environment in which the languages being used, mostly C++, Java, and Python, had been created. The problems introduced by multicore processors, networked systems, massive computation clusters, and the web programming model were being worked around rather than addressed head-on. Moreover, the scale has changed: today's server programs comprise tens of millions of lines of code, are worked on by hundreds or even thousands of programmers, and are updated literally every day. To make matters worse, build times, even on large compilation clusters, have stretched to many minutes, even hours. Go was designed and developed to make working in this environment more productive. Besides its better-known aspects such as built-in concurrency and garbage collection, Go's design considerations include rigorous dependency management, the adaptability of software architecture as systems grow, and robustness across the boundaries between components. Source Pain points at Google: slow builds uncontrolled dependencies each programmer using a different subset of the language poor program understanding (code hard to read, poorly documented, and so on) duplication of effort cost of updates version skew difficulty of writing automatic tools cross-language builds","title":"History"},{"location":"golang/golang-fundamentals/introduction/#gopher","text":"Original Gopher Funny Gophers from different projects","title":"Gopher"},{"location":"golang/golang-fundamentals/introduction/#projects-using-golang","text":"Docker Kubernetes Gogs InfluxDB Snappy Minio Mattermost OpenShift","title":"Projects using Golang"},{"location":"golang/golang-fundamentals/introduction/#key-benefits","text":"Deploy across platforms in record speed For enterprises, Go is preferred for providing rapid cross-platform deployment. With its goroutines, native compilation, and the URI-based package namespacing, Go code compiles to a single, small binary\u2014with zero dependencies\u2014making it very fast. Leverage Go\u2019s out-of-the-box performance to scale with ease Tigran Bayburtsyan, Co-Founder and CTO at Hexact Inc., summarizes five key reasons his company switched to Go: Compiles into a single binary \u2014 \u201cUsing static linking, Go actually combining all dependency libraries and modules into one single binary file based on OS type and architecture.\u201d Static type system \u2014 \u201cType system is really important for large scale applications.\u201d Performance \u2014 \u201cGo performed better because of its concurrency model and CPU scalability. Whenever we need to process some internal request, we are doing it with separate Goroutines which are 10x cheaper in resources than Python Threads.\u201d No need for a web framework \u2014 \u201cIn most of the cases you really don\u2019t need any third-party library.\u201d Great IDE support and debugging \u2014 \u201cAfter rewriting all projects to Go, we got 64 percent less code than we had earlier.\u201d","title":"Key Benefits"},{"location":"golang/golang-fundamentals/introduction/#the-good","text":"Simplicity Fast Built-in Build and Package Management Type Switch Concurrency Values vs Pointers","title":"The good"},{"location":"golang/golang-fundamentals/introduction/#simplicity","text":"Go aims to be a simple programming language. It has a minimal set of language constructs. It makes simple project and package module structures possible. The visibility control only relies on public or private exports. Data Structures can be easily defined by just a few possibilities: Structs, Maps, Arrays. Testing is very easy in Golang, thanks to built-in commands and libraries.","title":"Simplicity"},{"location":"golang/golang-fundamentals/introduction/#fast","text":"Go programs being compiled down to machine code, and having a static type system, makes it really fast during the execution. Also, the startup time is much less than to something like Java or any JVM language.","title":"Fast"},{"location":"golang/golang-fundamentals/introduction/#built-in-build-and-package-management","text":"Golang has a built-in build and package management what makes it easy to maintain packages. This eliminates the requirement for a third-party package and build management systems like Gradle, Maven, make, etc., and makes life so much easier for developers.","title":"Built-in Build and Package Management"},{"location":"golang/golang-fundamentals/introduction/#type-switch","text":"In Golang it's possible to do easy type switches instead of doing expensive operations like instanceof (Java).","title":"Type Switch"},{"location":"golang/golang-fundamentals/introduction/#visibility-control","text":"Visibility Control can be managed by using public or private variables, constants, and methods.","title":"Visibility Control"},{"location":"golang/golang-fundamentals/introduction/#concurrency","text":"Golangs concurrency model is really simple. Goroutines make it possible to start a managed concurrency model.","title":"Concurrency"},{"location":"golang/golang-fundamentals/introduction/#values-vs-pointers","text":"Go supports pass-by-value and pass-by-reference.","title":"Values vs. Pointers"},{"location":"golang/golang-fundamentals/introduction/#the-bad","text":"No Constructors Error Checking Confusing Design No Generics (No Inheritance)","title":"The bad"},{"location":"golang/golang-fundamentals/introduction/#no-constructors","text":"In Golang there are no constructors, you have to write constructors for structs by yourself.","title":"No constructors"},{"location":"golang/golang-fundamentals/introduction/#error-checking","text":"Each and every error has to be checked.","title":"Error Checking"},{"location":"golang/golang-fundamentals/introduction/#confusing-design","text":"There are some patterns, like the public/private concept and error handling and many more, which can confuse the first time.","title":"Confusing Design"},{"location":"golang/golang-fundamentals/introduction/#no-generics","text":"This isn't true anymore :)","title":"No Generics"},{"location":"golang/golang-fundamentals/introduction/#no-inheritance","text":"There is a lot of rumor about Golang, that it does not support inheritance. This is not really correct, it actually has a concept for that, which is called embedding. But it just differs from known concepts about inheritance.","title":"No Inheritance"},{"location":"golang/golang-fundamentals/introduction/#which-ide-to-choose","text":"Jetbrains Goland - paid, preferred VSCode - free Go Extension - free LiteIDE - free, untested","title":"Which IDE to choose?"},{"location":"golang/golang-fundamentals/introduction/#installation","text":"To install Golang simply see: go.dev / Download and install Mac users can install golang with brew: brew install go Windows users can install golang with Chocolatey: choco install golang","title":"Installation"},{"location":"golang/golang-fundamentals/introduction/#hello-world","text":"main.go 1 2 3 4 5 6 7 package main import \"fmt\" func main () { fmt . Println ( \"Hello World!\" ) } To build and run it, simply run: go run main.go","title":"Hello World!"},{"location":"golang/golang-fundamentals/introduction/#playground","text":"You can always use Go Playground to play around with go or just use it as \"REPL\" editor.","title":"Playground"},{"location":"golang/golang-fundamentals/introduction/#is-it-go-or-golang","text":"Usually you say: \"Go\". This is the official name of the programming language. The only reason why some people say \"Golang\" is, because it helps to identify the term more as programming language and to use it as google query. Also the first domain was reserved for golang.com but now it became go.dev .","title":"Is it \"Go\" or \"Golang\"?"},{"location":"golang/golang-fundamentals/introduction/#books-and-sources","text":"Effective Go Learning Go The Go Programming Language Go by Example Go Cookbook","title":"Books and Sources"},{"location":"golang/golang-fundamentals/logging/","text":"Logging","title":"Logging"},{"location":"golang/golang-fundamentals/logging/#logging","text":"","title":"Logging"},{"location":"golang/golang-fundamentals/modules_packages_imports/","text":"Modules, Packages, and Imports Repositories, Modules, and Packages There are three main concepts in Go: repositories , modules , and packages . A repository is the location, where the source code of a project is stored. A module is the root of a Go library or application, inside a repository . Modules consist of one or more packages . Before we use third-party libraries we need to declare that our project is a module . Every module has it's own global unique identifier. It's like in Java the com.example.project.library name. In Go you usually use the location of your project, for example a Github repository. It doesn't have to be the repository location, a unique name is also fine. go.mod Create a module by using: go mod init GLOBAL_UNIQUE_IDENTIFIER The GLOBAL_UNIQUE_IDENTIFIER is case-sensitive, therefore try to avoid uppercase letters. Let's take a look a the go.mod if running the go mod init command. module github.com/bykof/gostradamus go 1.17 require github.com/stretchr/testify v1.7.0 require ( github.com/davecgh/go-spew v1.1.0 // indirect github.com/pmezard/go-difflib v1.0.0 // indirect gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c // indirect ) Beside the require section, there can be custom repositories like: exclude and replace . Cross Compiling First we have to find available platforms, where we can compile to. ( Source ) To find all possible platforms use: go tool dist list output: aix/ppc64 android/386 android/amd64 android/arm android/arm64 darwin/amd64 darwin/arm64 dragonfly/amd64 freebsd/386 freebsd/amd64 freebsd/arm freebsd/arm64 illumos/amd64 ios/amd64 ios/arm64 js/wasm linux/386 linux/amd64 linux/arm linux/arm64 linux/mips linux/mips64 linux/mips64le linux/mipsle linux/ppc64 linux/ppc64le linux/riscv64 linux/s390x netbsd/386 netbsd/amd64 netbsd/arm netbsd/arm64 openbsd/386 openbsd/amd64 openbsd/arm openbsd/arm64 openbsd/mips64 plan9/386 plan9/amd64 plan9/arm solaris/amd64 windows/386 windows/amd64 windows/arm windows/arm64 This will print out all possible cross compilations, since Go 1.15 all possible platforms are built-in. The format of the output is: $GOOS/$GOARCH . Then you can use the following pattern for $GOOS and $GOARCH to cross compile your application: GOOS = windows GOARCH = amd64 go build -o main.exe main.go Go generate Go generate is a useful tool to run important project commands. You can run it with: go generate [ -run regexp ] [ -n ] [ -v ] [ -x ] [ build flags ] [ file.go... | packages ] Go generate will not run automatically with go build, go test and go run. It should be run manually and explicitly. The command should be placed a go file at the top of the file: For example we want to main.go 1 2 3 4 5 package main //go:generate echo \"Hello, Go Generate!\" func main () {} If you run this file with following commands: \u279c go run main.go \u279c go generate Hello, Go Generate! You will see later why it's an important tool and how it can be used with wire . Go format Go format is very important tool, to format your code upon Go conventions ( Source ). It make following standards possible: easier to write: never worry about minor formatting concerns while hacking away, easier to read: when all code looks the same you need not mentally convert others' formatting style into something you can understand. easier to maintain: mechanical changes to the source don\u2019t cause unrelated changes to the file\u2019s formatting; diffs show only the real changes. uncontroversial: never have a debate about spacing or brace position ever again! To use it execute: go fmt path/to/your/package This will format your code automatically. Imports and Exports In Go you can import exported: constants variables functions types and you can export: constants variables functions types methods in a struct fields in a sruct Exporting things in Go is managed by the capitalization . This means, if you start the name of a function with an uppercase letter it gets exported , otherwise it's only visible inside a package. 1 2 3 4 5 6 7 func Exported () { // this function can be accessed from other packages } func packageFunc () { // this function is only available in the package } Packages Creating and accessing packages very easy in Go. Actually you just create a folder with the package name . Then, every file inside the package should have a package clause. The package clause can use the package name or another custom package name . Let's look at an example: math/math.go 1 2 3 4 5 package math func Double ( a int ) in { return a * 2 } formatter/formatter.go 1 2 3 4 5 6 7 package print import \"fmt\" func Format ( num int ) string { return fmt . Sprintf ( \"The numer is %d\" , num ) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \"fmt\" \"example.com/formatter\" , \"example.com/math\" , ) func main () { num := math . Double ( 2 ) output := print . Format ( num ) fmt . Println ( output ) } The import path can be relative, but always use absolute paths with the repository name as root to the module name you want to import, separated by / . In the example we imported example.com/formatter but we defined the packagein formatter.go to be package print . This is because in Go the package declaration happens in the files itself not as directory name. BUT the package name should be the same across a dirctory. It won't work, if you mix package names in a directory. Overriding imports It can happen, that you have to import two packages with the same name. Therefore you can just overwrite the package name by using import alias . Let's check an example: 1 2 3 4 import ( cryptoRand \"crypto/rand\" \"math/rand\" ) Documenting with godoc With godoc you can document your repository and it's packages. There are several rules, which you have to follow: Place the comment directly before the item being documented with no blank lines between the comment and the declaration of the item Start the comment with two forward slashes // followeg by the name of the item Use a blank comment to break your comment into multiple paragraphs Insert preformatted comment by indenting the lines Comments before the package declaration create package level comments. Generate comments by using the command: go doc . internal package If you want to export constants or types between your packages in your module, but you don't want to export them outside of your repository, you can use internal packages. Create a package called internal , everyting exported in the internal package will be accessable by the outer package or sibling package. Here is an example: \u251c\u2500\u2500 bar \u2502 \u2514\u2500\u2500 bar.go \u251c\u2500\u2500 foo \u2502 \u251c\u2500\u2500 foo.go \u2502 \u251c\u2500\u2500 internal \u2502 \u2502 \u2514\u2500\u2500 internal.go \u2502 \u2514\u2500\u2500 sibling \u2502 \u2514\u2500\u2500 sibling.go \u251c\u2500\u2500 go.mod \u2514\u2500\u2500 main.go Only foo and sibling can access exported types from internal . bar cannot access internal . Circular Dependency Go doesn't allow you to have circular dependencies. Modules Let's import now third party libraries by using the library: decimal Here is an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import ( \"fmt\" \"github.com/shopspring/decimal\" ) func main () { price , err := decimal . NewFromString ( \"136.02\" ) if err != nil { panic ( err ) } quantity := decimal . NewFromInt ( 3 ) total := price . Mul ( quantity ) fmt . Println ( \"Total:\" , total ) } If we run go build or go run main.go we get: main.go:6:2: no required module provides package github.com/shopspring/decimal; to add it: go get github.com/shopspring/decimal Here just run: go get github.com/shopspring/decimal We see that Go automatically added the required module to the go.mod it created a go.sum file It took the latest version, since you did no specified one. If the repository does not specify a version, Go will create a pseudo version, with a hash of the module: go.mod module decimal_example go 1.18 require github.com/shopspring/decimal v1.3.1 // indirect go.sum github.com/shopspring/decimal v1.3.1 h1:2Usl1nmF/WZucqkFZhnfFYxxxu8LG21F6nPQBE5gKV8= github.com/shopspring/decimal v1.3.1/go.mod h1:DKyhrW/HYNuLGql+MJL6WCR6knT2jwCFRcu2hWCYk4o= Versions If you want a specific version of a module, just use go get with the @vx.x.x tag: go get github.com/shopspring/decimal@v1.1.0 This will install decimal at version v1.1.0 . Upgrade If you want to upgrade a module to the latest version use: go get -u github.com/shopspring/decimal If you just want to upgrade the patch version use -u=patch . go get -u=patch github.com/shopspring/decimal Vendoring If you want to store the module inside the project folder without depending on the internet, you can use: go mod vendor This will create a vendor folder with downloaded module inside of it. If you update the go.mod you have to rebuild the vendor folder again. Publishing If you want to publish your module to the public, you can do it by upload it to a public repository like Github oder Gitlab. Check my own repository for example: https://github.com/bykof/gostradamus . Versioning Golang uses semantic versioning to create different versions of a module. If you release a new version of your module just tag the main branch of you repository with v1.0.0 or a preferred version. Proxying If you run go get Go actually fetches the module from a Proxy Server ([https://proxy.golang.org]) where it holds copies of Go modules. If module is not available Google's Proxy Server downloads and stores the module you requested. If you do not want to use Google's Proxy Server but another one use: GOPROXY=https://gocenter.io,direct go get ... If you don't want to use Proxy Server at all and want to directly download the packages from the source use: GOPROXY=direct go get ... If you want to use your own proxy server in the company: Artifactory Sonatype Athens GOPROXY Setup surch a service and point to the URL via GOPROXY env variable. Private Repositories If you have private repositories but you are using a public proxy you can supress the call to a public proxy (by hiding the domain of your company for example): GOPRIVATE=GOPRIVATE=*.corp.example.com,rsc.io/private","title":"Modules, Packages, and Imports"},{"location":"golang/golang-fundamentals/modules_packages_imports/#modules-packages-and-imports","text":"","title":"Modules, Packages, and Imports"},{"location":"golang/golang-fundamentals/modules_packages_imports/#repositories-modules-and-packages","text":"There are three main concepts in Go: repositories , modules , and packages . A repository is the location, where the source code of a project is stored. A module is the root of a Go library or application, inside a repository . Modules consist of one or more packages . Before we use third-party libraries we need to declare that our project is a module . Every module has it's own global unique identifier. It's like in Java the com.example.project.library name. In Go you usually use the location of your project, for example a Github repository. It doesn't have to be the repository location, a unique name is also fine.","title":"Repositories, Modules, and Packages"},{"location":"golang/golang-fundamentals/modules_packages_imports/#gomod","text":"Create a module by using: go mod init GLOBAL_UNIQUE_IDENTIFIER The GLOBAL_UNIQUE_IDENTIFIER is case-sensitive, therefore try to avoid uppercase letters. Let's take a look a the go.mod if running the go mod init command. module github.com/bykof/gostradamus go 1.17 require github.com/stretchr/testify v1.7.0 require ( github.com/davecgh/go-spew v1.1.0 // indirect github.com/pmezard/go-difflib v1.0.0 // indirect gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c // indirect ) Beside the require section, there can be custom repositories like: exclude and replace .","title":"go.mod"},{"location":"golang/golang-fundamentals/modules_packages_imports/#cross-compiling","text":"First we have to find available platforms, where we can compile to. ( Source ) To find all possible platforms use: go tool dist list output: aix/ppc64 android/386 android/amd64 android/arm android/arm64 darwin/amd64 darwin/arm64 dragonfly/amd64 freebsd/386 freebsd/amd64 freebsd/arm freebsd/arm64 illumos/amd64 ios/amd64 ios/arm64 js/wasm linux/386 linux/amd64 linux/arm linux/arm64 linux/mips linux/mips64 linux/mips64le linux/mipsle linux/ppc64 linux/ppc64le linux/riscv64 linux/s390x netbsd/386 netbsd/amd64 netbsd/arm netbsd/arm64 openbsd/386 openbsd/amd64 openbsd/arm openbsd/arm64 openbsd/mips64 plan9/386 plan9/amd64 plan9/arm solaris/amd64 windows/386 windows/amd64 windows/arm windows/arm64 This will print out all possible cross compilations, since Go 1.15 all possible platforms are built-in. The format of the output is: $GOOS/$GOARCH . Then you can use the following pattern for $GOOS and $GOARCH to cross compile your application: GOOS = windows GOARCH = amd64 go build -o main.exe main.go","title":"Cross Compiling"},{"location":"golang/golang-fundamentals/modules_packages_imports/#go-generate","text":"Go generate is a useful tool to run important project commands. You can run it with: go generate [ -run regexp ] [ -n ] [ -v ] [ -x ] [ build flags ] [ file.go... | packages ] Go generate will not run automatically with go build, go test and go run. It should be run manually and explicitly. The command should be placed a go file at the top of the file: For example we want to main.go 1 2 3 4 5 package main //go:generate echo \"Hello, Go Generate!\" func main () {} If you run this file with following commands: \u279c go run main.go \u279c go generate Hello, Go Generate! You will see later why it's an important tool and how it can be used with wire .","title":"Go generate"},{"location":"golang/golang-fundamentals/modules_packages_imports/#go-format","text":"Go format is very important tool, to format your code upon Go conventions ( Source ). It make following standards possible: easier to write: never worry about minor formatting concerns while hacking away, easier to read: when all code looks the same you need not mentally convert others' formatting style into something you can understand. easier to maintain: mechanical changes to the source don\u2019t cause unrelated changes to the file\u2019s formatting; diffs show only the real changes. uncontroversial: never have a debate about spacing or brace position ever again! To use it execute: go fmt path/to/your/package This will format your code automatically.","title":"Go format"},{"location":"golang/golang-fundamentals/modules_packages_imports/#imports-and-exports","text":"In Go you can import exported: constants variables functions types and you can export: constants variables functions types methods in a struct fields in a sruct Exporting things in Go is managed by the capitalization . This means, if you start the name of a function with an uppercase letter it gets exported , otherwise it's only visible inside a package. 1 2 3 4 5 6 7 func Exported () { // this function can be accessed from other packages } func packageFunc () { // this function is only available in the package }","title":"Imports and Exports"},{"location":"golang/golang-fundamentals/modules_packages_imports/#packages","text":"Creating and accessing packages very easy in Go. Actually you just create a folder with the package name . Then, every file inside the package should have a package clause. The package clause can use the package name or another custom package name . Let's look at an example: math/math.go 1 2 3 4 5 package math func Double ( a int ) in { return a * 2 } formatter/formatter.go 1 2 3 4 5 6 7 package print import \"fmt\" func Format ( num int ) string { return fmt . Sprintf ( \"The numer is %d\" , num ) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \"fmt\" \"example.com/formatter\" , \"example.com/math\" , ) func main () { num := math . Double ( 2 ) output := print . Format ( num ) fmt . Println ( output ) } The import path can be relative, but always use absolute paths with the repository name as root to the module name you want to import, separated by / . In the example we imported example.com/formatter but we defined the packagein formatter.go to be package print . This is because in Go the package declaration happens in the files itself not as directory name. BUT the package name should be the same across a dirctory. It won't work, if you mix package names in a directory.","title":"Packages"},{"location":"golang/golang-fundamentals/modules_packages_imports/#overriding-imports","text":"It can happen, that you have to import two packages with the same name. Therefore you can just overwrite the package name by using import alias . Let's check an example: 1 2 3 4 import ( cryptoRand \"crypto/rand\" \"math/rand\" )","title":"Overriding imports"},{"location":"golang/golang-fundamentals/modules_packages_imports/#documenting-with-godoc","text":"With godoc you can document your repository and it's packages. There are several rules, which you have to follow: Place the comment directly before the item being documented with no blank lines between the comment and the declaration of the item Start the comment with two forward slashes // followeg by the name of the item Use a blank comment to break your comment into multiple paragraphs Insert preformatted comment by indenting the lines Comments before the package declaration create package level comments. Generate comments by using the command: go doc .","title":"Documenting with godoc"},{"location":"golang/golang-fundamentals/modules_packages_imports/#internal-package","text":"If you want to export constants or types between your packages in your module, but you don't want to export them outside of your repository, you can use internal packages. Create a package called internal , everyting exported in the internal package will be accessable by the outer package or sibling package. Here is an example: \u251c\u2500\u2500 bar \u2502 \u2514\u2500\u2500 bar.go \u251c\u2500\u2500 foo \u2502 \u251c\u2500\u2500 foo.go \u2502 \u251c\u2500\u2500 internal \u2502 \u2502 \u2514\u2500\u2500 internal.go \u2502 \u2514\u2500\u2500 sibling \u2502 \u2514\u2500\u2500 sibling.go \u251c\u2500\u2500 go.mod \u2514\u2500\u2500 main.go Only foo and sibling can access exported types from internal . bar cannot access internal .","title":"internal package"},{"location":"golang/golang-fundamentals/modules_packages_imports/#circular-dependency","text":"Go doesn't allow you to have circular dependencies.","title":"Circular Dependency"},{"location":"golang/golang-fundamentals/modules_packages_imports/#modules","text":"Let's import now third party libraries by using the library: decimal Here is an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import ( \"fmt\" \"github.com/shopspring/decimal\" ) func main () { price , err := decimal . NewFromString ( \"136.02\" ) if err != nil { panic ( err ) } quantity := decimal . NewFromInt ( 3 ) total := price . Mul ( quantity ) fmt . Println ( \"Total:\" , total ) } If we run go build or go run main.go we get: main.go:6:2: no required module provides package github.com/shopspring/decimal; to add it: go get github.com/shopspring/decimal Here just run: go get github.com/shopspring/decimal We see that Go automatically added the required module to the go.mod it created a go.sum file It took the latest version, since you did no specified one. If the repository does not specify a version, Go will create a pseudo version, with a hash of the module: go.mod module decimal_example go 1.18 require github.com/shopspring/decimal v1.3.1 // indirect go.sum github.com/shopspring/decimal v1.3.1 h1:2Usl1nmF/WZucqkFZhnfFYxxxu8LG21F6nPQBE5gKV8= github.com/shopspring/decimal v1.3.1/go.mod h1:DKyhrW/HYNuLGql+MJL6WCR6knT2jwCFRcu2hWCYk4o=","title":"Modules"},{"location":"golang/golang-fundamentals/modules_packages_imports/#versions","text":"If you want a specific version of a module, just use go get with the @vx.x.x tag: go get github.com/shopspring/decimal@v1.1.0 This will install decimal at version v1.1.0 .","title":"Versions"},{"location":"golang/golang-fundamentals/modules_packages_imports/#upgrade","text":"If you want to upgrade a module to the latest version use: go get -u github.com/shopspring/decimal If you just want to upgrade the patch version use -u=patch . go get -u=patch github.com/shopspring/decimal","title":"Upgrade"},{"location":"golang/golang-fundamentals/modules_packages_imports/#vendoring","text":"If you want to store the module inside the project folder without depending on the internet, you can use: go mod vendor This will create a vendor folder with downloaded module inside of it. If you update the go.mod you have to rebuild the vendor folder again.","title":"Vendoring"},{"location":"golang/golang-fundamentals/modules_packages_imports/#publishing","text":"If you want to publish your module to the public, you can do it by upload it to a public repository like Github oder Gitlab. Check my own repository for example: https://github.com/bykof/gostradamus .","title":"Publishing"},{"location":"golang/golang-fundamentals/modules_packages_imports/#versioning","text":"Golang uses semantic versioning to create different versions of a module. If you release a new version of your module just tag the main branch of you repository with v1.0.0 or a preferred version.","title":"Versioning"},{"location":"golang/golang-fundamentals/modules_packages_imports/#proxying","text":"If you run go get Go actually fetches the module from a Proxy Server ([https://proxy.golang.org]) where it holds copies of Go modules. If module is not available Google's Proxy Server downloads and stores the module you requested. If you do not want to use Google's Proxy Server but another one use: GOPROXY=https://gocenter.io,direct go get ... If you don't want to use Proxy Server at all and want to directly download the packages from the source use: GOPROXY=direct go get ... If you want to use your own proxy server in the company: Artifactory Sonatype Athens GOPROXY Setup surch a service and point to the URL via GOPROXY env variable.","title":"Proxying"},{"location":"golang/golang-fundamentals/modules_packages_imports/#private-repositories","text":"If you have private repositories but you are using a public proxy you can supress the call to a public proxy (by hiding the domain of your company for example): GOPRIVATE=GOPRIVATE=*.corp.example.com,rsc.io/private","title":"Private Repositories"},{"location":"golang/golang-fundamentals/pointers/","text":"Pointers Overview Let's first check how variable are represented in the memory: 1 2 var x int32 = 10 var y bool = true Value 0 0 0 10 1 Address 1 2 3 4 5 Variable x y x is a 32bit integer, which needs 4 bytes (4*8) to store the integer in the memory. y is a boolean and needs just 1 byte to store it in the memory. For every byte in the memory there is an address, so the programm can read or write the specific values into the memory. A pointer \"points\" to a specific address of a variable. Let's check that: 1 2 3 4 5 6 7 var x int32 = 10 var y bool = true pointerX := & x pointerY := & y var pointerZ * string Value 0 0 0 10 1 0 0 0 1 0 0 0 5 0 0 0 0 Address 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Variable x y pointer X pointerY pointerZ The & is the address operator . It returns a the address of the memory location where the value is stored. The * is the indirection operator . It returns the actual value of a pointer. This is also called dereferencing. If you dereference a pointer which is nil, you will get a panic: 1 2 3 var x * int fmt . Println ( x == nil ) fmt . Println ( * x ) outputs: true panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x47dd2d] There is a builtin function new , which creates a pointer type variable. It returns a pointer to a zero value of given type. 1 2 3 4 5 6 7 8 9 var x = new ( int ) fmt . Println ( x == nil ) fmt . Println ( * x ) // is the same as var a int var b * int b = & a fmt . Println ( * b ) For structs you can use just a & while initializing one: 1 2 3 4 5 6 7 8 9 type person struct { FirstName string LastName string } person := & person { FirstName : \"Michael\" , LastName : \"Bykovski\" , } Take care, that you cannot take the address of a constant. Check here: 1 2 3 4 5 6 7 8 9 10 11 type person struct { FirstName string MiddleName * string LastName string } p := & person { FirstName : \"Michael\" , MiddleName : & \"Michau\" , LastName : \"Bykovski\" , } output: invalid operation: cannot take address of \"Michau\" (untyped string constant) You can use two solutions here. First introduce a variable of the constant and then take the address of it. Or create a function that gets a type and returns the pointer to that type. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func stringPointer ( s string ) * string { return & s } type person struct { FirstName string MiddleName * string LastName string } func main () { type person struct { FirstName string MiddleName * string LastName string } middleName := \"Michau\" p := & person { FirstName : \"Michael\" , MiddleName : & middleName , LastName : \"Bykovski\" , } p2 := & person { FirstName : \"Michael\" , MiddleName : stringPointer ( \"Michau\" ), LastName : \"Bykovski\" , } fmt . Println ( p , p2 ) } output: &{Michael 0xc000010250 Bykovski} &{Michael 0xc000010260 Bykovski} Mutable Parameters or Call by Reference Go is a call by value language, which means that if you pass a variable into a function as parameter, it will make a copy of that variable. So if you try to manipulate the passed in variable you will only do changed on a copy of the actual passed in variable. But what if you store an address of a variable and pass in the address into a function? -> Then you will be able to manipulate the actual value of the outer variable. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 type Person struct { FirstName string LastName string Age int } func noBirthday ( p Person ) { p . Age = p . Age + 1 } func birthday ( p * Person ) { p . Age = p . Age + 1 } func main () { p := Person { FirstName : \"Michael\" , LastName : \"Bykovski\" , Age : 28 , } fmt . Println ( p ) noBirthday ( p ) fmt . Println ( p ) birthday ( & p ) fmt . Println ( p ) } output: {Michael Bykovski 28} {Michael Bykovski 28} {Michael Bykovski 29} But it has some implications, which could be not self explanatory. For example, if you have a nil pointer and you want to assign a variable to this pointer. You still work on a \"copy\" of that pointer. 1 2 3 4 5 6 7 8 9 10 func failedUpdate ( g * int ) { x := 10 g = & x // g is still a copied pointer and will be vanished after function returns } func main () { var f * int failedUpdate ( f ) fmt . Println ( f ) // f is still nil } This can be fixed by derefencing the value and setting it. By dereferencing we access the actual value in the memory and overwrite it within a function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func failedUpdate ( g * int ) { x := 10 g = & x // g is still a copied pointer and will be vanished after function returns } func update ( g * int ) { * g = 10 } func main () { f := 1 failedUpdate ( & f ) fmt . Println ( f ) // f is still 1 update ( & f ) fmt . Println ( f ) // 10 } Danger Please be carefull with dereferencing, because they can panic. Therefore always check for nil pointer! 1 2 3 4 5 6 7 8 9 10 func update ( g * int ) { * g = 10 } func main () { var f * int update ( f ) fmt . Println ( f ) // error: invalid memory address or nil pointer dereference } Fixed: 1 2 3 4 5 6 7 8 9 10 11 12 func update ( g * int ) { if g != nil { * g = 10 } } func main () { var f * int update ( f ) fmt . Println ( f ) // prints nil } Passing Pointers rather than Values Surely passing pointers and modifying their values is easy. But it's actually an \"anti-pattern\" to make functions, which receive a pointer and modifying the value of your variable. Modern Software Engineering teaches us to work with immutable values rather than mutable ones Source . Therefore it's better to make functions which receive a copy of a value, mutate it and returns the mutated value: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 type Person struct { FirstName string Age int } func badBirthday ( p * Person ) { p . Age ++ } func birthday ( p Person ) Person { p . Age ++ return p } func main () { person := Person { FirstName : \"Michael\" , Age : 28 , } fmt . Println ( person ) badBirthday ( person ) fmt . Println ( person ) person = birthday ( person ) fmt . Println ( person ) } Performance If you pass a variable into a function, the whole variable gets copied to work on it. So if you pass in a variable which is around 10megabytes big, it can take up to 1 millisecond to copy the variable. Beside that it takes only about 1 nanosecond to load a pointer into a function. But returning a pointer can take more time than returning a variable. But only in one case, if you variable is smaller than 1 megabyte. For example for a 100 byte pointer it takes 30 nanoseconds and to return a value, it takes 10 nanoseconds. Once your data is bigger than 1 megabyte, this rule inverts. So for the vast majority of cases you should use call by value, only in a few cases a pointer makes sense. Zero Value vs. No Value A common usage for pointers is to set a variable either to it's zero value or to set it to nil. If you need to explicitly say, that a variable is not set, use a nil pointer. For example if you need optional parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 type Parameters struct { a int b * int } func sum ( parameters Parameters ) int { if parameters . b != nil { return parameters . a + * parameters . b } return parameters . a } func main () { b := 2 p1 := Parameters { a : 1 , b : & b , } p2 := Parameters { a : 5 , } fmt . Println ( sum ( p1 )) fmt . Println ( sum ( p2 )) } Maps and Pointers If you pass a map into a function you can manipulate the actual value of the map. This is because Go doesn't copy the value of the map but passes a reference (a pointer to struct) into the function. Therefore you should avoid using maps, unless you are working with really dynamic JSON data for example. Especially if you design your code to work in a team, it is better to define a concrete struct for your data structure than to use a dynamic map. When to use Methods over Functions Any time your logic depends on values that are configured at startup of changed while your program is running, those values should be stored in a struct and that logic should be implemented as a method. Follow this three rules and you'll be fine: when implementing methods of an interface for your struct (we will do interfaces in the next chapter) when the function needs to use a private variable within your struct when the function is completely related to the struct","title":"Pointers"},{"location":"golang/golang-fundamentals/pointers/#pointers","text":"","title":"Pointers"},{"location":"golang/golang-fundamentals/pointers/#overview","text":"Let's first check how variable are represented in the memory: 1 2 var x int32 = 10 var y bool = true Value 0 0 0 10 1 Address 1 2 3 4 5 Variable x y x is a 32bit integer, which needs 4 bytes (4*8) to store the integer in the memory. y is a boolean and needs just 1 byte to store it in the memory. For every byte in the memory there is an address, so the programm can read or write the specific values into the memory. A pointer \"points\" to a specific address of a variable. Let's check that: 1 2 3 4 5 6 7 var x int32 = 10 var y bool = true pointerX := & x pointerY := & y var pointerZ * string Value 0 0 0 10 1 0 0 0 1 0 0 0 5 0 0 0 0 Address 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Variable x y pointer X pointerY pointerZ The & is the address operator . It returns a the address of the memory location where the value is stored. The * is the indirection operator . It returns the actual value of a pointer. This is also called dereferencing. If you dereference a pointer which is nil, you will get a panic: 1 2 3 var x * int fmt . Println ( x == nil ) fmt . Println ( * x ) outputs: true panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x47dd2d] There is a builtin function new , which creates a pointer type variable. It returns a pointer to a zero value of given type. 1 2 3 4 5 6 7 8 9 var x = new ( int ) fmt . Println ( x == nil ) fmt . Println ( * x ) // is the same as var a int var b * int b = & a fmt . Println ( * b ) For structs you can use just a & while initializing one: 1 2 3 4 5 6 7 8 9 type person struct { FirstName string LastName string } person := & person { FirstName : \"Michael\" , LastName : \"Bykovski\" , } Take care, that you cannot take the address of a constant. Check here: 1 2 3 4 5 6 7 8 9 10 11 type person struct { FirstName string MiddleName * string LastName string } p := & person { FirstName : \"Michael\" , MiddleName : & \"Michau\" , LastName : \"Bykovski\" , } output: invalid operation: cannot take address of \"Michau\" (untyped string constant) You can use two solutions here. First introduce a variable of the constant and then take the address of it. Or create a function that gets a type and returns the pointer to that type. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func stringPointer ( s string ) * string { return & s } type person struct { FirstName string MiddleName * string LastName string } func main () { type person struct { FirstName string MiddleName * string LastName string } middleName := \"Michau\" p := & person { FirstName : \"Michael\" , MiddleName : & middleName , LastName : \"Bykovski\" , } p2 := & person { FirstName : \"Michael\" , MiddleName : stringPointer ( \"Michau\" ), LastName : \"Bykovski\" , } fmt . Println ( p , p2 ) } output: &{Michael 0xc000010250 Bykovski} &{Michael 0xc000010260 Bykovski}","title":"Overview"},{"location":"golang/golang-fundamentals/pointers/#mutable-parameters-or-call-by-reference","text":"Go is a call by value language, which means that if you pass a variable into a function as parameter, it will make a copy of that variable. So if you try to manipulate the passed in variable you will only do changed on a copy of the actual passed in variable. But what if you store an address of a variable and pass in the address into a function? -> Then you will be able to manipulate the actual value of the outer variable. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 type Person struct { FirstName string LastName string Age int } func noBirthday ( p Person ) { p . Age = p . Age + 1 } func birthday ( p * Person ) { p . Age = p . Age + 1 } func main () { p := Person { FirstName : \"Michael\" , LastName : \"Bykovski\" , Age : 28 , } fmt . Println ( p ) noBirthday ( p ) fmt . Println ( p ) birthday ( & p ) fmt . Println ( p ) } output: {Michael Bykovski 28} {Michael Bykovski 28} {Michael Bykovski 29} But it has some implications, which could be not self explanatory. For example, if you have a nil pointer and you want to assign a variable to this pointer. You still work on a \"copy\" of that pointer. 1 2 3 4 5 6 7 8 9 10 func failedUpdate ( g * int ) { x := 10 g = & x // g is still a copied pointer and will be vanished after function returns } func main () { var f * int failedUpdate ( f ) fmt . Println ( f ) // f is still nil } This can be fixed by derefencing the value and setting it. By dereferencing we access the actual value in the memory and overwrite it within a function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func failedUpdate ( g * int ) { x := 10 g = & x // g is still a copied pointer and will be vanished after function returns } func update ( g * int ) { * g = 10 } func main () { f := 1 failedUpdate ( & f ) fmt . Println ( f ) // f is still 1 update ( & f ) fmt . Println ( f ) // 10 } Danger Please be carefull with dereferencing, because they can panic. Therefore always check for nil pointer! 1 2 3 4 5 6 7 8 9 10 func update ( g * int ) { * g = 10 } func main () { var f * int update ( f ) fmt . Println ( f ) // error: invalid memory address or nil pointer dereference } Fixed: 1 2 3 4 5 6 7 8 9 10 11 12 func update ( g * int ) { if g != nil { * g = 10 } } func main () { var f * int update ( f ) fmt . Println ( f ) // prints nil }","title":"Mutable Parameters or Call by Reference"},{"location":"golang/golang-fundamentals/pointers/#passing-pointers-rather-than-values","text":"Surely passing pointers and modifying their values is easy. But it's actually an \"anti-pattern\" to make functions, which receive a pointer and modifying the value of your variable. Modern Software Engineering teaches us to work with immutable values rather than mutable ones Source . Therefore it's better to make functions which receive a copy of a value, mutate it and returns the mutated value: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 type Person struct { FirstName string Age int } func badBirthday ( p * Person ) { p . Age ++ } func birthday ( p Person ) Person { p . Age ++ return p } func main () { person := Person { FirstName : \"Michael\" , Age : 28 , } fmt . Println ( person ) badBirthday ( person ) fmt . Println ( person ) person = birthday ( person ) fmt . Println ( person ) }","title":"Passing Pointers rather than Values"},{"location":"golang/golang-fundamentals/pointers/#performance","text":"If you pass a variable into a function, the whole variable gets copied to work on it. So if you pass in a variable which is around 10megabytes big, it can take up to 1 millisecond to copy the variable. Beside that it takes only about 1 nanosecond to load a pointer into a function. But returning a pointer can take more time than returning a variable. But only in one case, if you variable is smaller than 1 megabyte. For example for a 100 byte pointer it takes 30 nanoseconds and to return a value, it takes 10 nanoseconds. Once your data is bigger than 1 megabyte, this rule inverts. So for the vast majority of cases you should use call by value, only in a few cases a pointer makes sense.","title":"Performance"},{"location":"golang/golang-fundamentals/pointers/#zero-value-vs-no-value","text":"A common usage for pointers is to set a variable either to it's zero value or to set it to nil. If you need to explicitly say, that a variable is not set, use a nil pointer. For example if you need optional parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 type Parameters struct { a int b * int } func sum ( parameters Parameters ) int { if parameters . b != nil { return parameters . a + * parameters . b } return parameters . a } func main () { b := 2 p1 := Parameters { a : 1 , b : & b , } p2 := Parameters { a : 5 , } fmt . Println ( sum ( p1 )) fmt . Println ( sum ( p2 )) }","title":"Zero Value vs. No Value"},{"location":"golang/golang-fundamentals/pointers/#maps-and-pointers","text":"If you pass a map into a function you can manipulate the actual value of the map. This is because Go doesn't copy the value of the map but passes a reference (a pointer to struct) into the function. Therefore you should avoid using maps, unless you are working with really dynamic JSON data for example. Especially if you design your code to work in a team, it is better to define a concrete struct for your data structure than to use a dynamic map.","title":"Maps and Pointers"},{"location":"golang/golang-fundamentals/pointers/#when-to-use-methods-over-functions","text":"Any time your logic depends on values that are configured at startup of changed while your program is running, those values should be stored in a struct and that logic should be implemented as a method. Follow this three rules and you'll be fine: when implementing methods of an interface for your struct (we will do interfaces in the next chapter) when the function needs to use a private variable within your struct when the function is completely related to the struct","title":"When to use Methods over Functions"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/","text":"Primitive Types and Declarations Zero Value If a variable is declared but not initialized with a value it gets the 'zero value'. Following zero values will be defined: Types Zero Value int 0 float 0.0 bool false string \"\" pointer nil interface nil slice nil map nil channel nil function nil Variable Declarations There are several ways to define a variable in Go. Each definition describes the way, the declared variable will be used. The default way to declare a variable is by using: 1 var x int = 10 Using the var keyword, the variable name, the type, the assignment operator, and a value. If there is a default type for the value you propose, you can use a shorter declaration: 1 var x = 10 If you don't want to initialize the variable and just declare it, you can leave the assignment operator with the value. The variable will be then initialized with the Zero Value . 1 var x int You can declare multiple variables of the same type with: 1 var x , y int = 10 Also it's possible to just declare multiple variables of the same type without initialization: 1 var x , y int or for different types, but only in this form: 1 var x , y = 10 , \"hello\" It's also possible to wrap declarations in paranthesis: 1 2 3 4 5 6 7 var ( x int y = 20 z int = 30 d , e = 40 , \"hello\" f , g string ) Short declaration format Golang supports also a short declaration format. It can be only used within function scopes, not at the package scope. Here is an example: 1 x := 10 it's the same as: 1 var x = 10 With := you can also assign values to variables as long as there is a new variable on the left hand side of := For example: 1 2 x := 10 x , y := 20 , \"Hello World\" When to use what? When you should use var or := ? There are some rules to follow, when you decide when to use what: When you initialize a variable to its zero value, use var x int . When assigning an untyped constant or a literal to a typed variable: 1 var x byte = 20 := allows you to assign to new and existing variables. Therefore it's idiomatic to declare new variables with var and mixed (new and existing) variables with := . Package Variables Avoid defining variables in the package block , because they can be manipulated by other functions, which makes it harder to track, what values they have. Use const for this problem. Const Const allows variables to be immutable. It has the same syntax as variables. Here are some examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \"fmt\" ) const x int = 10 const ( idKey = \"id\" nameKey = \"name\" ) const z = 20 * 10 func main () { const y = \"hello\" fmt . Println ( x ) fmt . Println ( y ) x = x + 1 y = \"bye\" fmt . Println ( x ) fmt . Println ( y ) } This would result in: 1 2 . / prog . go : 22 : 5 : cannot assign to x ( constant 10 of type int ) . / prog . go : 23 : 5 : cannot assign to y ( untyped string constant \"hello\" ) Definition at compile time Go initializes constants at compile time, therefore it's only possible to assign following values to them: Numeric literals Boolean literals Strings Runes built-in function like complex, real, imag, len, cap Expressions that consists of operators and the preceeding values Unused variables Go will complain if you leave variables unread. Take a look at the following example: 1 2 3 4 5 6 7 package main var x = 10 func main () { var y = 20 } This will result in the error: ./prog.go:7:9: y declared but not used Therefore you can define as many package variables as you want. Only function scope variables should be read at least once. This is an another argument to avoid package scope variables. Unused constants You can define as much constants as you want. Because constants are calculated at the compile time, they won't have any side effects. This compiles without errors: 1 2 3 4 5 6 7 package main const x = 10 func main () { const y = 20 } Primitive Types Following primitive types in Go can be used: Boolean Integer Float Complex Byte Rune String Booleans bool types represents Boolean values. It can have true or false as value. The zero value for bool is false . Numeric Types Go has 12 different numeric types that are grouped into three categories. Integer Float Complex Integer Go has signed and unsigned integers with different byte sizes. They are defined in the following table: Type Name Value Range int8 -128 to 127 int16 -32768 to 32767 int32 -2147483648 to 2147483647 int64 -9223372036854775808 to 9223372036854775807 uint8 0 to 255 uint16 0 to 65535 uint32 0 to 4294967295 uint64 0 to 18446744073709551615 Overflows Trying to set a higher value to a numeric type with it's allowed byte size 1 2 3 4 5 6 7 8 9 10 11 package main import ( \"fmt\" ) func main () { var x uint8 fmt . Println ( \"Throws integer overflow\" ) x = 267 // range of uint8 is 0-255 } will result in following compiler error: ./prog.go:10:9: cannot use 267 (untyped int constant) as uint8 value in assignment (overflows) Special integer types There is a special name called int . It has different byte allocations depending on the CPU architecture. On a 32-bit CPU, int is a 32-bit signed integer like int32 . On most 64-bit CPUs, int is a 64-bit signed integer like int64 . Because int depends on the CPU architecture, it is not allowed to perform mathematical operations or between int and int32 or int64 . See following example for this: 1 2 3 4 5 6 7 8 9 10 11 package main import \"fmt\" func main () { var x int = 2 var y int32 = 5 var z int64 = 2 fmt . Println ( x + y ) fmt . Println ( x + z ) } would result in a compile error: ./prog.go:9:14: invalid operation: x + y (mismatched types int and int32) ./prog.go:10:14: invalid operation: x + z (mismatched types int and int64) Go build failed. Floating point types There are two floating point types, displayed in the following table: Type Name Larget absolute value Smallest (nonzero) absolute value float32 3.4028e+38 1.4012e-45 float64 1.7976e+308 4.9406e-324 In most cases you shouldn't use float, because Go just stores the nearest approximation for a value. If you want to use float, you will need float64 unless you really know what you do. Complex types Go has a built-in support for complex numbers. You're probably not going to need them. Here is an example how to use complex numbers in Go: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \"math/cmplx\" \"fmt\" ) func main () { x := complex ( 2.5 , 4.1 ) y := complex ( 10.2 , 6 ) fmt . Println ( x + y ) fmt . Println ( x - y ) fmt . Println ( x * y ) fmt . Println ( x / y ) fmt . Println ( real ( x )) fmt . Println ( imag ( y )) fmt . Println ( cmplx . Abs ( x )) } Byte A byte is an alias for uint8 . You can compare, peform mathematical operations between a byte and uint8 . For example the following code works: 1 2 3 4 5 6 7 8 9 package main import \"fmt\" func main () { var x uint8 = 2 var y byte = 65 fmt . Println ( x + y ) } this would print: 67 However if you want to work with bytes just use byte and not uint8 . Rune A rune is a an alias for int32 . You can compare, perform mathematical operations between a rune and int32 . A rune can be initialized with single quotes: 1 const symbolRune = '\u2318' This rune has the integer value: 0x2318 which is the unicode character \u2318 ( See here ). String A string is a read only slice of bytes in Go. Strings can be initialized in two ways: double quote strings Double quotes format the string with escape sequences. So if your string contains a \\n it will format it to a newline. 1 2 3 const myString = \"Hello\\n World!\" fmt . Println ( myString ) output: Hello World back quote strings Back quotes ignore escape sequences in your string. Back quote strings can be also used as multiline strings 1 2 3 4 5 6 7 const myString = `Hello\\n World!` const anotherString = `-> Hello -> World ` fmt . Println ( myString ) fmt . Println ( anotherString ) output: Hello\\n World! -> Hello -> World Each character in your string represents an utf-8 encoded string character by default. In utf-8 each character occupies between 1-4 bytes. The characters a or b are encoded using 1 byte . If you use characters like \u00a3 (2 bytes) or \u2318 (3 bytes) the byte size can vary. Therefore be cautious if you convert a string into a byte array, the byte array will contain each byte of a character: 1 2 3 4 5 6 7 8 package main import \"fmt\" func main () { myString := \"\u00a3\u2318a\" fmt . Println ([] byte ( s )) } will output: |--\u00a3---| |---\u2318-----| |a| [194 163 226 140 152 97] Explicit Type Conversion If you work with different type of integers and float you cannot just add, subtract, multiply, and divide those types independently. You have to explicitly type cast an int32 to an int64 for example to add it to another int64 . That makes it clear with what types you work and if some data was truncated 1 2 3 4 5 6 7 8 9 10 package main import \"fmt\" func main () { var x float64 = 1.2 var y int = 2 z := int ( x ) + y fmt . Println ( z ) } A type conversion to boolean is not possible. If you want to type cast a variable to a bool, you have to use the zero value of the specific type. 1 2 3 4 5 6 7 8 var x int var s string = \"Test\" var xZero bool = x == 0 var sZero bool = s == \"\" fmt . Println ( x , xZero ) fmt . Println ( s , sZero )","title":"Primitive Types and Declarations"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#primitive-types-and-declarations","text":"","title":"Primitive Types and Declarations"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#zero-value","text":"If a variable is declared but not initialized with a value it gets the 'zero value'. Following zero values will be defined: Types Zero Value int 0 float 0.0 bool false string \"\" pointer nil interface nil slice nil map nil channel nil function nil","title":"Zero Value"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#variable-declarations","text":"There are several ways to define a variable in Go. Each definition describes the way, the declared variable will be used. The default way to declare a variable is by using: 1 var x int = 10 Using the var keyword, the variable name, the type, the assignment operator, and a value. If there is a default type for the value you propose, you can use a shorter declaration: 1 var x = 10 If you don't want to initialize the variable and just declare it, you can leave the assignment operator with the value. The variable will be then initialized with the Zero Value . 1 var x int You can declare multiple variables of the same type with: 1 var x , y int = 10 Also it's possible to just declare multiple variables of the same type without initialization: 1 var x , y int or for different types, but only in this form: 1 var x , y = 10 , \"hello\" It's also possible to wrap declarations in paranthesis: 1 2 3 4 5 6 7 var ( x int y = 20 z int = 30 d , e = 40 , \"hello\" f , g string )","title":"Variable Declarations"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#short-declaration-format","text":"Golang supports also a short declaration format. It can be only used within function scopes, not at the package scope. Here is an example: 1 x := 10 it's the same as: 1 var x = 10 With := you can also assign values to variables as long as there is a new variable on the left hand side of := For example: 1 2 x := 10 x , y := 20 , \"Hello World\"","title":"Short declaration format"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#when-to-use-what","text":"When you should use var or := ? There are some rules to follow, when you decide when to use what: When you initialize a variable to its zero value, use var x int . When assigning an untyped constant or a literal to a typed variable: 1 var x byte = 20 := allows you to assign to new and existing variables. Therefore it's idiomatic to declare new variables with var and mixed (new and existing) variables with := .","title":"When to use what?"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#package-variables","text":"Avoid defining variables in the package block , because they can be manipulated by other functions, which makes it harder to track, what values they have. Use const for this problem.","title":"Package Variables"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#const","text":"Const allows variables to be immutable. It has the same syntax as variables. Here are some examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \"fmt\" ) const x int = 10 const ( idKey = \"id\" nameKey = \"name\" ) const z = 20 * 10 func main () { const y = \"hello\" fmt . Println ( x ) fmt . Println ( y ) x = x + 1 y = \"bye\" fmt . Println ( x ) fmt . Println ( y ) } This would result in: 1 2 . / prog . go : 22 : 5 : cannot assign to x ( constant 10 of type int ) . / prog . go : 23 : 5 : cannot assign to y ( untyped string constant \"hello\" )","title":"Const"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#definition-at-compile-time","text":"Go initializes constants at compile time, therefore it's only possible to assign following values to them: Numeric literals Boolean literals Strings Runes built-in function like complex, real, imag, len, cap Expressions that consists of operators and the preceeding values","title":"Definition at compile time"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#unused-variables","text":"Go will complain if you leave variables unread. Take a look at the following example: 1 2 3 4 5 6 7 package main var x = 10 func main () { var y = 20 } This will result in the error: ./prog.go:7:9: y declared but not used Therefore you can define as many package variables as you want. Only function scope variables should be read at least once. This is an another argument to avoid package scope variables.","title":"Unused variables"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#unused-constants","text":"You can define as much constants as you want. Because constants are calculated at the compile time, they won't have any side effects. This compiles without errors: 1 2 3 4 5 6 7 package main const x = 10 func main () { const y = 20 }","title":"Unused constants"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#primitive-types","text":"Following primitive types in Go can be used: Boolean Integer Float Complex Byte Rune String","title":"Primitive Types"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#booleans","text":"bool types represents Boolean values. It can have true or false as value. The zero value for bool is false .","title":"Booleans"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#numeric-types","text":"Go has 12 different numeric types that are grouped into three categories. Integer Float Complex","title":"Numeric Types"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#integer","text":"Go has signed and unsigned integers with different byte sizes. They are defined in the following table: Type Name Value Range int8 -128 to 127 int16 -32768 to 32767 int32 -2147483648 to 2147483647 int64 -9223372036854775808 to 9223372036854775807 uint8 0 to 255 uint16 0 to 65535 uint32 0 to 4294967295 uint64 0 to 18446744073709551615","title":"Integer"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#overflows","text":"Trying to set a higher value to a numeric type with it's allowed byte size 1 2 3 4 5 6 7 8 9 10 11 package main import ( \"fmt\" ) func main () { var x uint8 fmt . Println ( \"Throws integer overflow\" ) x = 267 // range of uint8 is 0-255 } will result in following compiler error: ./prog.go:10:9: cannot use 267 (untyped int constant) as uint8 value in assignment (overflows)","title":"Overflows"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#special-integer-types","text":"There is a special name called int . It has different byte allocations depending on the CPU architecture. On a 32-bit CPU, int is a 32-bit signed integer like int32 . On most 64-bit CPUs, int is a 64-bit signed integer like int64 . Because int depends on the CPU architecture, it is not allowed to perform mathematical operations or between int and int32 or int64 . See following example for this: 1 2 3 4 5 6 7 8 9 10 11 package main import \"fmt\" func main () { var x int = 2 var y int32 = 5 var z int64 = 2 fmt . Println ( x + y ) fmt . Println ( x + z ) } would result in a compile error: ./prog.go:9:14: invalid operation: x + y (mismatched types int and int32) ./prog.go:10:14: invalid operation: x + z (mismatched types int and int64) Go build failed.","title":"Special integer types"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#floating-point-types","text":"There are two floating point types, displayed in the following table: Type Name Larget absolute value Smallest (nonzero) absolute value float32 3.4028e+38 1.4012e-45 float64 1.7976e+308 4.9406e-324 In most cases you shouldn't use float, because Go just stores the nearest approximation for a value. If you want to use float, you will need float64 unless you really know what you do.","title":"Floating point types"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#complex-types","text":"Go has a built-in support for complex numbers. You're probably not going to need them. Here is an example how to use complex numbers in Go: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \"math/cmplx\" \"fmt\" ) func main () { x := complex ( 2.5 , 4.1 ) y := complex ( 10.2 , 6 ) fmt . Println ( x + y ) fmt . Println ( x - y ) fmt . Println ( x * y ) fmt . Println ( x / y ) fmt . Println ( real ( x )) fmt . Println ( imag ( y )) fmt . Println ( cmplx . Abs ( x )) }","title":"Complex types"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#byte","text":"A byte is an alias for uint8 . You can compare, peform mathematical operations between a byte and uint8 . For example the following code works: 1 2 3 4 5 6 7 8 9 package main import \"fmt\" func main () { var x uint8 = 2 var y byte = 65 fmt . Println ( x + y ) } this would print: 67 However if you want to work with bytes just use byte and not uint8 .","title":"Byte"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#rune","text":"A rune is a an alias for int32 . You can compare, perform mathematical operations between a rune and int32 . A rune can be initialized with single quotes: 1 const symbolRune = '\u2318' This rune has the integer value: 0x2318 which is the unicode character \u2318 ( See here ).","title":"Rune"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#string","text":"A string is a read only slice of bytes in Go. Strings can be initialized in two ways:","title":"String"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#double-quote-strings","text":"Double quotes format the string with escape sequences. So if your string contains a \\n it will format it to a newline. 1 2 3 const myString = \"Hello\\n World!\" fmt . Println ( myString ) output: Hello World","title":"double quote strings"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#back-quote-strings","text":"Back quotes ignore escape sequences in your string. Back quote strings can be also used as multiline strings 1 2 3 4 5 6 7 const myString = `Hello\\n World!` const anotherString = `-> Hello -> World ` fmt . Println ( myString ) fmt . Println ( anotherString ) output: Hello\\n World! -> Hello -> World Each character in your string represents an utf-8 encoded string character by default. In utf-8 each character occupies between 1-4 bytes. The characters a or b are encoded using 1 byte . If you use characters like \u00a3 (2 bytes) or \u2318 (3 bytes) the byte size can vary. Therefore be cautious if you convert a string into a byte array, the byte array will contain each byte of a character: 1 2 3 4 5 6 7 8 package main import \"fmt\" func main () { myString := \"\u00a3\u2318a\" fmt . Println ([] byte ( s )) } will output: |--\u00a3---| |---\u2318-----| |a| [194 163 226 140 152 97]","title":"back quote strings"},{"location":"golang/golang-fundamentals/primitive_types_and_declarations/#explicit-type-conversion","text":"If you work with different type of integers and float you cannot just add, subtract, multiply, and divide those types independently. You have to explicitly type cast an int32 to an int64 for example to add it to another int64 . That makes it clear with what types you work and if some data was truncated 1 2 3 4 5 6 7 8 9 10 package main import \"fmt\" func main () { var x float64 = 1.2 var y int = 2 z := int ( x ) + y fmt . Println ( z ) } A type conversion to boolean is not possible. If you want to type cast a variable to a bool, you have to use the zero value of the specific type. 1 2 3 4 5 6 7 8 var x int var s string = \"Test\" var xZero bool = x == 0 var sZero bool = s == \"\" fmt . Println ( x , xZero ) fmt . Println ( s , sZero )","title":"Explicit Type Conversion"},{"location":"golang/golang-fundamentals/reflect/","text":"Reflect Informative Source With reflect we get information about our variables at runtime. It's highly recommended not to use reflection, because every wrong usage can panic . Reflect should be the last possible way to do \"meta-programming\" in Go. But let's check an example anyway: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \"fmt\" \"reflect\" ) type Foo struct { A int `tag1:\"First Tag\" tag2:\"Second Tag\"` B string } func main () { sl := [] int { 1 , 2 , 3 } greeting := \"hello\" greetingPtr := & greeting f := Foo { A : 10 , B : \"Salutations\" } fp := & f fmt . Println ( reflect . TypeOf ( sl )) fmt . Println ( reflect . TypeOf ( greeting )) fmt . Println ( reflect . TypeOf ( greetingPtr )) fmt . Println ( reflect . TypeOf ( f )) fmt . Println ( reflect . TypeOf ( fp )) } output: []int string *string main.Foo *main.Foo Reflection has three rules, that you should remember, when you work with reflect : Reflection goes from interface value to reflection object Reflection goes from reflection object to interface value To modify a reflection object, the value must be settable Reflection goes from interface value to reflection object If you use reflect.TypeOf you pass in any and get a Type back. Type is an interface to get more information about the reflected type. If we want to examine the Value of a specific variable we can do that by: 1 2 3 var x float64 = 3.4 fmt . Println ( \"type:\" , reflect . TypeOf ( x )) fmt . Println ( \"value:\" , reflect . ValueOf ( x ). String ()) We can use the reflection to check, if a variable has a specific type: 1 2 3 4 5 var x float64 = 3.4 v := reflect . ValueOf ( x ) fmt . Println ( \"type:\" , reflect . TypeOf ( x )) fmt . Println ( \"value:\" , v . String ()) fmt . Println ( \"kind is float64:\" , v . Kind () == reflect . Float64 ) output would be: type: float64 value: <float64 Value> kind is float64: true If you have a user-defined type, Type can give you the user-defined type, but Kind will always give you the built-in type. 1 2 3 4 5 type MyInt int var x MyInt = 7 v := reflect . ValueOf ( x ) fmt . Println ( v . Kind (). String ()) fmt . Println ( v . Type ()) Reflection goes from reflection object to interface value If we have a reflected reflect.Value , we can derive back the inverse of it. We call the Interface method on a Value to get it's interface again and then we can Type Assert it back to it's natural Go type. Let's take an example: 1 2 3 4 y := 2.9 v := reflect . ValueOf ( y ) x := v . Interface ().( float64 ) fmt . Printf ( \"x, type: %T, value: %v\\n\" , x , x ) output: x, type: float64, value: 2.9 To modify a reflection object, the value must be settable To set a value via reflection, the value must be settable. 1 2 3 var x float64 = 3.4 v := reflect . ValueOf ( x ) v . SetFloat ( 7.1 ) // Error: will panic. output: panic: reflect: reflect.Value.SetFloat using unaddressable value Go is call-by-value, therefore it's a copy of the variable x what reflect.ValueOf is using. When we want to set the value of x , we have to pass a \"Setable\" type: a pointer. 1 2 3 4 var x float64 = 3.4 v := reflect . ValueOf ( & x ) v . SetFloat ( 7.1 ) fmt . Println ( x ) If we now to set the value, the output would be: panic: reflect: reflect.Value.SetFloat using unaddressable value Why? Because we just try to set 7.1 to the pointer itself and not to the actual value in RAM. To get the actual Value of a pointer in the RAM we have to call [ Elem ]. Elem returns the value that the interface v contains or that the pointer v points to. It panics if v's Kind is not Interface or Pointer. It returns the zero Value if v is nil. Example: 1 2 3 4 var x float64 = 3.4 v := reflect . ValueOf ( & x ) v . Elem (). SetFloat ( 7.1 ) fmt . Println ( x ) now the output is correct: 7.1","title":"Reflect"},{"location":"golang/golang-fundamentals/reflect/#reflect","text":"Informative Source With reflect we get information about our variables at runtime. It's highly recommended not to use reflection, because every wrong usage can panic . Reflect should be the last possible way to do \"meta-programming\" in Go. But let's check an example anyway: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \"fmt\" \"reflect\" ) type Foo struct { A int `tag1:\"First Tag\" tag2:\"Second Tag\"` B string } func main () { sl := [] int { 1 , 2 , 3 } greeting := \"hello\" greetingPtr := & greeting f := Foo { A : 10 , B : \"Salutations\" } fp := & f fmt . Println ( reflect . TypeOf ( sl )) fmt . Println ( reflect . TypeOf ( greeting )) fmt . Println ( reflect . TypeOf ( greetingPtr )) fmt . Println ( reflect . TypeOf ( f )) fmt . Println ( reflect . TypeOf ( fp )) } output: []int string *string main.Foo *main.Foo Reflection has three rules, that you should remember, when you work with reflect : Reflection goes from interface value to reflection object Reflection goes from reflection object to interface value To modify a reflection object, the value must be settable","title":"Reflect"},{"location":"golang/golang-fundamentals/reflect/#reflection-goes-from-interface-value-to-reflection-object","text":"If you use reflect.TypeOf you pass in any and get a Type back. Type is an interface to get more information about the reflected type. If we want to examine the Value of a specific variable we can do that by: 1 2 3 var x float64 = 3.4 fmt . Println ( \"type:\" , reflect . TypeOf ( x )) fmt . Println ( \"value:\" , reflect . ValueOf ( x ). String ()) We can use the reflection to check, if a variable has a specific type: 1 2 3 4 5 var x float64 = 3.4 v := reflect . ValueOf ( x ) fmt . Println ( \"type:\" , reflect . TypeOf ( x )) fmt . Println ( \"value:\" , v . String ()) fmt . Println ( \"kind is float64:\" , v . Kind () == reflect . Float64 ) output would be: type: float64 value: <float64 Value> kind is float64: true If you have a user-defined type, Type can give you the user-defined type, but Kind will always give you the built-in type. 1 2 3 4 5 type MyInt int var x MyInt = 7 v := reflect . ValueOf ( x ) fmt . Println ( v . Kind (). String ()) fmt . Println ( v . Type ())","title":"Reflection goes from interface value to reflection object"},{"location":"golang/golang-fundamentals/reflect/#reflection-goes-from-reflection-object-to-interface-value","text":"If we have a reflected reflect.Value , we can derive back the inverse of it. We call the Interface method on a Value to get it's interface again and then we can Type Assert it back to it's natural Go type. Let's take an example: 1 2 3 4 y := 2.9 v := reflect . ValueOf ( y ) x := v . Interface ().( float64 ) fmt . Printf ( \"x, type: %T, value: %v\\n\" , x , x ) output: x, type: float64, value: 2.9","title":"Reflection goes from reflection object to interface value"},{"location":"golang/golang-fundamentals/reflect/#to-modify-a-reflection-object-the-value-must-be-settable","text":"To set a value via reflection, the value must be settable. 1 2 3 var x float64 = 3.4 v := reflect . ValueOf ( x ) v . SetFloat ( 7.1 ) // Error: will panic. output: panic: reflect: reflect.Value.SetFloat using unaddressable value Go is call-by-value, therefore it's a copy of the variable x what reflect.ValueOf is using. When we want to set the value of x , we have to pass a \"Setable\" type: a pointer. 1 2 3 4 var x float64 = 3.4 v := reflect . ValueOf ( & x ) v . SetFloat ( 7.1 ) fmt . Println ( x ) If we now to set the value, the output would be: panic: reflect: reflect.Value.SetFloat using unaddressable value Why? Because we just try to set 7.1 to the pointer itself and not to the actual value in RAM. To get the actual Value of a pointer in the RAM we have to call [ Elem ]. Elem returns the value that the interface v contains or that the pointer v points to. It panics if v's Kind is not Interface or Pointer. It returns the zero Value if v is nil. Example: 1 2 3 4 var x float64 = 3.4 v := reflect . ValueOf ( & x ) v . Elem (). SetFloat ( 7.1 ) fmt . Println ( x ) now the output is correct: 7.1","title":"To modify a reflection object, the value must be settable"},{"location":"golang/golang-fundamentals/standard_library/","text":"The standard library There are a lot of \"batteries included\" in Go. The standard library is really huge, let's check some of those packages to see, how they were implemented. io Input and Output Data into files is probably one of the main things, what a programm should can. The package io provide this functionality and two most used interfaces from this package are: 1 2 3 4 5 6 7 type Reader interface { Read ( p [] byte ) ( n int , err error ) } type Writer interface { Write ( p [] byte ) ( n int , err error ) } Reader and Writer are very simple and practical interfaces. They allow to read or write len(p) byte to a specific destination. This allows also to read buffered data, lets check an example here: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func countLetters ( r io . Reader ) ( map [ string ] int , error ) { buf := make ([] byte , 2048 ) out := map [ string ] int {} for { n , err := r . Read ( buf ) for _ , r range bug [: n ] { if ( r >= 'A' && r <= 'Z' ) || ( r >= 'a' && r <= 'z' ) { out [ string ( r )] ++ } } if err == io . EOF { return out , nil } if err != nil { return nil , nil } } } Let's see, how we can read a simple file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import ( \"fmt\" \"io\" \"log\" \"os\" ) func main () { f , err := os . OpenFile ( \"notes.txt\" , os . O_RDWR | os . O_CREATE , 0755 ) if err != nil { log . Fatal ( err ) } defer func () { if err := f . Close (); err != nil { log . Fatal ( err ) } }() data , err := io . ReadAll ( f ) if err != nil { log . Fatal ( err ) } fmt . Println ( string ( data )) } The ioutil.ReadAll reads a Reader interface until an error or io.EOF is read. time The time package is for working with dates, times and datetimes. The package contains two main types: time.Duration and time.Time . A period of time is represented as an int64 . The smallest amount of time is one nanosecond. But there are some constants, which can be used to calculate a minute, two seconds and so on: 1 2 3 h := 2 * time . Hour // 2 hours m := 3 * time . Minute // 3 minutes hm := h + m // 2 hours and 3 minutes time.ParseDuration can parse strings like 300ms or 2.3h : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import ( \"fmt\" \"time\" ) func main () { hours , _ := time . ParseDuration ( \"10h\" ) complex , _ := time . ParseDuration ( \"1h10m10s\" ) micro , _ := time . ParseDuration ( \"1\u00b5s\" ) // The package also accepts the incorrect but common prefix u for micro. micro2 , _ := time . ParseDuration ( \"1us\" ) fmt . Println ( hours ) fmt . Println ( complex ) fmt . Printf ( \"There are %.0f seconds in %v.\\n\" , complex . Seconds (), complex ) fmt . Printf ( \"There are %d nanoseconds in %v.\\n\" , micro . Nanoseconds (), micro ) fmt . Printf ( \"There are %6.2e seconds in %v.\\n\" , micro2 . Seconds (), micro ) } Now we come to a really unusual thing... parsing and formatting datetimes. Go follows the idea to use a format depending on the position in the string: 01/02 03:04:05PM 06 -0700 . So for example: 1 2 3 4 5 6 7 func main () { t , err := time . Parse ( \"2006-01-02 15:04:05 -0700\" , \"2016-01-13 00:12:43 +0000\" ) if err != nil { fmt . Println ( err ) } fmt . Println ( t . Format ( \"January 2, 2006 at 03:04:05PM MST\" )) } output would be: January 13, 2016 at 12:12:43AM UTC There are a lot of more functions to manipulate time.Time . Jus see some of the documentation gostradamus If you want to work with datetimes and to have a in-replacement for time you can use my Go package: gostradamus . It's a more \"convenient\" way to work with time.Time variables: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import ( \"fmt\" \"github.com/bykof/gostradamus\" ) func main () { dateTime , err := gostradamus . Parse ( \"14.07.2017 02:40:00\" , \"DD.MM.YYYY HH:mm:ss\" ) if err != nil { panic ( err ) } // Easy manipulation dateTime = dateTime . ShiftMonths ( - 5 ). ShiftDays ( 2 ) // Easy formatting fmt . Println ( dateTime . Format ( \"DD.MM.YYYY HH:mm:ss\" )) // 16.02.2017 02:40:00 // Easy helper functions start , end := dateTime . SpanWeek () fmt . Println ( start . String (), end . String ()) } output: 16.02.2017 02:40:00 2017-02-13T00:00:00.000000Z 2017-02-19T23:59:59.999999Z encoding/json Go has a builtin json parser. It uses the word Marshal ( Parse ) and Unmarshal ( Format ) for this library. Also Go uses structs or types to represent JSON object, arrays and so on. You can \"map\" json object fields onto your struct, even when the field names are different. Let's check an example: 1 2 3 4 5 6 7 8 9 10 { \"id\" : 123 , \"first_name\" : \"Test\" , \"last_name\" : \"Tester\" , \"birthday\" : \"1994-01-19T00:00:00Z\" , \"skills\" : [ { \"id\" : 1 , \"name\" : \"Running\" }, { \"id\" : 1 , \"name\" : \"Jumping\" } ] } now we define a struct to map the data: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import ( \"encoding/json\" \"fmt\" \"time\" ) type Skill struct { ID int `json:\"id\"` Name string `json:\"name\"` } type Skills [] Skill type Person struct { ID int `json:\"id\"` FirstName string `json:\"first_name\"` LastName string `json:\"last_name\"` Birthday time . Time `json:\"birthday\"` Skills Skills `json:\"skills\"` } func main () { s := ` { \"id\": 123, \"first_name\": \"Test\", \"last_name\": \"Tester\", \"birthday\": \"1994-01-19T00:00:00Z\", \"skills\": [ {\"id\": 1, \"name\": \"Running\"}, {\"id\": 1, \"name\": \"Jumping\"} ] }` var person Person err := json . Unmarshal ([] byte ( s ), & person ) if err != nil { panic ( err ) } fmt . Printf ( \"%#v\" , person ) } output: main.Person{ID:123, FirstName:\"Test\", LastName:\"Tester\", Birthday:time.Date(1994, time.January, 19, 0, 0, 0, 0, time.UTC), Skills:main.Skills{main.Skill{ID:1, Name:\"Running\"}, main.Skill{ID:1, Name:\"Jumping\"}}} net/http The net/http library has a client and a server . So you can send and receive http requests. client You can create a http.Client instance with a default timeout: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import ( \"context\" \"encoding/json\" \"fmt\" \"net/http\" \"time\" ) func main () { client := & http . Client { Timeout : 30 * time . Second , } request , err := http . NewRequestWithContext ( context . Background (), http . MethodGet , \"https://jsonplaceholder.typicode.com/todos/1\" , nil , ) if err != nil { panic ( err ) } response , err := client . Do ( request ) if err != nil { panic ( err ) } defer response . Body . Close () if response . StatusCode != http . StatusOK { panic ( fmt . Sprintf ( \"got unexpected status: %v\" , response . StatusCode )) } var data struct { ID int `json:\"id\"` UserID int `json:\"userId\"` Title string `json:\"title\"` Completed bool `json:\"completed\"` } err = json . NewDecoder ( response . Body ). Decode ( & data ) if err != nil { panic ( err ) } fmt . Printf ( \"%+v\" , data ) } output would be: {ID:1 UserID:1 Title:delectus aut autem Completed:false}% server The server http.ServeMux handles multiple paths. You can combine multiple ServeMux Handlers, but be aware, that you have to strip the path before the request will be given to any underlying handler. Every incoming request will be handled by it's own goroutine. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import ( \"fmt\" \"net/http\" \"time\" ) func main () { apiMux := http . NewServeMux () apiMux . HandleFunc ( \"/todo/\" , func ( w http . ResponseWriter , req * http . Request ) { w . Write ([] byte ( \"todo\" )) }) apiMux . HandleFunc ( \"/\" , func ( w http . ResponseWriter , req * http . Request ) { w . Write ([] byte ( \"api\" )) }) mux := http . NewServeMux () mux . Handle ( \"/api/\" , http . StripPrefix ( \"/api\" , apiMux )) mux . HandleFunc ( \"/\" , func ( w http . ResponseWriter , req * http . Request ) { // The \"/\" pattern matches everything, so we need to check // that we're at the root here. if req . URL . Path != \"/\" { http . NotFound ( w , req ) return } fmt . Fprintf ( w , \"Welcome to the home page!\" ) }) server := http . Server { Addr : \":8000\" , ReadTimeout : 30 * time . Second , WriteTimeout : 60 * time . Second , IdleTimeout : 120 * time . Second , Handler : mux , } err := server . ListenAndServe () if err != nil && err != http . ErrServerClosed { panic ( err ) } } Sometimes you need a middleware to check if the user is allowed to access an endpoint: main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 const Password = \"notsecurepassword\" func securityMiddleware ( h http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , req * http . Request ) { if req . Header . Get ( \"Authorization\" ) != Password { w . WriteHeader ( http . StatusUnauthorized ) w . Write ([] byte ( \"no access\" )) return } h . ServeHTTP ( w , req ) }) } func requestTimer ( h http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , req * http . Request ) { start := time . Now () h . ServeHTTP ( w , req ) end := time . Now () log . Printf ( \"request took: %s\" , end . Sub ( start )) }) } // ... mux . Handle ( \"/\" , requestTimer ( securityMiddleware ( http . HandlerFunc ( func ( w http . ResponseWriter , req * http . Request ) { // The \"/\" pattern matches everything, so we need to check // that we're at the root here. if req . URL . Path != \"/\" { http . NotFound ( w , req ) return } fmt . Fprintf ( w , \"Welcome to the home page!\" ) }, ), ), ), )","title":"The standard library"},{"location":"golang/golang-fundamentals/standard_library/#the-standard-library","text":"There are a lot of \"batteries included\" in Go. The standard library is really huge, let's check some of those packages to see, how they were implemented.","title":"The standard library"},{"location":"golang/golang-fundamentals/standard_library/#io","text":"Input and Output Data into files is probably one of the main things, what a programm should can. The package io provide this functionality and two most used interfaces from this package are: 1 2 3 4 5 6 7 type Reader interface { Read ( p [] byte ) ( n int , err error ) } type Writer interface { Write ( p [] byte ) ( n int , err error ) } Reader and Writer are very simple and practical interfaces. They allow to read or write len(p) byte to a specific destination. This allows also to read buffered data, lets check an example here: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func countLetters ( r io . Reader ) ( map [ string ] int , error ) { buf := make ([] byte , 2048 ) out := map [ string ] int {} for { n , err := r . Read ( buf ) for _ , r range bug [: n ] { if ( r >= 'A' && r <= 'Z' ) || ( r >= 'a' && r <= 'z' ) { out [ string ( r )] ++ } } if err == io . EOF { return out , nil } if err != nil { return nil , nil } } } Let's see, how we can read a simple file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import ( \"fmt\" \"io\" \"log\" \"os\" ) func main () { f , err := os . OpenFile ( \"notes.txt\" , os . O_RDWR | os . O_CREATE , 0755 ) if err != nil { log . Fatal ( err ) } defer func () { if err := f . Close (); err != nil { log . Fatal ( err ) } }() data , err := io . ReadAll ( f ) if err != nil { log . Fatal ( err ) } fmt . Println ( string ( data )) } The ioutil.ReadAll reads a Reader interface until an error or io.EOF is read.","title":"io"},{"location":"golang/golang-fundamentals/standard_library/#time","text":"The time package is for working with dates, times and datetimes. The package contains two main types: time.Duration and time.Time . A period of time is represented as an int64 . The smallest amount of time is one nanosecond. But there are some constants, which can be used to calculate a minute, two seconds and so on: 1 2 3 h := 2 * time . Hour // 2 hours m := 3 * time . Minute // 3 minutes hm := h + m // 2 hours and 3 minutes time.ParseDuration can parse strings like 300ms or 2.3h : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import ( \"fmt\" \"time\" ) func main () { hours , _ := time . ParseDuration ( \"10h\" ) complex , _ := time . ParseDuration ( \"1h10m10s\" ) micro , _ := time . ParseDuration ( \"1\u00b5s\" ) // The package also accepts the incorrect but common prefix u for micro. micro2 , _ := time . ParseDuration ( \"1us\" ) fmt . Println ( hours ) fmt . Println ( complex ) fmt . Printf ( \"There are %.0f seconds in %v.\\n\" , complex . Seconds (), complex ) fmt . Printf ( \"There are %d nanoseconds in %v.\\n\" , micro . Nanoseconds (), micro ) fmt . Printf ( \"There are %6.2e seconds in %v.\\n\" , micro2 . Seconds (), micro ) } Now we come to a really unusual thing... parsing and formatting datetimes. Go follows the idea to use a format depending on the position in the string: 01/02 03:04:05PM 06 -0700 . So for example: 1 2 3 4 5 6 7 func main () { t , err := time . Parse ( \"2006-01-02 15:04:05 -0700\" , \"2016-01-13 00:12:43 +0000\" ) if err != nil { fmt . Println ( err ) } fmt . Println ( t . Format ( \"January 2, 2006 at 03:04:05PM MST\" )) } output would be: January 13, 2016 at 12:12:43AM UTC There are a lot of more functions to manipulate time.Time . Jus see some of the documentation","title":"time"},{"location":"golang/golang-fundamentals/standard_library/#gostradamus","text":"If you want to work with datetimes and to have a in-replacement for time you can use my Go package: gostradamus . It's a more \"convenient\" way to work with time.Time variables: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import ( \"fmt\" \"github.com/bykof/gostradamus\" ) func main () { dateTime , err := gostradamus . Parse ( \"14.07.2017 02:40:00\" , \"DD.MM.YYYY HH:mm:ss\" ) if err != nil { panic ( err ) } // Easy manipulation dateTime = dateTime . ShiftMonths ( - 5 ). ShiftDays ( 2 ) // Easy formatting fmt . Println ( dateTime . Format ( \"DD.MM.YYYY HH:mm:ss\" )) // 16.02.2017 02:40:00 // Easy helper functions start , end := dateTime . SpanWeek () fmt . Println ( start . String (), end . String ()) } output: 16.02.2017 02:40:00 2017-02-13T00:00:00.000000Z 2017-02-19T23:59:59.999999Z","title":"gostradamus"},{"location":"golang/golang-fundamentals/standard_library/#encodingjson","text":"Go has a builtin json parser. It uses the word Marshal ( Parse ) and Unmarshal ( Format ) for this library. Also Go uses structs or types to represent JSON object, arrays and so on. You can \"map\" json object fields onto your struct, even when the field names are different. Let's check an example: 1 2 3 4 5 6 7 8 9 10 { \"id\" : 123 , \"first_name\" : \"Test\" , \"last_name\" : \"Tester\" , \"birthday\" : \"1994-01-19T00:00:00Z\" , \"skills\" : [ { \"id\" : 1 , \"name\" : \"Running\" }, { \"id\" : 1 , \"name\" : \"Jumping\" } ] } now we define a struct to map the data: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import ( \"encoding/json\" \"fmt\" \"time\" ) type Skill struct { ID int `json:\"id\"` Name string `json:\"name\"` } type Skills [] Skill type Person struct { ID int `json:\"id\"` FirstName string `json:\"first_name\"` LastName string `json:\"last_name\"` Birthday time . Time `json:\"birthday\"` Skills Skills `json:\"skills\"` } func main () { s := ` { \"id\": 123, \"first_name\": \"Test\", \"last_name\": \"Tester\", \"birthday\": \"1994-01-19T00:00:00Z\", \"skills\": [ {\"id\": 1, \"name\": \"Running\"}, {\"id\": 1, \"name\": \"Jumping\"} ] }` var person Person err := json . Unmarshal ([] byte ( s ), & person ) if err != nil { panic ( err ) } fmt . Printf ( \"%#v\" , person ) } output: main.Person{ID:123, FirstName:\"Test\", LastName:\"Tester\", Birthday:time.Date(1994, time.January, 19, 0, 0, 0, 0, time.UTC), Skills:main.Skills{main.Skill{ID:1, Name:\"Running\"}, main.Skill{ID:1, Name:\"Jumping\"}}}","title":"encoding/json"},{"location":"golang/golang-fundamentals/standard_library/#nethttp","text":"The net/http library has a client and a server . So you can send and receive http requests.","title":"net/http"},{"location":"golang/golang-fundamentals/standard_library/#client","text":"You can create a http.Client instance with a default timeout: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import ( \"context\" \"encoding/json\" \"fmt\" \"net/http\" \"time\" ) func main () { client := & http . Client { Timeout : 30 * time . Second , } request , err := http . NewRequestWithContext ( context . Background (), http . MethodGet , \"https://jsonplaceholder.typicode.com/todos/1\" , nil , ) if err != nil { panic ( err ) } response , err := client . Do ( request ) if err != nil { panic ( err ) } defer response . Body . Close () if response . StatusCode != http . StatusOK { panic ( fmt . Sprintf ( \"got unexpected status: %v\" , response . StatusCode )) } var data struct { ID int `json:\"id\"` UserID int `json:\"userId\"` Title string `json:\"title\"` Completed bool `json:\"completed\"` } err = json . NewDecoder ( response . Body ). Decode ( & data ) if err != nil { panic ( err ) } fmt . Printf ( \"%+v\" , data ) } output would be: {ID:1 UserID:1 Title:delectus aut autem Completed:false}%","title":"client"},{"location":"golang/golang-fundamentals/standard_library/#server","text":"The server http.ServeMux handles multiple paths. You can combine multiple ServeMux Handlers, but be aware, that you have to strip the path before the request will be given to any underlying handler. Every incoming request will be handled by it's own goroutine. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import ( \"fmt\" \"net/http\" \"time\" ) func main () { apiMux := http . NewServeMux () apiMux . HandleFunc ( \"/todo/\" , func ( w http . ResponseWriter , req * http . Request ) { w . Write ([] byte ( \"todo\" )) }) apiMux . HandleFunc ( \"/\" , func ( w http . ResponseWriter , req * http . Request ) { w . Write ([] byte ( \"api\" )) }) mux := http . NewServeMux () mux . Handle ( \"/api/\" , http . StripPrefix ( \"/api\" , apiMux )) mux . HandleFunc ( \"/\" , func ( w http . ResponseWriter , req * http . Request ) { // The \"/\" pattern matches everything, so we need to check // that we're at the root here. if req . URL . Path != \"/\" { http . NotFound ( w , req ) return } fmt . Fprintf ( w , \"Welcome to the home page!\" ) }) server := http . Server { Addr : \":8000\" , ReadTimeout : 30 * time . Second , WriteTimeout : 60 * time . Second , IdleTimeout : 120 * time . Second , Handler : mux , } err := server . ListenAndServe () if err != nil && err != http . ErrServerClosed { panic ( err ) } } Sometimes you need a middleware to check if the user is allowed to access an endpoint: main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 const Password = \"notsecurepassword\" func securityMiddleware ( h http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , req * http . Request ) { if req . Header . Get ( \"Authorization\" ) != Password { w . WriteHeader ( http . StatusUnauthorized ) w . Write ([] byte ( \"no access\" )) return } h . ServeHTTP ( w , req ) }) } func requestTimer ( h http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , req * http . Request ) { start := time . Now () h . ServeHTTP ( w , req ) end := time . Now () log . Printf ( \"request took: %s\" , end . Sub ( start )) }) } // ... mux . Handle ( \"/\" , requestTimer ( securityMiddleware ( http . HandlerFunc ( func ( w http . ResponseWriter , req * http . Request ) { // The \"/\" pattern matches everything, so we need to check // that we're at the root here. if req . URL . Path != \"/\" { http . NotFound ( w , req ) return } fmt . Fprintf ( w , \"Welcome to the home page!\" ) }, ), ), ), )","title":"server"},{"location":"golang/golang-fundamentals/tags/","text":"Tags Some libraries like encoding/json use tags for more information in a struct. Tags can be fetched by using reflect. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type Person struct { FirstName string `json:\"first_name,omitempty\" other:\"hello\"` } func main () { person := Person { FirstName : \"Michael\" , } personType := reflect . TypeOf ( person ) if firstNameField , ok := personType . FieldByName ( \"FirstName\" ); ok { fmt . Println ( firstNameField . Tag . Get ( \"json\" )) fmt . Println ( firstNameField . Tag . Get ( \"other\" )) } } output: first_name,omitempty hello JSON Tags If you use, for example encoding/json , you influence how your fields get Marshaled or Unmarshaled Source . We can set the key name of the json object, by using tags. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type Person struct { FirstName string `json:\"first_name,omitempty\"` } func main () { person := Person { FirstName : \"Michael\" , } data , err := json . Marshal ( person ) if err != nil { fmt . Println ( err ) } fmt . Println ( string ( data )) } output: {\"first_name\":\"Michael\"} If we use omitempty on a field and the field value is set to a zero value, then the field will be truncated: 1 2 3 4 5 6 7 8 person := Person {} data , err := json . Marshal ( person ) if err != nil { fmt . Println ( err ) } fmt . Println ( string ( data )) output: {} If we do not use omitempty the field will be included always: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type Person struct { FirstName string `json:\"first_name\"` } func main () { person := Person {} data , err := json . Marshal ( person ) if err != nil { fmt . Println ( err ) } fmt . Println ( string ( data )) } output: {\"first_name\":\"\"}","title":"Tags"},{"location":"golang/golang-fundamentals/tags/#tags","text":"Some libraries like encoding/json use tags for more information in a struct. Tags can be fetched by using reflect. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type Person struct { FirstName string `json:\"first_name,omitempty\" other:\"hello\"` } func main () { person := Person { FirstName : \"Michael\" , } personType := reflect . TypeOf ( person ) if firstNameField , ok := personType . FieldByName ( \"FirstName\" ); ok { fmt . Println ( firstNameField . Tag . Get ( \"json\" )) fmt . Println ( firstNameField . Tag . Get ( \"other\" )) } } output: first_name,omitempty hello","title":"Tags"},{"location":"golang/golang-fundamentals/tags/#json-tags","text":"If you use, for example encoding/json , you influence how your fields get Marshaled or Unmarshaled Source . We can set the key name of the json object, by using tags. Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type Person struct { FirstName string `json:\"first_name,omitempty\"` } func main () { person := Person { FirstName : \"Michael\" , } data , err := json . Marshal ( person ) if err != nil { fmt . Println ( err ) } fmt . Println ( string ( data )) } output: {\"first_name\":\"Michael\"} If we use omitempty on a field and the field value is set to a zero value, then the field will be truncated: 1 2 3 4 5 6 7 8 person := Person {} data , err := json . Marshal ( person ) if err != nil { fmt . Println ( err ) } fmt . Println ( string ( data )) output: {} If we do not use omitempty the field will be included always: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type Person struct { FirstName string `json:\"first_name\"` } func main () { person := Person {} data , err := json . Marshal ( person ) if err != nil { fmt . Println ( err ) } fmt . Println ( string ( data )) } output: {\"first_name\":\"\"}","title":"JSON Tags"},{"location":"golang/golang-fundamentals/tests/","text":"Tests Tests are important. Tests check, if you application works as expected. Tests in Go are so easy, it's easier to write tests than not to do it. Normally you will not see any logs from tests, unles you set the -v (verbose) flag. Tests are executed automatically when you name your files *_test.go . Let's dive in with an easy example: calculator.go 1 2 3 func add ( a , b int ) int { return a + b } calculator_test.go 1 2 3 4 5 6 7 func Test_add ( t * testing . T ) { result := add ( 1 , 2 ) expected := 2 if result != expected { t . Error ( \"not correct, expected\" , expected , \" got\" , result ) } } If you run go test ./... the output is: ? example [no test files] --- FAIL: Test_add (0.00s) calculator_test.go:9: not correct, expected 2 got 3 FAIL FAIL example/calculator 0.153s FAIL Let's fix the test: calculator_test.go 1 2 3 4 5 6 7 func Test_add ( t * testing . T ) { result := add ( 1 , 2 ) expected := 3 if result != expected { t . Error ( \"not correct, expected\" , expected , \" got\" , result ) } } Now the tests are running properly: ? example [no test files] ok example/calculator 0.154s Setup and Teardown To setup a test use a function called TestMain . To teardown a tests files and data use t.Cleanup(func() { ... }) . calculator_test.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func TestMain ( m * testing . M ) { fmt . Println ( \"Setting up...\" ) fmt . Println ( \"Running tests...\" ) exitValue := m . Run () fmt . Println ( \"Clean up all tests...\" ) os . Exit ( exitValue ) } func Test_add ( t * testing . T ) { result := add ( 1 , 2 ) expected := 3 if result != expected { t . Error ( \"not correct, expected\" , expected , \" got\" , result ) } t . Cleanup ( func () { fmt . Println ( \"Teardown test\" ) }) } By running the tests with: go test ./... -v the output is: ? reader_writer [no test files] Setting up... Running tests... === RUN Test_add Teardown add test --- PASS: Test_add (0.00s) PASS Clean up all tests... ok reader_writer/calculator 0.152s Public API Testing If you want to test your public exposed functions or methods you can create a \"*_test\" package. This will, by definition, create a new package, which can only access exported functions and methods. Let's check that: calculator/calculator.go 1 2 3 func Add ( a int , b int ) int { return a + b } calculator/calculator_test/calculator_test.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package calculator import ( \"testing\" \"example/calculator\" ) func Test_Add ( t * testing . T ) { result := calculator . Add ( 1 , 2 ) expected := 3 if result != expected { t . Error ( \"not correct, expected\" , expected , \" got\" , result ) } } Testify In a lot of projects you will see the package github.com/stretchr/testify/assert . This is because it brings a more \"convenient\" way of testing with assertions, mocking, and suite. Let's check some examples: main.go 1 2 3 4 5 6 7 8 import ( \"testing\" \"github.com/stretchr/testify/assert\" ) func Test_Add ( t * testing . T ) { assert . Equal ( t , 3 , calculator . Add ( 1 , 2 )) }","title":"Tests"},{"location":"golang/golang-fundamentals/tests/#tests","text":"Tests are important. Tests check, if you application works as expected. Tests in Go are so easy, it's easier to write tests than not to do it. Normally you will not see any logs from tests, unles you set the -v (verbose) flag. Tests are executed automatically when you name your files *_test.go . Let's dive in with an easy example: calculator.go 1 2 3 func add ( a , b int ) int { return a + b } calculator_test.go 1 2 3 4 5 6 7 func Test_add ( t * testing . T ) { result := add ( 1 , 2 ) expected := 2 if result != expected { t . Error ( \"not correct, expected\" , expected , \" got\" , result ) } } If you run go test ./... the output is: ? example [no test files] --- FAIL: Test_add (0.00s) calculator_test.go:9: not correct, expected 2 got 3 FAIL FAIL example/calculator 0.153s FAIL Let's fix the test: calculator_test.go 1 2 3 4 5 6 7 func Test_add ( t * testing . T ) { result := add ( 1 , 2 ) expected := 3 if result != expected { t . Error ( \"not correct, expected\" , expected , \" got\" , result ) } } Now the tests are running properly: ? example [no test files] ok example/calculator 0.154s","title":"Tests"},{"location":"golang/golang-fundamentals/tests/#setup-and-teardown","text":"To setup a test use a function called TestMain . To teardown a tests files and data use t.Cleanup(func() { ... }) . calculator_test.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func TestMain ( m * testing . M ) { fmt . Println ( \"Setting up...\" ) fmt . Println ( \"Running tests...\" ) exitValue := m . Run () fmt . Println ( \"Clean up all tests...\" ) os . Exit ( exitValue ) } func Test_add ( t * testing . T ) { result := add ( 1 , 2 ) expected := 3 if result != expected { t . Error ( \"not correct, expected\" , expected , \" got\" , result ) } t . Cleanup ( func () { fmt . Println ( \"Teardown test\" ) }) } By running the tests with: go test ./... -v the output is: ? reader_writer [no test files] Setting up... Running tests... === RUN Test_add Teardown add test --- PASS: Test_add (0.00s) PASS Clean up all tests... ok reader_writer/calculator 0.152s","title":"Setup and Teardown"},{"location":"golang/golang-fundamentals/tests/#public-api-testing","text":"If you want to test your public exposed functions or methods you can create a \"*_test\" package. This will, by definition, create a new package, which can only access exported functions and methods. Let's check that: calculator/calculator.go 1 2 3 func Add ( a int , b int ) int { return a + b } calculator/calculator_test/calculator_test.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package calculator import ( \"testing\" \"example/calculator\" ) func Test_Add ( t * testing . T ) { result := calculator . Add ( 1 , 2 ) expected := 3 if result != expected { t . Error ( \"not correct, expected\" , expected , \" got\" , result ) } }","title":"Public API Testing"},{"location":"golang/golang-fundamentals/tests/#testify","text":"In a lot of projects you will see the package github.com/stretchr/testify/assert . This is because it brings a more \"convenient\" way of testing with assertions, mocking, and suite. Let's check some examples: main.go 1 2 3 4 5 6 7 8 import ( \"testing\" \"github.com/stretchr/testify/assert\" ) func Test_Add ( t * testing . T ) { assert . Equal ( t , 3 , calculator . Add ( 1 , 2 )) }","title":"Testify"},{"location":"golang/golang-fundamentals/third_party_libraries/","text":"Third Party Libraries gorm : ORM library gin : Web Framework cobra : CLI library zap : Logger Library for Go Go Awesome","title":"Third Party Libraries"},{"location":"golang/golang-fundamentals/third_party_libraries/#third-party-libraries","text":"gorm : ORM library gin : Web Framework cobra : CLI library zap : Logger Library for Go Go Awesome","title":"Third Party Libraries"},{"location":"golang/golang-fundamentals/types_interfaces_methods/","text":"Types, Interfaces and Methods Types Go allows you to declare a user-defined type. It can be a struct literal or primitive type. Let's see an example: 1 2 3 4 5 6 7 8 type Person struct { FirstName string LastName string } type Score int type Converter func ( string ) Score type TeamScores map [ string ] Score Methods Like many programming languages, Go supports Methods on user-defined types. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type Person struct { FirstName string LastName string Age int } func ( p Person ) String () string { return fmt . Sprintf ( \"%s %s: age %d\" , p . FirstName , p . LastName , p . Age ) } func main () { p := Person { FirstName : \"Michael\" , LastName : \"Bykovski\" , Age : 28 , } fmt . Println ( p . String ()) } The receiver declares to which type a function belongs to. The receiver is between the func keyword and the method's name and it's usually a short abbreviation of the receiver type and not conventional names like self or this . Method overloading is prohibited. You can use the same name for different user-defined types, but not two methods with the same name for one specific user-defined types. Pointer Receivers As with usual functions the parameters (or receivers) of function are passed by value. This means, that the method will work on a copy of the receiver variable. If you want to modify the receiver variable, you can use pointer receivers: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type Counter struct { total int lastUpdated time . Time } func ( c * Counter ) Increment () { c . total ++ c . lastUpdated = time . Now () } func ( c Counter ) String () string { return fmt . Sprintf ( \"counts: %d, last updated %v\" , c . total , c . lastUpdated ) } func main () { counter := Counter {} fmt . Println ( counter . String ()) counter . Increment () fmt . Println ( counter . String ()) } output will be: counts: 0, last updated 0001-01-01 00:00:00 +0000 UTC counts: 1, last updated 2009-11-10 23:00:00 +0000 UTC m=+0.000000001 If you use counter you dont have to convert it to a pointer type, because you use the method of the specific type. So therefore counter.Increment() is converted to (&counter).Increment() Be aware if you pass in a copy of a variable and work with the pointer type of it. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 type Counter struct { total int lastUpdated time . Time } func ( c * Counter ) Increment () { c . total ++ c . lastUpdated = time . Now () } func ( c Counter ) String () string { return fmt . Sprintf ( \"counts: %d, last updated %v\" , c . total , c . lastUpdated ) } func update ( counter Counter ) { counter . Increment () } func main () { counter := Counter {} fmt . Println ( counter . String ()) update ( counter ) fmt . Println ( counter . String ()) } will output: counts: 0, last updated 0001-01-01 00:00:00 +0000 UTC counts: 0, last updated 0001-01-01 00:00:00 +0000 UTC Nil and Methods If a struct poiner gets declared but not initialized it becomes nil. Implementing pointer receivers on structs can produce a problem. But Go handles it quiet easily: If you create a nil struct pointer and call a value receiver, it will panic If you create a nil struct pointer and call a pointer receiver, it will try to execute the function Here are some examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 type Person struct { FirstName string LastName string } func ( p * Person ) ChangeName ( newName string ) * Person { if p == nil { return & Person { LastName : newName , } } p . LastName = newName return p } func ( p Person ) String () string { return fmt . Sprintf ( \"%s %s\" , p . FirstName , p . LastName ) } func main () { var person * Person newPerson := person . ChangeName ( \"Test\" ) fmt . Println ( newPerson . String ()) fmt . Println ( person . String ()) } output: Test panic: runtime error: invalid memory address or nil pointer dereference Nested Typing is not Inheritance One could believe that if you nest different types, you get a similar behaviour like inheratance. But this is not correct. Inheritance would enable the possibility to use the underlying defined methods for the inherited type, but this is not the case. Every type builds it's own \"environment\" with methods. You can't even assign a child type to a parent type, because in Go those type are two different one and don't belong together. Danger This won't work: 1 2 3 4 5 6 7 8 9 10 11 12 13 type Score int type TeamScore Score func ( s Score ) Good () bool { return s > 10 } func main () { var score Score teamScore := TeamScore ( 10 ) fmt . Println ( \"Team Score is: \" , teamScore . Good ()) score = teamScore } Success This works: 1 2 3 4 5 6 7 8 9 10 11 12 13 type Score int type TeamScore Score func ( s Score ) Good () bool { return s > 10 } func main () { var score Score teamScore := TeamScore ( 10 ) fmt . Println ( \"Team Score is: \" , Score ( teamScore ). Good ()) score = Score ( teamScore ) } iotas are Enums Go doesn't have the concept of enumerations. But it has iota , which somehow has the same concepts, but different. If you start with iota define an integer type: 1 type PurchasingCategory int then start with a const block and define a some iotas: 1 2 3 4 5 6 7 const ( NoCategory PurchasingCategory = iota Shirts Pants Watches Hats ) If the Go compiler sees iota at the end of a line and succeeding lines of constants it will increment each line by one. The first constant NoCategory receives the value 0 . If you define a new const block with another variable, iota will start again from 0 . Danger This will not work ```go linenums=\"1\" type Test int const ( one Test = 1 two three ) func main() { fmt.Println(one, two, three) } ``` output: ``` 1 1 1 ``` Success This is the correct usage: 1 2 3 4 5 6 7 8 9 10 11 type Test int const ( one Test = iota two three ) func main () { fmt . Println ( one , two , three ) } Use iota only if you are not relying on the value of the constants. Because the values can be changed, if you insert a new constant in the middle of the definition block. Use commond constants with a value assigned if you use it for database entries or outgoing messages. Use iotas only for \"internal\" computation, where you need some kind of named constant where the value doesn't matter. Embedding is Composition There is some kind of inheritance in Go what is called \"Composition\". Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package main import ( \"fmt\" \"strings\" ) type Employee struct { Name string ID string } func ( e Employee ) Description () string { return fmt . Sprintf ( \"%s: %s\" , e . ID , e . Name ) } type Project struct { Name string } type Projects [] Project func ( ps Projects ) ProjectNames () [] string { var names [] string for _ , project := range ps { names = append ( names , project . Name ) } return names } type SoftwareDeveloper struct { Employee Projects Projects } func ( sd SoftwareDeveloper ) String () string { return fmt . Sprintf ( \"%s\\nProjects: \\n%s\" , sd . Description (), strings . Join ( sd . Projects . ProjectNames (), \"\\n\" , ), ) } func main () { developer := SoftwareDeveloper { Employee : Employee { Name : \"Michael Bykovski\" , ID : \"1\" , }, Projects : Projects { { Name : \"Daimler\" }, { Name : \"Deutsche B\u00f6rse\" }, }, } fmt . Println ( developer ) } It is important to leave the name of the variable of the embedding struct (line 33). If you want to overwrite the embedded function or some field, just do it. They will be still accessable: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 type Inner struct { Y int } func ( i Inner ) String () string { return fmt . Sprintf ( \"%d\" , i . Y ) } type Outer struct { Inner Y int } func ( o Outer ) String () string { return fmt . Sprintf ( \"%d\" , o . Y ) } func main () { outer := Outer { Inner : Inner { Y : 5 , }, Y : 10 , } fmt . Println ( outer . String (), outer . Inner . String ()) } output: 10 5 Embedding is not Inheritance Do not treat embedding as inheritance. You cannot assign an inherited member to the parent type 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type Inner struct { Y int } type Outer struct { Inner Y int } func main () { var inner Inner outer := Outer { Inner : Inner { Y : 1 , }, Y : 2 , } inner = outer } output would be: cannot use outer (variable of type Outer) as type Inner in assignment this would fix it: 1 2 3 4 5 6 7 8 9 10 func main () { var inner Inner outer := Outer { Inner : Inner { Y : 1 , }, Y : 2 , } inner = outer . Inner } Go does not dynamically dispatch the Methods 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 type Inner struct { Y int } func ( i Inner ) IntPrinter ( value int ) string { return fmt . Sprintf ( \"Inner: %d\" , value ) } func ( i Inner ) Double () string { return i . IntPrinter ( i . Y * 2 ) } type Outer struct { Inner Y int } func ( o Outer ) IntPrinter ( value int ) string { return fmt . Sprintf ( \"Outer: %d\" , value ) } func main () { outer := Outer { Inner : Inner { Y : 2 , }, Y : 4 , } fmt . Println ( outer . Double ()) } If you have a struct, which embeds another struct and you can an embedded function, it will resolve other functions of the struct in the \"embedded scope\". Interfaces The only abstract type in Go are interfaces . So let's check them out: 1 2 3 type Stringer interface { String () string } Usually Interfaces end with \"er\", there are several Go built-in interfaces like io.Reader , io.Closer , io.ReadCloser , json.Marshaler . Implicit Interfaces Go Interfaces work in a different way compared to other programming languages. Types implement interfaces by implementing their function signatures. Let's check it out: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 type ConsoleWriter struct { Prefix string } func ( cw ConsoleWriter ) Write ( data string ) { fmt . Println ( cw . Prefix , \":\" , data ) } type Writer interface { Write ( data string ) } type Application struct { W Writer } func ( a Application ) Run () { a . W . Write ( \"Hello World\" ) } func main () { application := Application { W : ConsoleWriter { Prefix : \"ConsoleWriter\" , }, } application . Run () } Application wants a type that fulfills the Writer interface. Since ConsoleWriter implements the defined function signatures of the Writer interface, it implements automatically the Writer interface. Interfaces are a type and therefore they can be shared like functions, variables and structs. Let's check this example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 type ConsoleWriter struct { Prefix string } func ( cw ConsoleWriter ) Write ( data string ) { fmt . Println ( cw . Prefix , \":\" , data ) } type Writer interface { Write ( data string ) } type Application struct { W Writer } func NewApplication ( w Writer ) Application { return Application { W : w , } } func ( a Application ) Run () { a . W . Write ( \"Hello World\" ) } func main () { consoleWriter := ConsoleWriter { Prefix : \"ConsoleWriter\" , } application := NewApplication ( consoleWriter ) application . Run () } You can also append new methods to structs which implement interfaces. As long as the signature fulfills the interface, it implements the interface, all other methods belong to the struct. Multiple interface implementations are also possible: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 type ConsoleWriter struct { Prefix string Cache string } func ( cw ConsoleWriter ) Write ( data string ) { fmt . Printf ( \"%s: %s (cached: %s)\" , cw . Prefix , data , cw . Cache ) cw . Cache = \"\" } func ( cw * ConsoleWriter ) Read ( data string ) { cw . Cache = data } func ( cw * ConsoleWriter ) PurgeCache () { cw . Cache = \"\" } type Writer interface { Write ( data string ) } type Reader interface { Read ( data string ) } type Application struct { W Writer R Reader } func NewApplication ( w Writer , r Reader ) Application { return Application { W : w , R : r , } } func ( a Application ) Run () { a . R . Read ( \"Hello World\" ) a . W . Write ( \"Hello Go\" ) } func main () { consoleWriter := ConsoleWriter { Prefix : \"ConsoleWriter\" , } application := NewApplication ( & consoleWriter , & consoleWriter ) application . Run () consoleWriter . PurgeCache () } Embedding Interfaces The same way you can embed structs, you can embed interfaces too. Here is an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 type ConsoleWriter struct { Prefix string Cache string } func ( cw ConsoleWriter ) Write ( data string ) { fmt . Printf ( \"%s: %s (cached: %s)\" , cw . Prefix , data , cw . Cache ) cw . Cache = \"\" } func ( cw * ConsoleWriter ) Read ( data string ) { cw . Cache = data } func ( cw * ConsoleWriter ) PurgeCache () { cw . Cache = \"\" } type Writer interface { Write ( data string ) } type Reader interface { Read ( data string ) } type ReaderWriter interface { Reader Writer } type Application struct { RW ReaderWriter } func NewApplication ( readerWriter ReaderWriter ) Application { return Application { RW : readerWriter , } } func ( a Application ) Run () { a . RW . Read ( \"Hello World\" ) a . RW . Write ( \"Hello Go\" ) } func main () { consoleWriter := ConsoleWriter { Prefix : \"ConsoleWriter\" , } application := NewApplication ( & consoleWriter ) application . Run () consoleWriter . PurgeCache () } Accept Interfaces, Return Concrete Types As we want to decouple our code but make it easy to adapt we should build functions that accept interfaces and return concrete types. Because interfaces define a specific functionality our code should accept functionality, run it and return a concrete behaviour or value. Let's take for example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type UserData struct { // ... } type Authentication struct { // ... } func ( a Authentication ) Auth () ( UserData , error ) { // ... return UserData {}, nil } func DoAuthentication ( a Authentication ) ( UserData , error ) { // ... return a . Auth () } If we want now to support multiple Auth methods for example, we can open the DoAuthentication for an interface, which defines the Method Auth but we should still a concrete struct, for further implementations: userdata.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 type AppleUserData struct { // ... } type GoogleUserData struct { // ... } type UserData struct { AppleUserData * AppleUserData GoogleUserData * GoogleUserData } func ( ud UserData ) IsApple () { // ... } func ( ud UserData ) IsGoogle () { // ... } type Authenticator interface { Auth () ( UserData , error ) } type GoogleAuthentication struct { // ... } func ( ga GoogleAuthentication ) Auth () ( UserData , error ) { // ... return UserData { GoogleUserData : & GoogleUserData { // ... }, }, nil } type AppleAuthentication struct { // ... } func ( aa AppleAuthentication ) Auth () ( UserData , error ) { return UserData { AppleUserData : & AppleUserData { // ... }, }, nil } func DoAuthentication ( a Authenticator ) ( UserData , error ) { return a . Auth () } Danger Do NOT do this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 type UserData struct { // ... } type UserDataGetter interface { UserData () UserData } type AppleUserData struct { // ... } func ( aud AppleUserData ) UserData () { } type GoogleUserData struct { // ... } // ... func DoAuthentication ( a Authenticator ) UserDataGetter { return a . Auth () } If you want to read more about \"accept interfaces, return concrete types\" follow this and this The rule is: Unnecessary abstraction creates unnecessary complication. Don\u2019t over complicate code until it\u2019s needed. Interfaces and nil Interfaces are nil as long as they: don't have a type don't have a value This example should make it clear: 1 2 3 4 5 6 7 8 var s * string fmt . Println ( s == nil ) // true var i interface {} fmt . Println ( i == nil ) // true i = s fmt . Println ( i == nil ) // false This tells us, that if an interface has a struct which is nil, it can still run methods of the nil-struct: 1 2 3 4 5 6 7 8 9 10 11 12 13 type Dog struct {} func ( d * Dog ) BarkGhost () { fmt . Println ( \"Woof!\" ) } func main () { var ghostDog interface {} var dog * Dog ghostDog = dog ghostDog .( * Dog ). BarkGhost () } Empty Interface All The Way Sometimes you need to define a variable, where you will not know which type it is going to have. Take interface for that: 1 2 3 4 5 6 7 8 9 var i interface {} i = 10 fmt . Println ( i ) i = \"Hello\" fmt . Println ( i ) i = func ( word string ) string { return word } fmt . Println ( i ) output: 10 Hello 0x47dcc0 Mostly you won't need an empty interface. Sometimes you will need it to store some really unknown data structure, which comes from an unknown json schema: 1 2 3 4 5 6 7 8 9 10 func main () { data := map [ string ] interface {}{} contents , err := ioutil . ReadFile ( \"data.json\" ) if err != nil { return err } defer contents . Close () json . Unmarshal ( contents , & data ) } Type Assertions and Type Switches Type Assertions Let's make first a type assertions, so we assert a specific type to an interface variable: 1 2 3 4 5 6 7 8 9 type Score int func main () { var i interface {} var score Score = 20 i = score i2 := i .( Score ) fmt . Println ( i2 + score ) } If you try to assert a type, which could not work, Go will panic: 1 2 3 4 5 6 7 8 9 type Score int func main () { var i interface {} var score Score = 20 i = score i2 := i .( string ) fmt . Println ( i2 ) } output: interface conversion: interface {} is main.Score, not string The type has to match the exact underlying type, not embedded or type inferenced . 1 2 3 4 5 6 7 8 9 type Score int func main () { var i interface {} var score Score = 20 i = score i2 := i .( int ) fmt . Println ( i2 + score ) } output: interface conversion: interface {} is main.Score, not int If you want to test in your code and don't want to panic, use the variable, ok := idiom 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type Score int func main () { var i interface {} var score Score = 1 i = score i2 , ok := i .( int ) if ! ok { fmt . Printf ( \"i is not an int: %v\" , i ) return } fmt . Println ( i2 + 1 ) } Type Switches If your interface variable can have multiple types, use a type switch: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func checkType ( i interface {}) { switch j := i .( type ) { case nil : fmt . Println ( \"i is nil\" ) return case int : fmt . Println ( \"i is an int\" ) return case string fmt . Println ( \"i is a string\" ) return default : fmt . Println ( \"the type is not defined as case\" ) return } }","title":"Types, Interfaces and Methods"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#types-interfaces-and-methods","text":"","title":"Types, Interfaces and Methods"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#types","text":"Go allows you to declare a user-defined type. It can be a struct literal or primitive type. Let's see an example: 1 2 3 4 5 6 7 8 type Person struct { FirstName string LastName string } type Score int type Converter func ( string ) Score type TeamScores map [ string ] Score","title":"Types"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#methods","text":"Like many programming languages, Go supports Methods on user-defined types. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type Person struct { FirstName string LastName string Age int } func ( p Person ) String () string { return fmt . Sprintf ( \"%s %s: age %d\" , p . FirstName , p . LastName , p . Age ) } func main () { p := Person { FirstName : \"Michael\" , LastName : \"Bykovski\" , Age : 28 , } fmt . Println ( p . String ()) } The receiver declares to which type a function belongs to. The receiver is between the func keyword and the method's name and it's usually a short abbreviation of the receiver type and not conventional names like self or this . Method overloading is prohibited. You can use the same name for different user-defined types, but not two methods with the same name for one specific user-defined types.","title":"Methods"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#pointer-receivers","text":"As with usual functions the parameters (or receivers) of function are passed by value. This means, that the method will work on a copy of the receiver variable. If you want to modify the receiver variable, you can use pointer receivers: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type Counter struct { total int lastUpdated time . Time } func ( c * Counter ) Increment () { c . total ++ c . lastUpdated = time . Now () } func ( c Counter ) String () string { return fmt . Sprintf ( \"counts: %d, last updated %v\" , c . total , c . lastUpdated ) } func main () { counter := Counter {} fmt . Println ( counter . String ()) counter . Increment () fmt . Println ( counter . String ()) } output will be: counts: 0, last updated 0001-01-01 00:00:00 +0000 UTC counts: 1, last updated 2009-11-10 23:00:00 +0000 UTC m=+0.000000001 If you use counter you dont have to convert it to a pointer type, because you use the method of the specific type. So therefore counter.Increment() is converted to (&counter).Increment() Be aware if you pass in a copy of a variable and work with the pointer type of it. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 type Counter struct { total int lastUpdated time . Time } func ( c * Counter ) Increment () { c . total ++ c . lastUpdated = time . Now () } func ( c Counter ) String () string { return fmt . Sprintf ( \"counts: %d, last updated %v\" , c . total , c . lastUpdated ) } func update ( counter Counter ) { counter . Increment () } func main () { counter := Counter {} fmt . Println ( counter . String ()) update ( counter ) fmt . Println ( counter . String ()) } will output: counts: 0, last updated 0001-01-01 00:00:00 +0000 UTC counts: 0, last updated 0001-01-01 00:00:00 +0000 UTC","title":"Pointer Receivers"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#nil-and-methods","text":"If a struct poiner gets declared but not initialized it becomes nil. Implementing pointer receivers on structs can produce a problem. But Go handles it quiet easily: If you create a nil struct pointer and call a value receiver, it will panic If you create a nil struct pointer and call a pointer receiver, it will try to execute the function Here are some examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 type Person struct { FirstName string LastName string } func ( p * Person ) ChangeName ( newName string ) * Person { if p == nil { return & Person { LastName : newName , } } p . LastName = newName return p } func ( p Person ) String () string { return fmt . Sprintf ( \"%s %s\" , p . FirstName , p . LastName ) } func main () { var person * Person newPerson := person . ChangeName ( \"Test\" ) fmt . Println ( newPerson . String ()) fmt . Println ( person . String ()) } output: Test panic: runtime error: invalid memory address or nil pointer dereference","title":"Nil and Methods"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#nested-typing-is-not-inheritance","text":"One could believe that if you nest different types, you get a similar behaviour like inheratance. But this is not correct. Inheritance would enable the possibility to use the underlying defined methods for the inherited type, but this is not the case. Every type builds it's own \"environment\" with methods. You can't even assign a child type to a parent type, because in Go those type are two different one and don't belong together. Danger This won't work: 1 2 3 4 5 6 7 8 9 10 11 12 13 type Score int type TeamScore Score func ( s Score ) Good () bool { return s > 10 } func main () { var score Score teamScore := TeamScore ( 10 ) fmt . Println ( \"Team Score is: \" , teamScore . Good ()) score = teamScore } Success This works: 1 2 3 4 5 6 7 8 9 10 11 12 13 type Score int type TeamScore Score func ( s Score ) Good () bool { return s > 10 } func main () { var score Score teamScore := TeamScore ( 10 ) fmt . Println ( \"Team Score is: \" , Score ( teamScore ). Good ()) score = Score ( teamScore ) }","title":"Nested Typing is not Inheritance"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#iotas-are-enums","text":"Go doesn't have the concept of enumerations. But it has iota , which somehow has the same concepts, but different. If you start with iota define an integer type: 1 type PurchasingCategory int then start with a const block and define a some iotas: 1 2 3 4 5 6 7 const ( NoCategory PurchasingCategory = iota Shirts Pants Watches Hats ) If the Go compiler sees iota at the end of a line and succeeding lines of constants it will increment each line by one. The first constant NoCategory receives the value 0 . If you define a new const block with another variable, iota will start again from 0 . Danger This will not work ```go linenums=\"1\" type Test int const ( one Test = 1 two three ) func main() { fmt.Println(one, two, three) } ``` output: ``` 1 1 1 ``` Success This is the correct usage: 1 2 3 4 5 6 7 8 9 10 11 type Test int const ( one Test = iota two three ) func main () { fmt . Println ( one , two , three ) } Use iota only if you are not relying on the value of the constants. Because the values can be changed, if you insert a new constant in the middle of the definition block. Use commond constants with a value assigned if you use it for database entries or outgoing messages. Use iotas only for \"internal\" computation, where you need some kind of named constant where the value doesn't matter.","title":"iotas are Enums"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#embedding-is-composition","text":"There is some kind of inheritance in Go what is called \"Composition\". Let's check an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package main import ( \"fmt\" \"strings\" ) type Employee struct { Name string ID string } func ( e Employee ) Description () string { return fmt . Sprintf ( \"%s: %s\" , e . ID , e . Name ) } type Project struct { Name string } type Projects [] Project func ( ps Projects ) ProjectNames () [] string { var names [] string for _ , project := range ps { names = append ( names , project . Name ) } return names } type SoftwareDeveloper struct { Employee Projects Projects } func ( sd SoftwareDeveloper ) String () string { return fmt . Sprintf ( \"%s\\nProjects: \\n%s\" , sd . Description (), strings . Join ( sd . Projects . ProjectNames (), \"\\n\" , ), ) } func main () { developer := SoftwareDeveloper { Employee : Employee { Name : \"Michael Bykovski\" , ID : \"1\" , }, Projects : Projects { { Name : \"Daimler\" }, { Name : \"Deutsche B\u00f6rse\" }, }, } fmt . Println ( developer ) } It is important to leave the name of the variable of the embedding struct (line 33). If you want to overwrite the embedded function or some field, just do it. They will be still accessable: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 type Inner struct { Y int } func ( i Inner ) String () string { return fmt . Sprintf ( \"%d\" , i . Y ) } type Outer struct { Inner Y int } func ( o Outer ) String () string { return fmt . Sprintf ( \"%d\" , o . Y ) } func main () { outer := Outer { Inner : Inner { Y : 5 , }, Y : 10 , } fmt . Println ( outer . String (), outer . Inner . String ()) } output: 10 5","title":"Embedding is Composition"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#embedding-is-not-inheritance","text":"Do not treat embedding as inheritance. You cannot assign an inherited member to the parent type 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type Inner struct { Y int } type Outer struct { Inner Y int } func main () { var inner Inner outer := Outer { Inner : Inner { Y : 1 , }, Y : 2 , } inner = outer } output would be: cannot use outer (variable of type Outer) as type Inner in assignment this would fix it: 1 2 3 4 5 6 7 8 9 10 func main () { var inner Inner outer := Outer { Inner : Inner { Y : 1 , }, Y : 2 , } inner = outer . Inner } Go does not dynamically dispatch the Methods 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 type Inner struct { Y int } func ( i Inner ) IntPrinter ( value int ) string { return fmt . Sprintf ( \"Inner: %d\" , value ) } func ( i Inner ) Double () string { return i . IntPrinter ( i . Y * 2 ) } type Outer struct { Inner Y int } func ( o Outer ) IntPrinter ( value int ) string { return fmt . Sprintf ( \"Outer: %d\" , value ) } func main () { outer := Outer { Inner : Inner { Y : 2 , }, Y : 4 , } fmt . Println ( outer . Double ()) } If you have a struct, which embeds another struct and you can an embedded function, it will resolve other functions of the struct in the \"embedded scope\".","title":"Embedding is not Inheritance"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#interfaces","text":"The only abstract type in Go are interfaces . So let's check them out: 1 2 3 type Stringer interface { String () string } Usually Interfaces end with \"er\", there are several Go built-in interfaces like io.Reader , io.Closer , io.ReadCloser , json.Marshaler .","title":"Interfaces"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#implicit-interfaces","text":"Go Interfaces work in a different way compared to other programming languages. Types implement interfaces by implementing their function signatures. Let's check it out: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 type ConsoleWriter struct { Prefix string } func ( cw ConsoleWriter ) Write ( data string ) { fmt . Println ( cw . Prefix , \":\" , data ) } type Writer interface { Write ( data string ) } type Application struct { W Writer } func ( a Application ) Run () { a . W . Write ( \"Hello World\" ) } func main () { application := Application { W : ConsoleWriter { Prefix : \"ConsoleWriter\" , }, } application . Run () } Application wants a type that fulfills the Writer interface. Since ConsoleWriter implements the defined function signatures of the Writer interface, it implements automatically the Writer interface. Interfaces are a type and therefore they can be shared like functions, variables and structs. Let's check this example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 type ConsoleWriter struct { Prefix string } func ( cw ConsoleWriter ) Write ( data string ) { fmt . Println ( cw . Prefix , \":\" , data ) } type Writer interface { Write ( data string ) } type Application struct { W Writer } func NewApplication ( w Writer ) Application { return Application { W : w , } } func ( a Application ) Run () { a . W . Write ( \"Hello World\" ) } func main () { consoleWriter := ConsoleWriter { Prefix : \"ConsoleWriter\" , } application := NewApplication ( consoleWriter ) application . Run () } You can also append new methods to structs which implement interfaces. As long as the signature fulfills the interface, it implements the interface, all other methods belong to the struct. Multiple interface implementations are also possible: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 type ConsoleWriter struct { Prefix string Cache string } func ( cw ConsoleWriter ) Write ( data string ) { fmt . Printf ( \"%s: %s (cached: %s)\" , cw . Prefix , data , cw . Cache ) cw . Cache = \"\" } func ( cw * ConsoleWriter ) Read ( data string ) { cw . Cache = data } func ( cw * ConsoleWriter ) PurgeCache () { cw . Cache = \"\" } type Writer interface { Write ( data string ) } type Reader interface { Read ( data string ) } type Application struct { W Writer R Reader } func NewApplication ( w Writer , r Reader ) Application { return Application { W : w , R : r , } } func ( a Application ) Run () { a . R . Read ( \"Hello World\" ) a . W . Write ( \"Hello Go\" ) } func main () { consoleWriter := ConsoleWriter { Prefix : \"ConsoleWriter\" , } application := NewApplication ( & consoleWriter , & consoleWriter ) application . Run () consoleWriter . PurgeCache () }","title":"Implicit Interfaces"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#embedding-interfaces","text":"The same way you can embed structs, you can embed interfaces too. Here is an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 type ConsoleWriter struct { Prefix string Cache string } func ( cw ConsoleWriter ) Write ( data string ) { fmt . Printf ( \"%s: %s (cached: %s)\" , cw . Prefix , data , cw . Cache ) cw . Cache = \"\" } func ( cw * ConsoleWriter ) Read ( data string ) { cw . Cache = data } func ( cw * ConsoleWriter ) PurgeCache () { cw . Cache = \"\" } type Writer interface { Write ( data string ) } type Reader interface { Read ( data string ) } type ReaderWriter interface { Reader Writer } type Application struct { RW ReaderWriter } func NewApplication ( readerWriter ReaderWriter ) Application { return Application { RW : readerWriter , } } func ( a Application ) Run () { a . RW . Read ( \"Hello World\" ) a . RW . Write ( \"Hello Go\" ) } func main () { consoleWriter := ConsoleWriter { Prefix : \"ConsoleWriter\" , } application := NewApplication ( & consoleWriter ) application . Run () consoleWriter . PurgeCache () }","title":"Embedding Interfaces"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#accept-interfaces-return-concrete-types","text":"As we want to decouple our code but make it easy to adapt we should build functions that accept interfaces and return concrete types. Because interfaces define a specific functionality our code should accept functionality, run it and return a concrete behaviour or value. Let's take for example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type UserData struct { // ... } type Authentication struct { // ... } func ( a Authentication ) Auth () ( UserData , error ) { // ... return UserData {}, nil } func DoAuthentication ( a Authentication ) ( UserData , error ) { // ... return a . Auth () } If we want now to support multiple Auth methods for example, we can open the DoAuthentication for an interface, which defines the Method Auth but we should still a concrete struct, for further implementations: userdata.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 type AppleUserData struct { // ... } type GoogleUserData struct { // ... } type UserData struct { AppleUserData * AppleUserData GoogleUserData * GoogleUserData } func ( ud UserData ) IsApple () { // ... } func ( ud UserData ) IsGoogle () { // ... } type Authenticator interface { Auth () ( UserData , error ) } type GoogleAuthentication struct { // ... } func ( ga GoogleAuthentication ) Auth () ( UserData , error ) { // ... return UserData { GoogleUserData : & GoogleUserData { // ... }, }, nil } type AppleAuthentication struct { // ... } func ( aa AppleAuthentication ) Auth () ( UserData , error ) { return UserData { AppleUserData : & AppleUserData { // ... }, }, nil } func DoAuthentication ( a Authenticator ) ( UserData , error ) { return a . Auth () } Danger Do NOT do this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 type UserData struct { // ... } type UserDataGetter interface { UserData () UserData } type AppleUserData struct { // ... } func ( aud AppleUserData ) UserData () { } type GoogleUserData struct { // ... } // ... func DoAuthentication ( a Authenticator ) UserDataGetter { return a . Auth () } If you want to read more about \"accept interfaces, return concrete types\" follow this and this The rule is: Unnecessary abstraction creates unnecessary complication. Don\u2019t over complicate code until it\u2019s needed.","title":"Accept Interfaces, Return Concrete Types"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#interfaces-and-nil","text":"Interfaces are nil as long as they: don't have a type don't have a value This example should make it clear: 1 2 3 4 5 6 7 8 var s * string fmt . Println ( s == nil ) // true var i interface {} fmt . Println ( i == nil ) // true i = s fmt . Println ( i == nil ) // false This tells us, that if an interface has a struct which is nil, it can still run methods of the nil-struct: 1 2 3 4 5 6 7 8 9 10 11 12 13 type Dog struct {} func ( d * Dog ) BarkGhost () { fmt . Println ( \"Woof!\" ) } func main () { var ghostDog interface {} var dog * Dog ghostDog = dog ghostDog .( * Dog ). BarkGhost () }","title":"Interfaces and nil"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#empty-interface-all-the-way","text":"Sometimes you need to define a variable, where you will not know which type it is going to have. Take interface for that: 1 2 3 4 5 6 7 8 9 var i interface {} i = 10 fmt . Println ( i ) i = \"Hello\" fmt . Println ( i ) i = func ( word string ) string { return word } fmt . Println ( i ) output: 10 Hello 0x47dcc0 Mostly you won't need an empty interface. Sometimes you will need it to store some really unknown data structure, which comes from an unknown json schema: 1 2 3 4 5 6 7 8 9 10 func main () { data := map [ string ] interface {}{} contents , err := ioutil . ReadFile ( \"data.json\" ) if err != nil { return err } defer contents . Close () json . Unmarshal ( contents , & data ) }","title":"Empty Interface All The Way"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#type-assertions-and-type-switches","text":"","title":"Type Assertions and Type Switches"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#type-assertions","text":"Let's make first a type assertions, so we assert a specific type to an interface variable: 1 2 3 4 5 6 7 8 9 type Score int func main () { var i interface {} var score Score = 20 i = score i2 := i .( Score ) fmt . Println ( i2 + score ) } If you try to assert a type, which could not work, Go will panic: 1 2 3 4 5 6 7 8 9 type Score int func main () { var i interface {} var score Score = 20 i = score i2 := i .( string ) fmt . Println ( i2 ) } output: interface conversion: interface {} is main.Score, not string The type has to match the exact underlying type, not embedded or type inferenced . 1 2 3 4 5 6 7 8 9 type Score int func main () { var i interface {} var score Score = 20 i = score i2 := i .( int ) fmt . Println ( i2 + score ) } output: interface conversion: interface {} is main.Score, not int If you want to test in your code and don't want to panic, use the variable, ok := idiom 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type Score int func main () { var i interface {} var score Score = 1 i = score i2 , ok := i .( int ) if ! ok { fmt . Printf ( \"i is not an int: %v\" , i ) return } fmt . Println ( i2 + 1 ) }","title":"Type Assertions"},{"location":"golang/golang-fundamentals/types_interfaces_methods/#type-switches","text":"If your interface variable can have multiple types, use a type switch: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func checkType ( i interface {}) { switch j := i .( type ) { case nil : fmt . Println ( \"i is nil\" ) return case int : fmt . Println ( \"i is an int\" ) return case string fmt . Println ( \"i is a string\" ) return default : fmt . Println ( \"the type is not defined as case\" ) return } }","title":"Type Switches"},{"location":"golang/grpc/","text":"gRPC and Protobuf","title":"gRPC and Protobuf"},{"location":"golang/grpc/#grpc-and-protobuf","text":"","title":"gRPC and Protobuf"},{"location":"javascript/","text":"Introduction Welcome to my lectures which I collected, wrote, reevaluated and worked on in several years. On the left side you will find several topics of my lectures.","title":"Introduction"},{"location":"javascript/#introduction","text":"Welcome to my lectures which I collected, wrote, reevaluated and worked on in several years. On the left side you will find several topics of my lectures.","title":"Introduction"},{"location":"javascript/browser-api/","text":"Introduction Welcome to my lecture Browser API!","title":"Introduction"},{"location":"javascript/browser-api/#introduction","text":"Welcome to my lecture Browser API!","title":"Introduction"},{"location":"javascript/browser-api/browser-vs-node/","text":"Browser vs. Node The difference between node and browser environment The red blocks are displaying the different environments, where the JavaScript engine (V8, the blue block) can be embedded. On the left side in the image there is the browser environment, which provides a Browser API . On the right side in the image ther is the node (system) environment, which provides a Node API . So V8 is the interpreter that understands all JavaScript Code and just executes it, beside that we also need ways to access the browser or system. Accessing the browser's DOM (document object model) or a specific directory in the system's file-system is not given by \"just\" running V8. Therefore the environments (browser, node) attach specific APIs to your JavaScript environment. Browser API The Browser API is able to deliver functionality to run specific tasks in the browser, like showing an alert box, fetching and modifying a DOM-element or sending a HTTP-request. The most important Browser API object is: window All properties and methods of the Window object are exposed to the global environment. const element = window . document . getElementById ( \"main\" ); // is the same as const element2 = document . getElementById ( \"main\" ); There are also more APIs: Web APIs Node API The Node API is able to deliver functionality to run specific tasks on the system, like reading a file in a directory, get system information, creating a TCP-socket. There is no \"global object\", which holds all important functionality. There are a lot of different objects like crypto , child_process or timers .","title":"Browser vs. Node"},{"location":"javascript/browser-api/browser-vs-node/#browser-vs-node","text":"The difference between node and browser environment The red blocks are displaying the different environments, where the JavaScript engine (V8, the blue block) can be embedded. On the left side in the image there is the browser environment, which provides a Browser API . On the right side in the image ther is the node (system) environment, which provides a Node API . So V8 is the interpreter that understands all JavaScript Code and just executes it, beside that we also need ways to access the browser or system. Accessing the browser's DOM (document object model) or a specific directory in the system's file-system is not given by \"just\" running V8. Therefore the environments (browser, node) attach specific APIs to your JavaScript environment.","title":"Browser vs. Node"},{"location":"javascript/browser-api/browser-vs-node/#browser-api","text":"The Browser API is able to deliver functionality to run specific tasks in the browser, like showing an alert box, fetching and modifying a DOM-element or sending a HTTP-request. The most important Browser API object is: window All properties and methods of the Window object are exposed to the global environment. const element = window . document . getElementById ( \"main\" ); // is the same as const element2 = document . getElementById ( \"main\" ); There are also more APIs: Web APIs","title":"Browser API"},{"location":"javascript/browser-api/browser-vs-node/#node-api","text":"The Node API is able to deliver functionality to run specific tasks on the system, like reading a file in a directory, get system information, creating a TCP-socket. There is no \"global object\", which holds all important functionality. There are a lot of different objects like crypto , child_process or timers .","title":"Node API"},{"location":"javascript/browser-api/dom/","text":"DOM (Document Object Model) The Javascript DOM (Document Object Model) is an interface that allows developers to manipulate the content, structure and style of a website. Document Object Model The DOM document is the owner of all other objects in your webpage. That means if you want to access any object on your webpage you always have to start with the document. It also contains many important properties and methods that enable us to access and modify our website. The document is attached to the window object. Therefore you could use both: window . document ; // or document ; <document> Finding elements To find an element there are functions starting with getElementBy... : index.html : < p id = \"title\" > This is my title </ p > < p class = \"text\" > A text </ p > < p class = \"text\" > Another text </ p > index.js : const title = document . getElementById ( \"title\" ); const texts = document . getElementsByClassName ( \"text\" ); const pElements = document . getElementsByTagName ( \"p\" ); Queryselector With a queryselector it's possible to retrieve the elements via CSS-selectors index.html : < p id = \"title\" > This is my title </ p > < p class = \"text\" > A text </ p > < p class = \"text\" > Another text </ p > index.js : const title = document . querySelector ( \"#title\" ); const texts = document . querySelectorAll ( \".text\" ); const pElements = document . querySelectorAll ( \"p\" );","title":"DOM (Document Object Model)"},{"location":"javascript/browser-api/dom/#dom-document-object-model","text":"The Javascript DOM (Document Object Model) is an interface that allows developers to manipulate the content, structure and style of a website. Document Object Model The DOM document is the owner of all other objects in your webpage. That means if you want to access any object on your webpage you always have to start with the document. It also contains many important properties and methods that enable us to access and modify our website. The document is attached to the window object. Therefore you could use both: window . document ; // or document ;","title":"DOM (Document Object Model)"},{"location":"javascript/browser-api/dom/#document","text":"","title":"&lt;document&gt;"},{"location":"javascript/browser-api/dom/#finding-elements","text":"To find an element there are functions starting with getElementBy... : index.html : < p id = \"title\" > This is my title </ p > < p class = \"text\" > A text </ p > < p class = \"text\" > Another text </ p > index.js : const title = document . getElementById ( \"title\" ); const texts = document . getElementsByClassName ( \"text\" ); const pElements = document . getElementsByTagName ( \"p\" );","title":"Finding elements"},{"location":"javascript/browser-api/dom/#queryselector","text":"With a queryselector it's possible to retrieve the elements via CSS-selectors index.html : < p id = \"title\" > This is my title </ p > < p class = \"text\" > A text </ p > < p class = \"text\" > Another text </ p > index.js : const title = document . querySelector ( \"#title\" ); const texts = document . querySelectorAll ( \".text\" ); const pElements = document . querySelectorAll ( \"p\" );","title":"Queryselector"},{"location":"javascript/browser-api/element/","text":"Element When retrieving an element from the document you will get an object which is an instance of HTMLElement . HTMLElement HTMLElement inherits from Element . Element inherits from Node . Node inherits from EventTarget . Which means that you are able to use all the functionality and properties provided by HTMLElement , Element , Node and EventTarget . Manipulation HTMLElements are directly bound to the DOM, which means that if you manipulate the HTMLElement this will reflect instantly in the DOM. Instant bind of HTMLElement to the DOM Code: const element = document . getElementById ( \"title\" ); element . innerText = \"123\" ; Note that you cannot manipulate Read only fields like: offsetLeft , dataset and many more... Creation Surely there is the possibility to create a HTMLElement. Creating an element means to create it in the document first and then append it to an element you like. const divElement = document . createElement ( \"div\" ); After creation you can append it to an element: const h1Element = document . createElement ( \"h1\" ); h1Element . innerText = \"Hello World!\" ; document . body . append ( h1Element ); Events Because deep in the inheritance, the HTMLElement inherits from an EventTarget, you can use addEventListener to attach an event listener to an element. For example: const element = document . getElementById ( \"title\" ); element . addEventListener ( \"click\" , ( event ) => { console . log ( ` ${ event } was clicked!` ); }); Here are all events: Link","title":"Element"},{"location":"javascript/browser-api/element/#element","text":"When retrieving an element from the document you will get an object which is an instance of HTMLElement . HTMLElement HTMLElement inherits from Element . Element inherits from Node . Node inherits from EventTarget . Which means that you are able to use all the functionality and properties provided by HTMLElement , Element , Node and EventTarget .","title":"Element"},{"location":"javascript/browser-api/element/#manipulation","text":"HTMLElements are directly bound to the DOM, which means that if you manipulate the HTMLElement this will reflect instantly in the DOM. Instant bind of HTMLElement to the DOM Code: const element = document . getElementById ( \"title\" ); element . innerText = \"123\" ; Note that you cannot manipulate Read only fields like: offsetLeft , dataset and many more...","title":"Manipulation"},{"location":"javascript/browser-api/element/#creation","text":"Surely there is the possibility to create a HTMLElement. Creating an element means to create it in the document first and then append it to an element you like. const divElement = document . createElement ( \"div\" ); After creation you can append it to an element: const h1Element = document . createElement ( \"h1\" ); h1Element . innerText = \"Hello World!\" ; document . body . append ( h1Element );","title":"Creation"},{"location":"javascript/browser-api/element/#events","text":"Because deep in the inheritance, the HTMLElement inherits from an EventTarget, you can use addEventListener to attach an event listener to an element. For example: const element = document . getElementById ( \"title\" ); element . addEventListener ( \"click\" , ( event ) => { console . log ( ` ${ event } was clicked!` ); }); Here are all events: Link","title":"Events"},{"location":"javascript/browser-api/fetch/","text":"Fetch Fetch is a new approach to send HTTP requests to servers. Fetch uses a promise-based approach. fetch ( \"http://echo.jsontest.com/key/value/one/two\" ) . then (( response ) => { return response . json (); }) . then (( json ) => { console . log ( json ); }); Surely you can use the promise-based approach with async/await : const receiveOneTwo = async () => { try { const response = await fetch ( \"http://echo.jsontest.com/key/value/one/two\" ); const json = await response . json (); console . log ( json ); } catch ( error ) { console . error ( error ); } }; receiveOneTwo (). catch ( console . error );","title":"Fetch"},{"location":"javascript/browser-api/fetch/#fetch","text":"Fetch is a new approach to send HTTP requests to servers. Fetch uses a promise-based approach. fetch ( \"http://echo.jsontest.com/key/value/one/two\" ) . then (( response ) => { return response . json (); }) . then (( json ) => { console . log ( json ); }); Surely you can use the promise-based approach with async/await : const receiveOneTwo = async () => { try { const response = await fetch ( \"http://echo.jsontest.com/key/value/one/two\" ); const json = await response . json (); console . log ( json ); } catch ( error ) { console . error ( error ); } }; receiveOneTwo (). catch ( console . error );","title":"Fetch"},{"location":"javascript/browser-api/html/","text":"HTML This is a default HTML document. <!DOCTYPE html> < html lang = \"en\" > < head > < title > Sample page </ title > < script type = \"text/javascript\" src = \"./index.js\" > < /head> < body > < h1 > Sample page </ h1 > < p > This is a < a href = \"demo.html\" > simple </ a > sample. </ p > <!-- this is a comment --> </ body > </ html > The <!DOCTYPE html> is actually not a HTML-element but it describes the document as a HTML-document for the browser. Then it starts with the most outer element <html>...</html> . It holds the <head></head> and <body></body> elements together. <head> Within the <head> element we define properties of the document \"which we don't see\" (except the title). We also define here links to other documents like JavaScript and CSS files. <body> Within the <body> element we define elements of the documents \"which we will see\".","title":"HTML"},{"location":"javascript/browser-api/html/#html","text":"This is a default HTML document. <!DOCTYPE html> < html lang = \"en\" > < head > < title > Sample page </ title > < script type = \"text/javascript\" src = \"./index.js\" > < /head> < body > < h1 > Sample page </ h1 > < p > This is a < a href = \"demo.html\" > simple </ a > sample. </ p > <!-- this is a comment --> </ body > </ html > The <!DOCTYPE html> is actually not a HTML-element but it describes the document as a HTML-document for the browser. Then it starts with the most outer element <html>...</html> . It holds the <head></head> and <body></body> elements together.","title":"HTML"},{"location":"javascript/browser-api/html/#head","text":"Within the <head> element we define properties of the document \"which we don't see\" (except the title). We also define here links to other documents like JavaScript and CSS files.","title":"&lt;head&gt;"},{"location":"javascript/browser-api/html/#body","text":"Within the <body> element we define elements of the documents \"which we will see\".","title":"&lt;body&gt;"},{"location":"javascript/browser-api/web-apis/","text":"Web APIs Web APIs allow to communicate with the Browser via JavaScript and to trigger different functions. Web APIs are exposed as global functions or objects into the current JavaScript environment. window For example there is a window object exposed, which contains all the information about the current window (the current tab): window . console . log ( window . innerHeight ); window . console . log ( window . innerWidth ); All attributes and methods of the window object, are exposed to your JavaScript environment automatically. So you could use: window . console . log ( \"Test\" ); // or simply console . log ( \"Test\" );","title":"Web APIs"},{"location":"javascript/browser-api/web-apis/#web-apis","text":"Web APIs allow to communicate with the Browser via JavaScript and to trigger different functions. Web APIs are exposed as global functions or objects into the current JavaScript environment.","title":"Web APIs"},{"location":"javascript/browser-api/web-apis/#window","text":"For example there is a window object exposed, which contains all the information about the current window (the current tab): window . console . log ( window . innerHeight ); window . console . log ( window . innerWidth ); All attributes and methods of the window object, are exposed to your JavaScript environment automatically. So you could use: window . console . log ( \"Test\" ); // or simply console . log ( \"Test\" );","title":"window"},{"location":"javascript/browser-api/xmlhttprequest/","text":"XMLHttpRequest \" XMLHttpRequest (XHR) objects are used to interact with servers. You can retrieve data from a URL without having to do a full page refresh. This enables a Web page to update just part of a page without disrupting what the user is doing. XMLHttpRequest is used heavily in AJAX (Asynchronous JavaScript and XML) programming.\" const request = new XMLHttpRequest (); request . onload = ( event ) => { const json = request . response ; console . log ( json ); }; request . open ( \"GET\" , \"http://echo.jsontest.com/key/value/one/two\" ); request . responseType = \"json\" ; request . send (); XMLHttpRequest uses an event-based approach. When the request is sent with request.send() the browser will send the prepared request and call the onload function of the request after the response was received. Consider that after using the request.send() method the thread won't block! Non blocking request.send","title":"XMLHttpRequest"},{"location":"javascript/browser-api/xmlhttprequest/#xmlhttprequest","text":"\" XMLHttpRequest (XHR) objects are used to interact with servers. You can retrieve data from a URL without having to do a full page refresh. This enables a Web page to update just part of a page without disrupting what the user is doing. XMLHttpRequest is used heavily in AJAX (Asynchronous JavaScript and XML) programming.\" const request = new XMLHttpRequest (); request . onload = ( event ) => { const json = request . response ; console . log ( json ); }; request . open ( \"GET\" , \"http://echo.jsontest.com/key/value/one/two\" ); request . responseType = \"json\" ; request . send (); XMLHttpRequest uses an event-based approach. When the request is sent with request.send() the browser will send the prepared request and call the onload function of the request after the response was received. Consider that after using the request.send() method the thread won't block! Non blocking request.send","title":"XMLHttpRequest"},{"location":"javascript/byot/","text":"Introduction Build Your Own Tool follows the idea, that you build a small tool with the least effort possible. To achieve this solution there is currently a best practice way to do so. Strapi is an open source headless CMS which is build with JavaScript. Next.JS is a React Framework. You can find the whole example as repository on Github","title":"Introduction"},{"location":"javascript/byot/#introduction","text":"Build Your Own Tool follows the idea, that you build a small tool with the least effort possible. To achieve this solution there is currently a best practice way to do so. Strapi is an open source headless CMS which is build with JavaScript. Next.JS is a React Framework. You can find the whole example as repository on Github","title":"Introduction"},{"location":"javascript/byot/add-theme/","text":"Add Theme We add a theme to our application first with: yarn add 98 .css and then in the file dashboard/pages/_app.js : import \"../styles/globals.css\" ; import \"98.css\" ; function MyApp ({ Component , pageProps }) { return < Component {... pageProps } /> ; } export default MyApp ;","title":"Add Theme"},{"location":"javascript/byot/add-theme/#add-theme","text":"We add a theme to our application first with: yarn add 98 .css and then in the file dashboard/pages/_app.js : import \"../styles/globals.css\" ; import \"98.css\" ; function MyApp ({ Component , pageProps }) { return < Component {... pageProps } /> ; } export default MyApp ;","title":"Add Theme"},{"location":"javascript/byot/api/","text":"API Find Now after we setup the Content-Type and the Roles & Permissions we are able to access the api: http://localhost:1337/events We will get a response like this: [ { id : 1 , na me : \"TechTalk #46 - BYOT - Build Your Own Tool mit Strapi und Next.js!\" , descrip t io n : \" \" Sch nell mal ei n Tool baue n \" ist f\u00fcr viele eine gro\u00dfe Herausforderung. Es muss ein Backend mit Datenbankzugriff, REST-Schnittstellen, Benutzerverwaltung und vielen mehr entwickelt werden. Hinzu kommt, dass eine Oberfl\u00e4che f\u00fcr das Eintragen und Anzeigen der Daten implementiert werden muss. Des Weiteren bleibt es meistens nicht bei der Verwaltung und Anzeige der Daten, denn es wird noch dazu ein Gesch\u00e4ftsprozess programmiert. Mit Strapi und Next.JS zeige ich anhand eines Live-Coding-Beispiels, wie ein Event-Verwaltungstool f\u00fcr interne Events eines Unternehmens in unter einer Stunde entwickelt werden kann.\" , s tart : \"2020-10-02T15:00:00.000Z\" , e n d : \"2020-10-02T18:00:00.000Z\" , crea te d_by : { id : 1 , f irs tna me : \"Test\" , las tna me : \"test\" , user na me : null }, upda te d_by : { id : 1 , f irs tna me : \"Test\" , las tna me : \"test\" , user na me : null }, crea te d_a t : \"2020-09-21T07:20:05.564Z\" , upda te d_a t : \"2020-09-21T07:20:05.573Z\" } ] Find One And we can directly access the event with the id: http://localhost:1337/events/1 Response: { id : 1 , na me : \"TechTalk #46 - BYOT - Build Your Own Tool mit Strapi und Next.js!\" , descrip t io n : \" \" Sch nell mal ei n Tool baue n \" ist f\u00fcr viele eine gro\u00dfe Herausforderung. Es muss ein Backend mit Datenbankzugriff, REST-Schnittstellen, Benutzerverwaltung und vielen mehr entwickelt werden. Hinzu kommt, dass eine Oberfl\u00e4che f\u00fcr das Eintragen und Anzeigen der Daten implementiert werden muss. Des Weiteren bleibt es meistens nicht bei der Verwaltung und Anzeige der Daten, denn es wird noch dazu ein Gesch\u00e4ftsprozess programmiert. Mit Strapi und Next.JS zeige ich anhand eines Live-Coding-Beispiels, wie ein Event-Verwaltungstool f\u00fcr interne Events eines Unternehmens in unter einer Stunde entwickelt werden kann.\" , s tart : \"2020-10-02T15:00:00.000Z\" , e n d : \"2020-10-02T18:00:00.000Z\" , crea te d_by : { id : 1 , f irs tna me : \"Test\" , las tna me : \"test\" , user na me : null }, upda te d_by : { id : 1 , f irs tna me : \"Test\" , las tna me : \"test\" , user na me : null }, crea te d_a t : \"2020-09-21T07:20:05.564Z\" , upda te d_a t : \"2020-09-21T07:20:05.573Z\" }","title":"API"},{"location":"javascript/byot/api/#api","text":"","title":"API"},{"location":"javascript/byot/api/#find","text":"Now after we setup the Content-Type and the Roles & Permissions we are able to access the api: http://localhost:1337/events We will get a response like this: [ { id : 1 , na me : \"TechTalk #46 - BYOT - Build Your Own Tool mit Strapi und Next.js!\" , descrip t io n : \" \" Sch nell mal ei n Tool baue n \" ist f\u00fcr viele eine gro\u00dfe Herausforderung. Es muss ein Backend mit Datenbankzugriff, REST-Schnittstellen, Benutzerverwaltung und vielen mehr entwickelt werden. Hinzu kommt, dass eine Oberfl\u00e4che f\u00fcr das Eintragen und Anzeigen der Daten implementiert werden muss. Des Weiteren bleibt es meistens nicht bei der Verwaltung und Anzeige der Daten, denn es wird noch dazu ein Gesch\u00e4ftsprozess programmiert. Mit Strapi und Next.JS zeige ich anhand eines Live-Coding-Beispiels, wie ein Event-Verwaltungstool f\u00fcr interne Events eines Unternehmens in unter einer Stunde entwickelt werden kann.\" , s tart : \"2020-10-02T15:00:00.000Z\" , e n d : \"2020-10-02T18:00:00.000Z\" , crea te d_by : { id : 1 , f irs tna me : \"Test\" , las tna me : \"test\" , user na me : null }, upda te d_by : { id : 1 , f irs tna me : \"Test\" , las tna me : \"test\" , user na me : null }, crea te d_a t : \"2020-09-21T07:20:05.564Z\" , upda te d_a t : \"2020-09-21T07:20:05.573Z\" } ]","title":"Find"},{"location":"javascript/byot/api/#find-one","text":"And we can directly access the event with the id: http://localhost:1337/events/1 Response: { id : 1 , na me : \"TechTalk #46 - BYOT - Build Your Own Tool mit Strapi und Next.js!\" , descrip t io n : \" \" Sch nell mal ei n Tool baue n \" ist f\u00fcr viele eine gro\u00dfe Herausforderung. Es muss ein Backend mit Datenbankzugriff, REST-Schnittstellen, Benutzerverwaltung und vielen mehr entwickelt werden. Hinzu kommt, dass eine Oberfl\u00e4che f\u00fcr das Eintragen und Anzeigen der Daten implementiert werden muss. Des Weiteren bleibt es meistens nicht bei der Verwaltung und Anzeige der Daten, denn es wird noch dazu ein Gesch\u00e4ftsprozess programmiert. Mit Strapi und Next.JS zeige ich anhand eines Live-Coding-Beispiels, wie ein Event-Verwaltungstool f\u00fcr interne Events eines Unternehmens in unter einer Stunde entwickelt werden kann.\" , s tart : \"2020-10-02T15:00:00.000Z\" , e n d : \"2020-10-02T18:00:00.000Z\" , crea te d_by : { id : 1 , f irs tna me : \"Test\" , las tna me : \"test\" , user na me : null }, upda te d_by : { id : 1 , f irs tna me : \"Test\" , las tna me : \"test\" , user na me : null }, crea te d_a t : \"2020-09-21T07:20:05.564Z\" , upda te d_a t : \"2020-09-21T07:20:05.573Z\" }","title":"Find One"},{"location":"javascript/byot/client/","text":"Client To communicate with the server, we need to implement a client in the dashboard. And to work easier with HTTP requests and responses, we install Axios: yarn add axios Now we implement the client: dashboard/client/index.js import Axios from \"axios\" ; export const API_URL = \"http://localhost:1337\" ; export const getEvents = async () => { return Axios . get ( ` ${ API_URL } /events` ); };","title":"Client"},{"location":"javascript/byot/client/#client","text":"To communicate with the server, we need to implement a client in the dashboard. And to work easier with HTTP requests and responses, we install Axios: yarn add axios Now we implement the client: dashboard/client/index.js import Axios from \"axios\" ; export const API_URL = \"http://localhost:1337\" ; export const getEvents = async () => { return Axios . get ( ` ${ API_URL } /events` ); };","title":"Client"},{"location":"javascript/byot/content-type/","text":"Content-Type Let's create our first content type. Imagine we want to build a small tool, which helps a company to store their upcoming and past events. First we need to create a \"content type\". You can compare it to a model or database table, which stores your information. Strapi creates and alters your table in the database automatically, so we just have to setup the content type through the UI. Click on the left side on Content-Types Builder and then on Create new collection type : Then we enter the name of the new content type Event for example: We click on Continue and add a new Textfield to the model: After that we enter \"name\" as name for the field and check the Advanded Settings , where we check required field . Now we do that for description (optional Textfield), start (required DateTimefield), end (required DateTimefield). After we created the fields we should see this model. We press Save to let Strapi create the tables in the database. On the left side under Collection Types should appear Events . We click on Events and then on Add New Event : Enter data for a new event and click on Save :","title":"Content-Type"},{"location":"javascript/byot/content-type/#content-type","text":"Let's create our first content type. Imagine we want to build a small tool, which helps a company to store their upcoming and past events. First we need to create a \"content type\". You can compare it to a model or database table, which stores your information. Strapi creates and alters your table in the database automatically, so we just have to setup the content type through the UI. Click on the left side on Content-Types Builder and then on Create new collection type : Then we enter the name of the new content type Event for example: We click on Continue and add a new Textfield to the model: After that we enter \"name\" as name for the field and check the Advanded Settings , where we check required field . Now we do that for description (optional Textfield), start (required DateTimefield), end (required DateTimefield). After we created the fields we should see this model. We press Save to let Strapi create the tables in the database. On the left side under Collection Types should appear Events . We click on Events and then on Add New Event : Enter data for a new event and click on Save :","title":"Content-Type"},{"location":"javascript/byot/implement-the-frontend/","text":"Implement the frontend Event Component First let's create a component to show our events later: dashboard/components/Event.js export const Event = ({ title , description , start , end }) => { const startDateTime = new Date ( start ); const endDateTime = new Date ( end ); return ( < div className = \"window\" style = {{ width : 300 , marginBottom : \"1em\" }} > < div className = \"title-bar\" > < div className = \"title-bar-text\" > { title } < /div> < /div> < div className = \"window-body\" > < p > { description } < /p> < hr /> < p > { startDateTime . toLocaleString ()} - { endDateTime . toLocaleString ()} < /p> < /div> < /div> ); }; export default Event ; Add react-query To fetch data properly from the backend server, we will use the library react-query . It is able to fetch, cache, synchronize and update server state. We install it using: yarn add react-query Events Container Create a container to fetch the data from the server and display it by using our created Event component, our implemented client , and the react-query library. dashboard/containers/Events.js import { useQuery } from \"react-query\" ; import { getEvents } from \"../client\" ; import { Event } from \"../components/Event\" ; export const Events = () => { const { isLoading , isError , data : events , error } = useQuery ( \"events\" , getEvents ); if ( isLoading ) { return < div > Loading ... < /div>; } if ( isError ) { return < div > Error fetching events : { error . toString ()} < /div>; } return events . map (( event ) => < Event key = { event . id } {... event } /> ); }; export default Events ; Glueing it all together Now we are finished and just have to call the Event container in the index.js file. dashboard/pages/index.js import Head from \"next/head\" ; import Events from \"../containers/Events\" ; const mainStyle = { padding : 30 , display : \"flex\" , alignItems : \"center\" , justifyContent : \"space-evenly\" , flexWrap : \"wrap\" , }; export default function Home () { return ( < div > < Head > < title > Events Dashboard < /title> < /Head> < main style = { mainStyle } > < Events /> < /main> < /div> ); } Result","title":"Implement the frontend"},{"location":"javascript/byot/implement-the-frontend/#implement-the-frontend","text":"","title":"Implement the frontend"},{"location":"javascript/byot/implement-the-frontend/#event-component","text":"First let's create a component to show our events later: dashboard/components/Event.js export const Event = ({ title , description , start , end }) => { const startDateTime = new Date ( start ); const endDateTime = new Date ( end ); return ( < div className = \"window\" style = {{ width : 300 , marginBottom : \"1em\" }} > < div className = \"title-bar\" > < div className = \"title-bar-text\" > { title } < /div> < /div> < div className = \"window-body\" > < p > { description } < /p> < hr /> < p > { startDateTime . toLocaleString ()} - { endDateTime . toLocaleString ()} < /p> < /div> < /div> ); }; export default Event ;","title":"Event Component"},{"location":"javascript/byot/implement-the-frontend/#add-react-query","text":"To fetch data properly from the backend server, we will use the library react-query . It is able to fetch, cache, synchronize and update server state. We install it using: yarn add react-query","title":"Add react-query"},{"location":"javascript/byot/implement-the-frontend/#events-container","text":"Create a container to fetch the data from the server and display it by using our created Event component, our implemented client , and the react-query library. dashboard/containers/Events.js import { useQuery } from \"react-query\" ; import { getEvents } from \"../client\" ; import { Event } from \"../components/Event\" ; export const Events = () => { const { isLoading , isError , data : events , error } = useQuery ( \"events\" , getEvents ); if ( isLoading ) { return < div > Loading ... < /div>; } if ( isError ) { return < div > Error fetching events : { error . toString ()} < /div>; } return events . map (( event ) => < Event key = { event . id } {... event } /> ); }; export default Events ;","title":"Events Container"},{"location":"javascript/byot/implement-the-frontend/#glueing-it-all-together","text":"Now we are finished and just have to call the Event container in the index.js file. dashboard/pages/index.js import Head from \"next/head\" ; import Events from \"../containers/Events\" ; const mainStyle = { padding : 30 , display : \"flex\" , alignItems : \"center\" , justifyContent : \"space-evenly\" , flexWrap : \"wrap\" , }; export default function Home () { return ( < div > < Head > < title > Events Dashboard < /title> < /Head> < main style = { mainStyle } > < Events /> < /main> < /div> ); }","title":"Glueing it all together"},{"location":"javascript/byot/implement-the-frontend/#result","text":"","title":"Result"},{"location":"javascript/byot/installation/","text":"Installation To setup the projects you need to install Node.JS . Preferably you need yarn .","title":"Installation"},{"location":"javascript/byot/installation/#installation","text":"To setup the projects you need to install Node.JS . Preferably you need yarn .","title":"Installation"},{"location":"javascript/byot/roles-and-permissions/","text":"Roles & Permissions Before we consume our created content type Event , we need to enable the endpoint find and findOne to public API.","title":"Roles & Permissions"},{"location":"javascript/byot/roles-and-permissions/#roles-permissions","text":"Before we consume our created content type Event , we need to enable the endpoint find and findOne to public API.","title":"Roles &amp; Permissions"},{"location":"javascript/byot/setup-next/","text":"Setup Next.JS Now that we have setup our headless CMS, we can create a frontend to show an event dashboard for our employees. For that we run: npx create-next-app dashboard","title":"Setup Next.JS"},{"location":"javascript/byot/setup-next/#setup-nextjs","text":"Now that we have setup our headless CMS, we can create a frontend to show an event dashboard for our employees. For that we run: npx create-next-app dashboard","title":"Setup Next.JS"},{"location":"javascript/byot/setup/","text":"Setup Strapi Create a new project with: yarn create strapi-app backend --quickstart Now your browser should show up this site:","title":"Setup Strapi"},{"location":"javascript/byot/setup/#setup-strapi","text":"Create a new project with: yarn create strapi-app backend --quickstart Now your browser should show up this site:","title":"Setup Strapi"},{"location":"javascript/javascript-fundamentals/","text":"Introduction Welcome to my lecture JavaScript Fundamentals!","title":"Introduction"},{"location":"javascript/javascript-fundamentals/#introduction","text":"Welcome to my lecture JavaScript Fundamentals!","title":"Introduction"},{"location":"javascript/javascript-fundamentals/assert/","text":"Assert Please consider that the used assert object in the following examples only exists in Node.JS! If you are going to programm JavaScript in the browser, it won't be possible to use assert.equal for example. The Browser API only supports console.assert(condition, msg). So if you want to assert in the browser, you have to do the condition by yourself. For example: const a = 2 ; const b = 3 ; const c = 4 ; console . assert ( a !== b , \"a equals b\" ); console . assert ( a === c / 2 , \"a equals c divided by 2\" );","title":"Assert"},{"location":"javascript/javascript-fundamentals/assert/#assert","text":"Please consider that the used assert object in the following examples only exists in Node.JS! If you are going to programm JavaScript in the browser, it won't be possible to use assert.equal for example. The Browser API only supports console.assert(condition, msg). So if you want to assert in the browser, you have to do the condition by yourself. For example: const a = 2 ; const b = 3 ; const c = 4 ; console . assert ( a !== b , \"a equals b\" ); console . assert ( a === c / 2 , \"a equals c divided by 2\" );","title":"Assert"},{"location":"javascript/javascript-fundamentals/asynchronicity/","text":"Asynchronicity If you use JavaScript there are several parts, which help you to get all the necessary APIs and functionality to work: JS Engines and APIs JavaScript Engine is the JavaScript interpreter which runs your code and handles variables, etc. Platform Core is the platform dependent functionality, e.g. to send requests or to read files from local storage JS Standard Library brings all standard functionality, for example for Arrays or Objects Platform API provides platform dependent APIs to execute code which reads files or sends requests. If you execute code, which needs heavy computational time, then this code will block the process. That's because JavaScript is single-thread only . So keep in mind, everything that runs in your JavaScript engine is always in a single thread ! If everything in JavaScript is single-threaded, why then Web UIs doesn't block if they send a request to a server, to wait until they receive the belonging response? The event loop of JavaScript Check this Visualization to see how the event loop works. Callbacks const onInterval = () => { console . log ( \"Executed on interval\" ); }; setInterval ( onInterval , 1000 ); setInterval (() => { console . log ( \"Shorter way\" ); }, 1000 ); const onInterval = () => { console . log ( \"Before sleep\" ); sleep ( 1500 ); console . log ( \"After sleep\" ); }; const sleep = ( milliseconds ) => { const start = Date . now (); while ( Date . now () - start < milliseconds ); }; setInterval ( onInterval , 1000 ); Promises Promises are the default solution to program asynchronous code though there exist 'old' APIs with callback mechanisms. Nevertheless this is not a big deal since we can just wrap callbacks in Promises . The three states of Promises Promises have three different states: Pending - the Promise still waits for a result Fulfilled - the Promise has finished and got a result (no errors) Rejected - the Promise hash finished and got an error (no results) const addAsync = ( x , y ) => { return new Promise (( resolve , reject ) => { if ( x === undefined || y === undefined ) { return reject ( new Error ( \"Must provide two parameters\" )); } else { return resolve ( x + y ); } }); }; const prom = addAsync ( 1 , 2 ); prom . then (( result ) => { console . log ( `The result is: ${ result } ` ); }) . catch (( error ) => { console . error ( `There was an error: ${ error } ` ); }) . finally (() => { console . log ( \"Runs always, either its an error or a result\" ); }); Exceptions in Promises const myError = new Error ( \"My error!\" ); const promise = new Promise (( resolve , reject ) => { resolve ( 123 ); }); promise . then (( result ) => { console . log ( `Result is ${ result } but i will throw an error` ); throw myError ; }) . catch (( error ) => { console . error ( `Error is: ${ error } ` ); }); Returning in then() const addAsync = ( x , y ) => { return new Promise (( resolve , reject ) => { if ( x === undefined || y === undefined ) { reject ( new Error ( \"Must provide two parameters\" )); } else { resolve ( x + y ); } }); }; const multAsync = ( x , y ) => { return new Promise (( resolve , reject ) => { if ( x === undefined || y === undefined ) { reject ( new Error ( \"Must provide two parameters\" )); } else { resolve ( x * y ); } }); }; addAsync ( 1 , 2 ) . then (( result ) => { console . log ( `Add result is: ${ result } ` ); return multAsync ( result , 4 ); }) . then (( result ) => { console . log ( `Mult result is: ${ result } ` ); }) . catch (( error ) => { console . error ( `There was an error: ${ error } ` ); }); Async Async functions are just a syntactic wrapper for Promises. This means that you can use Promises and async/await interchangeable. But it's better to prefer the async/await syntax since it's more clear and most developers prefer the procedural style. const fetchJsonViaPromises = ( url ) => { return fetch ( url ) . then (( request ) => request . text ()) . then (( text ) => JSON . parse ( text )) . catch (( error ) => { console . error ( error ); }); }; const fetchJsonAsync = async ( url ) => { try { const request = await fetch ( url ); const text = await request . text (); return JSON . parse ( text ); } catch ( error ) { console . error ( error ); } }; Interchangeability const addAsync = async ( x , y ) => { return x + y ; }; addAsync . then (( result ) => { console . log ( `Result is: ${ result } ` ); }) . catch ( console . error );","title":"Asynchronicity"},{"location":"javascript/javascript-fundamentals/asynchronicity/#asynchronicity","text":"If you use JavaScript there are several parts, which help you to get all the necessary APIs and functionality to work: JS Engines and APIs JavaScript Engine is the JavaScript interpreter which runs your code and handles variables, etc. Platform Core is the platform dependent functionality, e.g. to send requests or to read files from local storage JS Standard Library brings all standard functionality, for example for Arrays or Objects Platform API provides platform dependent APIs to execute code which reads files or sends requests. If you execute code, which needs heavy computational time, then this code will block the process. That's because JavaScript is single-thread only . So keep in mind, everything that runs in your JavaScript engine is always in a single thread ! If everything in JavaScript is single-threaded, why then Web UIs doesn't block if they send a request to a server, to wait until they receive the belonging response? The event loop of JavaScript Check this Visualization to see how the event loop works.","title":"Asynchronicity"},{"location":"javascript/javascript-fundamentals/asynchronicity/#callbacks","text":"const onInterval = () => { console . log ( \"Executed on interval\" ); }; setInterval ( onInterval , 1000 ); setInterval (() => { console . log ( \"Shorter way\" ); }, 1000 ); const onInterval = () => { console . log ( \"Before sleep\" ); sleep ( 1500 ); console . log ( \"After sleep\" ); }; const sleep = ( milliseconds ) => { const start = Date . now (); while ( Date . now () - start < milliseconds ); }; setInterval ( onInterval , 1000 );","title":"Callbacks"},{"location":"javascript/javascript-fundamentals/asynchronicity/#promises","text":"Promises are the default solution to program asynchronous code though there exist 'old' APIs with callback mechanisms. Nevertheless this is not a big deal since we can just wrap callbacks in Promises . The three states of Promises Promises have three different states: Pending - the Promise still waits for a result Fulfilled - the Promise has finished and got a result (no errors) Rejected - the Promise hash finished and got an error (no results) const addAsync = ( x , y ) => { return new Promise (( resolve , reject ) => { if ( x === undefined || y === undefined ) { return reject ( new Error ( \"Must provide two parameters\" )); } else { return resolve ( x + y ); } }); }; const prom = addAsync ( 1 , 2 ); prom . then (( result ) => { console . log ( `The result is: ${ result } ` ); }) . catch (( error ) => { console . error ( `There was an error: ${ error } ` ); }) . finally (() => { console . log ( \"Runs always, either its an error or a result\" ); });","title":"Promises"},{"location":"javascript/javascript-fundamentals/asynchronicity/#exceptions-in-promises","text":"const myError = new Error ( \"My error!\" ); const promise = new Promise (( resolve , reject ) => { resolve ( 123 ); }); promise . then (( result ) => { console . log ( `Result is ${ result } but i will throw an error` ); throw myError ; }) . catch (( error ) => { console . error ( `Error is: ${ error } ` ); });","title":"Exceptions in Promises"},{"location":"javascript/javascript-fundamentals/asynchronicity/#returning-in-then","text":"const addAsync = ( x , y ) => { return new Promise (( resolve , reject ) => { if ( x === undefined || y === undefined ) { reject ( new Error ( \"Must provide two parameters\" )); } else { resolve ( x + y ); } }); }; const multAsync = ( x , y ) => { return new Promise (( resolve , reject ) => { if ( x === undefined || y === undefined ) { reject ( new Error ( \"Must provide two parameters\" )); } else { resolve ( x * y ); } }); }; addAsync ( 1 , 2 ) . then (( result ) => { console . log ( `Add result is: ${ result } ` ); return multAsync ( result , 4 ); }) . then (( result ) => { console . log ( `Mult result is: ${ result } ` ); }) . catch (( error ) => { console . error ( `There was an error: ${ error } ` ); });","title":"Returning in then()"},{"location":"javascript/javascript-fundamentals/asynchronicity/#async","text":"Async functions are just a syntactic wrapper for Promises. This means that you can use Promises and async/await interchangeable. But it's better to prefer the async/await syntax since it's more clear and most developers prefer the procedural style. const fetchJsonViaPromises = ( url ) => { return fetch ( url ) . then (( request ) => request . text ()) . then (( text ) => JSON . parse ( text )) . catch (( error ) => { console . error ( error ); }); }; const fetchJsonAsync = async ( url ) => { try { const request = await fetch ( url ); const text = await request . text (); return JSON . parse ( text ); } catch ( error ) { console . error ( error ); } };","title":"Async"},{"location":"javascript/javascript-fundamentals/asynchronicity/#interchangeability","text":"const addAsync = async ( x , y ) => { return x + y ; }; addAsync . then (( result ) => { console . log ( `Result is: ${ result } ` ); }) . catch ( console . error );","title":"Interchangeability"},{"location":"javascript/javascript-fundamentals/classes/","text":"Classes Constructor Functions There is the existence of constructor functions: function Person ( firstName , lastName , age , gender ) { this . firstName = firstName ; this . lastName = lastName ; this . age = age ; this . gender = gender ; this . fullName = function () { return ` ${ this . firstName } ${ this . lastName } ` } } assert . equal ( typeof Person , 'function' ); const person = new Person ( 'Test' , 'Tester' , 21 , 'male' ); assert . equal ( typeof person , 'object' ); assert . equal ( person . firstName , 'Test' ); assert . equal ( person . fullName , 'Test Tester' ); Prototypes and Inheritance // Shape - superclass function Shape () { this . x = 0 ; this . y = 0 ; } // superclass method Shape . prototype . move = function ( x , y ) { this . x += x ; this . y += y ; console . info ( 'Shape moved.' ); }; // Rectangle - subclass function Rectangle () { Shape . call ( this ); // call super constructor. } // subclass extends superclass Rectangle . prototype = Object . create ( Shape . prototype ); //If you don't set Rectangle.prototype.constructor to Rectangle, //it will take the prototype.constructor of Shape (parent). //To avoid that, we set the prototype.constructor to Rectangle (child). Rectangle . prototype . constructor = Rectangle ; var rect = new Rectangle (); console . log ( 'Is rect an instance of Rectangle?' , rect instanceof Rectangle ); // true console . log ( 'Is rect an instance of Shape?' , rect instanceof Shape ); // true rect . move ( 1 , 1 ); // Outputs, 'Shape moved.' Multiple Inheritance [use it with caution!] function MyClass () { SuperClass . call ( this ); OtherSuperClass . call ( this ); } // inherit one class MyClass . prototype = Object . create ( SuperClass . prototype ); // mixin another Object . assign ( Object . getPrototypeOf ( MyClass . prototype ), OtherSuperClass . prototype ); // re-assign constructor MyClass . prototype . constructor = MyClass ; MyClass . prototype . myMethod = function () { // do something }; Classes But they are used less frequently because of the implementation of Classes in ES6. So it became more convenient to use classes instead of constructor functions : class Person { constructor ( name ) { this . name = name ; } describe () { return 'Person named ' + this . name ; } get upperCaseName () { return this . name . toUpperCase (); } set setUpperCaseName ( value ) { this . name = value . toUpperCase (); } } const person = new Person ( 'Test' ); assert . equal ( person . name , 'Test' ); assert . equal ( person . describe (), 'Person named Test' ); assert . equal ( person . upperCaseName , 'TEST' ); person . setUpperCaseName = 'anotherTest' ; assert . equal ( person . name , 'ANOTHERTEST' ); person . name = 'backTest' ; assert . equal ( person . name , 'backTest' ); Inheritance class Person { constructor ( firstName , lastName ) { this . firstName = firstName ; this . lastName = lastName ; } fullName () { return ` ${ this . firstName } ${ this . lastName } ` ; } } class Employee extends Person { constructor ( firstName , lastName , position ) { super ( firstName , lastName ); this . position = position ; } } const empl1 = new Employee ( 'Test' , 'Testlast' , 'Developer' ); assert . equal ( empl1 . fullName (), 'Test Testlast' ); Static class Person { constructor ( firstName , lastName ) { this . firstName = firstName ; this . lastName = lastName ; } static createDefaultPerson () { return new Person ( 'Test' , 'TestPerson' ); } }","title":"Classes"},{"location":"javascript/javascript-fundamentals/classes/#classes","text":"","title":"Classes"},{"location":"javascript/javascript-fundamentals/classes/#constructor-functions","text":"There is the existence of constructor functions: function Person ( firstName , lastName , age , gender ) { this . firstName = firstName ; this . lastName = lastName ; this . age = age ; this . gender = gender ; this . fullName = function () { return ` ${ this . firstName } ${ this . lastName } ` } } assert . equal ( typeof Person , 'function' ); const person = new Person ( 'Test' , 'Tester' , 21 , 'male' ); assert . equal ( typeof person , 'object' ); assert . equal ( person . firstName , 'Test' ); assert . equal ( person . fullName , 'Test Tester' );","title":"Constructor Functions"},{"location":"javascript/javascript-fundamentals/classes/#prototypes-and-inheritance","text":"// Shape - superclass function Shape () { this . x = 0 ; this . y = 0 ; } // superclass method Shape . prototype . move = function ( x , y ) { this . x += x ; this . y += y ; console . info ( 'Shape moved.' ); }; // Rectangle - subclass function Rectangle () { Shape . call ( this ); // call super constructor. } // subclass extends superclass Rectangle . prototype = Object . create ( Shape . prototype ); //If you don't set Rectangle.prototype.constructor to Rectangle, //it will take the prototype.constructor of Shape (parent). //To avoid that, we set the prototype.constructor to Rectangle (child). Rectangle . prototype . constructor = Rectangle ; var rect = new Rectangle (); console . log ( 'Is rect an instance of Rectangle?' , rect instanceof Rectangle ); // true console . log ( 'Is rect an instance of Shape?' , rect instanceof Shape ); // true rect . move ( 1 , 1 ); // Outputs, 'Shape moved.'","title":"Prototypes and Inheritance"},{"location":"javascript/javascript-fundamentals/classes/#multiple-inheritance-use-it-with-caution","text":"function MyClass () { SuperClass . call ( this ); OtherSuperClass . call ( this ); } // inherit one class MyClass . prototype = Object . create ( SuperClass . prototype ); // mixin another Object . assign ( Object . getPrototypeOf ( MyClass . prototype ), OtherSuperClass . prototype ); // re-assign constructor MyClass . prototype . constructor = MyClass ; MyClass . prototype . myMethod = function () { // do something };","title":"Multiple Inheritance [use it with caution!]"},{"location":"javascript/javascript-fundamentals/classes/#classes_1","text":"But they are used less frequently because of the implementation of Classes in ES6. So it became more convenient to use classes instead of constructor functions : class Person { constructor ( name ) { this . name = name ; } describe () { return 'Person named ' + this . name ; } get upperCaseName () { return this . name . toUpperCase (); } set setUpperCaseName ( value ) { this . name = value . toUpperCase (); } } const person = new Person ( 'Test' ); assert . equal ( person . name , 'Test' ); assert . equal ( person . describe (), 'Person named Test' ); assert . equal ( person . upperCaseName , 'TEST' ); person . setUpperCaseName = 'anotherTest' ; assert . equal ( person . name , 'ANOTHERTEST' ); person . name = 'backTest' ; assert . equal ( person . name , 'backTest' );","title":"Classes"},{"location":"javascript/javascript-fundamentals/classes/#inheritance","text":"class Person { constructor ( firstName , lastName ) { this . firstName = firstName ; this . lastName = lastName ; } fullName () { return ` ${ this . firstName } ${ this . lastName } ` ; } } class Employee extends Person { constructor ( firstName , lastName , position ) { super ( firstName , lastName ); this . position = position ; } } const empl1 = new Employee ( 'Test' , 'Testlast' , 'Developer' ); assert . equal ( empl1 . fullName (), 'Test Testlast' );","title":"Inheritance"},{"location":"javascript/javascript-fundamentals/classes/#static","text":"class Person { constructor ( firstName , lastName ) { this . firstName = firstName ; this . lastName = lastName ; } static createDefaultPerson () { return new Person ( 'Test' , 'TestPerson' ); } }","title":"Static"},{"location":"javascript/javascript-fundamentals/complex-values/","text":"Complex Values Arrays const shoppingList = [ \"milk\" , \"rice\" , \"sugar\" ]; const values = [ \"abc\" , 123 , [ \"dfg\" , \"jkl\" ]]; assert . equal ( shoppingList [ 0 ], \"milk\" ); assert . equal ( shoppingList . length , 3 ); // Adding an item shopping_list . push ( \"potatoes\" ); assert . equal ( shoppingList . length , 4 ); // Shrinking the array to a length shopping_list . length = 1 ; assert . equal ( shoppingList , [ \"milk\" ]); // Remove at 0 index 1 element from array shopping_list . splice ( 0 , 1 ); All possible functions: Arrays Destructuring const arr = [ \"a\" , \"b\" , \"c\" ]; const [ a , b , c , d = \"d\" ] = arr ; assert . equal ( a , \"a\" ); assert . equal ( b , \"b\" ); assert . equal ( c , \"c\" ); assert . equal ( d , \"d\" ); Spreading const arr = [ 1 , 2 , 3 ]; const copyArr = [... arr ]; const anotherCopyArr = [ 0 , ... arr , 4 , 5 , 6 ]; assert . equal ( arr , arr ); assert . notEqual ( arr , copyArr ); assert . deepEqual ( arr , copyArr ); copyArr ; // [ 1, 2, 3 ] anotherCopyArr ; /* [ 0, 1, 2, 3, 4, 5, 6 ] */ Map Filter Reduce Find const arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]; const mappedArr = arr . map (( value ) => value + 1 ); const filteredArr = arr . filter (( value ) => value % 2 === 0 ); const reducedArr = arr . reduce (( value , total ) => total + value , 0 ); const findArr = arr . find (( value ) => value === 9 ); const notFindArr = arr . find (( value ) => value === 10 ); assert . deepEqual ( mappedArr , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]); assert . deepEqual ( filteredArr , [ 2 , 4 , 6 , 8 ]); assert . deepEqual ( reducedArr , 45 ); assert . deepEqual ( findArr , 9 ); assert . deepEqual ( notFindArr , undefined ); See Anonymous Functions for further information. Objects const person = { firstName : 'Test' , lastName : 'Testlast' , }; assert . equal ( person . firstName , 'Test' ); assert . equal ( person [ 'firstName' ], 'Test' ); person . age = 12 ; assert . equal ( person , { firstName : 'Test' , lastName : 'Testlast' , age : 12 } ) > Uncaught AssertionError assert . deepEqual ( person , { firstName : 'Test' , lastName : 'Testlast' , age : 12 } ) All possible functions: MDN Docs Destructuring const person = { firstName : \"Test\" , lastName : \"Testlast\" , }; const { firstName , lastName , age = 0 } = person ; const { fName , lName } = person ; assert . equal ( firstName , \"Test\" ); assert . equal ( lastName , \"Testlast\" ); assert . equal ( age , 0 ); assert . equal ( fName , undefined ); assert . equal ( lName , undefined ); Spreading const person = { firstName : \"Test\" , lastName : \"Testlast\" , }; const newPerson = { firstName : \"AnotherTest\" , ... person , age : 18 , }; assert . deepEqual ( newPerson , { firstName : \"Test\" , lastName : \"Testlast\" , age : 18 , }); Object.keys const person = { firstName : 'Test' , lastName : 'Testlast' , }; assert . equal ( Object . keys ( person ), [ 'firstName' , 'lastName' ], ); > Uncaught AssertionError assert . deepEqual ( Object . keys ( person ), [ 'firstName' , 'lastName' ], ); Object.values const person = { firstName : \"Test\" , lastName : \"Testlast\" , }; assert . deepEqual ( Object . values ( person ), [ \"Test\" , \"Testlast\" ]); Methods const person = { firstName : \"Test\" , lastName : \"Testlast\" , fullName : function () { return ` ${ this . firstName } ${ this . lastName } ` ; }, }; assert . equal ( person . fullName (), \"Test Testlast\" );","title":"Complex Values"},{"location":"javascript/javascript-fundamentals/complex-values/#complex-values","text":"","title":"Complex Values"},{"location":"javascript/javascript-fundamentals/complex-values/#arrays","text":"const shoppingList = [ \"milk\" , \"rice\" , \"sugar\" ]; const values = [ \"abc\" , 123 , [ \"dfg\" , \"jkl\" ]]; assert . equal ( shoppingList [ 0 ], \"milk\" ); assert . equal ( shoppingList . length , 3 ); // Adding an item shopping_list . push ( \"potatoes\" ); assert . equal ( shoppingList . length , 4 ); // Shrinking the array to a length shopping_list . length = 1 ; assert . equal ( shoppingList , [ \"milk\" ]); // Remove at 0 index 1 element from array shopping_list . splice ( 0 , 1 ); All possible functions: Arrays","title":"Arrays"},{"location":"javascript/javascript-fundamentals/complex-values/#destructuring","text":"const arr = [ \"a\" , \"b\" , \"c\" ]; const [ a , b , c , d = \"d\" ] = arr ; assert . equal ( a , \"a\" ); assert . equal ( b , \"b\" ); assert . equal ( c , \"c\" ); assert . equal ( d , \"d\" );","title":"Destructuring"},{"location":"javascript/javascript-fundamentals/complex-values/#spreading","text":"const arr = [ 1 , 2 , 3 ]; const copyArr = [... arr ]; const anotherCopyArr = [ 0 , ... arr , 4 , 5 , 6 ]; assert . equal ( arr , arr ); assert . notEqual ( arr , copyArr ); assert . deepEqual ( arr , copyArr ); copyArr ; // [ 1, 2, 3 ] anotherCopyArr ; /* [ 0, 1, 2, 3, 4, 5, 6 ] */","title":"Spreading"},{"location":"javascript/javascript-fundamentals/complex-values/#map-filter-reduce-find","text":"const arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]; const mappedArr = arr . map (( value ) => value + 1 ); const filteredArr = arr . filter (( value ) => value % 2 === 0 ); const reducedArr = arr . reduce (( value , total ) => total + value , 0 ); const findArr = arr . find (( value ) => value === 9 ); const notFindArr = arr . find (( value ) => value === 10 ); assert . deepEqual ( mappedArr , [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]); assert . deepEqual ( filteredArr , [ 2 , 4 , 6 , 8 ]); assert . deepEqual ( reducedArr , 45 ); assert . deepEqual ( findArr , 9 ); assert . deepEqual ( notFindArr , undefined ); See Anonymous Functions for further information.","title":"Map Filter Reduce Find"},{"location":"javascript/javascript-fundamentals/complex-values/#objects","text":"const person = { firstName : 'Test' , lastName : 'Testlast' , }; assert . equal ( person . firstName , 'Test' ); assert . equal ( person [ 'firstName' ], 'Test' ); person . age = 12 ; assert . equal ( person , { firstName : 'Test' , lastName : 'Testlast' , age : 12 } ) > Uncaught AssertionError assert . deepEqual ( person , { firstName : 'Test' , lastName : 'Testlast' , age : 12 } ) All possible functions: MDN Docs","title":"Objects"},{"location":"javascript/javascript-fundamentals/complex-values/#destructuring_1","text":"const person = { firstName : \"Test\" , lastName : \"Testlast\" , }; const { firstName , lastName , age = 0 } = person ; const { fName , lName } = person ; assert . equal ( firstName , \"Test\" ); assert . equal ( lastName , \"Testlast\" ); assert . equal ( age , 0 ); assert . equal ( fName , undefined ); assert . equal ( lName , undefined );","title":"Destructuring"},{"location":"javascript/javascript-fundamentals/complex-values/#spreading_1","text":"const person = { firstName : \"Test\" , lastName : \"Testlast\" , }; const newPerson = { firstName : \"AnotherTest\" , ... person , age : 18 , }; assert . deepEqual ( newPerson , { firstName : \"Test\" , lastName : \"Testlast\" , age : 18 , });","title":"Spreading"},{"location":"javascript/javascript-fundamentals/complex-values/#objectkeys","text":"const person = { firstName : 'Test' , lastName : 'Testlast' , }; assert . equal ( Object . keys ( person ), [ 'firstName' , 'lastName' ], ); > Uncaught AssertionError assert . deepEqual ( Object . keys ( person ), [ 'firstName' , 'lastName' ], );","title":"Object.keys"},{"location":"javascript/javascript-fundamentals/complex-values/#objectvalues","text":"const person = { firstName : \"Test\" , lastName : \"Testlast\" , }; assert . deepEqual ( Object . values ( person ), [ \"Test\" , \"Testlast\" ]);","title":"Object.values"},{"location":"javascript/javascript-fundamentals/complex-values/#methods","text":"const person = { firstName : \"Test\" , lastName : \"Testlast\" , fullName : function () { return ` ${ this . firstName } ${ this . lastName } ` ; }, }; assert . equal ( person . fullName (), \"Test Testlast\" );","title":"Methods"},{"location":"javascript/javascript-fundamentals/conditions/","text":"Conditions Truthy vs. Falsy values Falsy values are: undefined null Boolean: false Numbers: 0, NaN Bigint: 0n String: \"\" Note All other values are truthy! if-condition const a = 2 ; const b = 3 ; if ( a === b ) { console . log ( \"equal\" ); } else { console . log ( \"not equal\" ); } if-in-condition const a = { firstName : \"Test\" , lastName : \"Testlast\" , }; assert . equal ( \"firstName\" in a , true ); assert . equal ( \"lastName\" in a , true ); assert . equal ( \"Test\" in a , false ); assert . equal ( \"NotExistingKey\" in a , false ); const b = [ \"a\" , \"b\" , \"c\" ]; assert . equal ( \"a\" in b , false ); assert . equal ( \"b\" in b , false ); assert . equal ( 0 in b , true ); assert . equal ( 2 in b , true ); assert . equal ( 3 in b , false ); switch-case const STARTED = \"started\" ; const FINISHED = \"finished\" ; const status = STARTED ; switch ( status ) { case STARTED : console . log ( \"Process has started!\" ); break ; case FINISHED : console . log ( \"Process has finished!\" ); break ; default : console . log ( \"Unknown status!\" ); } // Process has started!","title":"Conditions"},{"location":"javascript/javascript-fundamentals/conditions/#conditions","text":"","title":"Conditions"},{"location":"javascript/javascript-fundamentals/conditions/#truthy-vs-falsy-values","text":"Falsy values are: undefined null Boolean: false Numbers: 0, NaN Bigint: 0n String: \"\" Note All other values are truthy!","title":"Truthy vs. Falsy values"},{"location":"javascript/javascript-fundamentals/conditions/#if-condition","text":"const a = 2 ; const b = 3 ; if ( a === b ) { console . log ( \"equal\" ); } else { console . log ( \"not equal\" ); }","title":"if-condition"},{"location":"javascript/javascript-fundamentals/conditions/#if-in-condition","text":"const a = { firstName : \"Test\" , lastName : \"Testlast\" , }; assert . equal ( \"firstName\" in a , true ); assert . equal ( \"lastName\" in a , true ); assert . equal ( \"Test\" in a , false ); assert . equal ( \"NotExistingKey\" in a , false ); const b = [ \"a\" , \"b\" , \"c\" ]; assert . equal ( \"a\" in b , false ); assert . equal ( \"b\" in b , false ); assert . equal ( 0 in b , true ); assert . equal ( 2 in b , true ); assert . equal ( 3 in b , false );","title":"if-in-condition"},{"location":"javascript/javascript-fundamentals/conditions/#switch-case","text":"const STARTED = \"started\" ; const FINISHED = \"finished\" ; const status = STARTED ; switch ( status ) { case STARTED : console . log ( \"Process has started!\" ); break ; case FINISHED : console . log ( \"Process has finished!\" ); break ; default : console . log ( \"Unknown status!\" ); } // Process has started!","title":"switch-case"},{"location":"javascript/javascript-fundamentals/exceptions/","text":"Exceptions The Error object Any value can be thrown, but it's convenient to throw an Error object: throw new Error ( \"Unexpected Error\" ); Try... Catch const oddValue = ( value ) => { if ( value % 2 === 0 ) { throw new Error ( ` ${ value } is not odd!` ); } }; try { oddValue ( 3 ); oddValue ( 2 ); } catch ( error ) { console . error ( error ); } finally { console . log ( \"this will be printed always!\" ); } // Error: 2 is not odd!","title":"Exceptions"},{"location":"javascript/javascript-fundamentals/exceptions/#exceptions","text":"","title":"Exceptions"},{"location":"javascript/javascript-fundamentals/exceptions/#the-error-object","text":"Any value can be thrown, but it's convenient to throw an Error object: throw new Error ( \"Unexpected Error\" );","title":"The Error object"},{"location":"javascript/javascript-fundamentals/exceptions/#try-catch","text":"const oddValue = ( value ) => { if ( value % 2 === 0 ) { throw new Error ( ` ${ value } is not odd!` ); } }; try { oddValue ( 3 ); oddValue ( 2 ); } catch ( error ) { console . error ( error ); } finally { console . log ( \"this will be printed always!\" ); } // Error: 2 is not odd!","title":"Try... Catch"},{"location":"javascript/javascript-fundamentals/functions/","text":"Functions JavaScript has two categories of functions An ordinary function can play several roles: Real function Method Constructor function A specialized function can only play one of those roles \u2013 for example: An arrow function can only be a real function. A method can only be a method. A class can only be a constructor function. Ordinary Functions Parts of Ordinary Functions function add ( x , y ) { return x + y ; } add is the name of the function declaration. add(x, y) is the head of the function declaration. x and y are the parameters. The curly braces ({and}) and everything between them are the body of the function declaration. The return statement explicitly returns value from the function. Different ways to define the same: an ordinary function Three ways of doing (roughly) the same thing: creating an ordinary function. // Function declaration (a statement) function ordinary1 ( a , b , c ) { // \u00b7\u00b7\u00b7 } // const plus anonymous function expression const ordinary2 = function ( a , b , c ) { // \u00b7\u00b7\u00b7 }; // const plus named function expression const ordinary3 = function myName ( a , b , c ) { // `myName` is only accessible in here }; Roles of an ordinary function function add ( x , y ) { return x + y ; } This function declaration creates an ordinary function whose name is add . As an ordinary function, add() can play three roles: 1. Real function: invoked via a function call: assert . equal ( add ( 2 , 1 ), 3 ); 2. Method: stored in property, invoked via a method call: const obj = { addAsMethod : add }; assert . equal ( obj . addAsMethod ( 2 , 4 ), 6 ); // (A) obj is called the receiver of the method call. It can be accessed via this inside the method. 3. Constructor function/class: invoked via new. const inst = new add (); assert . equal ( inst instanceof add , true ); Specialized Functions Specialized functions are single-purpose versions of ordinary functions. Each one of them specializes in one single role : Roles of specialized function The purpose of an arrow function is to be a real function: const arrow = () => { return 123 ; }; assert . equal ( arrow (), 123 ); The purpose of a method is to be a method: const obj = { method () { return 'abc' ; }, }; assert . equal ( obj . method (), 'abc' ); The purpose of a class is to be a constructor function: class MyClass { /* \u00b7\u00b7\u00b7 */ } const inst = new MyClass (); Use specialized over ordinary functions function funcDecl ( x , y ) { return x * y ; } const arrowFunc = ( x , y ) => { return x * y ; }; Arrow Functions const f = function ( x , y , z ) { return 123 ; }; const g = ( x , y , z ) => { return 123 ; }; const h = ( x , y , z ) => 123 ; const plusTwo = ( x ) => x + 2 ; Arrow Functions are often used as a parameter of callback-functions Return Statements Normally you can just use return in an arrow function to return expressions: const sum = ( a , b ) => { return a + b ; }; If the return value of the arrow function is an expression, you can leave the curly-brackets out. [ 1 , 2 , 3 ]. map (( x ) => x + 1 ); If you want to return a multiline expression you can wrap the expression in parenthesis: const divide = ( dividend , divisor ) => ( dividend / divisor ) What about this 'this'? In ordinary functions 'this' always relates to current function. In specialized functions 'this' always relates to the lexical this which is mostly preferred. const prefixer = { prefix : '==> ' , prefixStringArray ( stringArray ) { return stringArray . map ( function ( x ) { return this . prefix + x ; }); }, }; prefixer . prefixStringArray ([ 'a' , 'b' , 'c' ])[ ( 'undefineda' , 'undefinedb' , 'undefinedc' ) ]; const prefixerRight = { prefix : '==> ' , prefixStringArray ( stringArray ) { return stringArray . map (( x ) => { return this . prefix + x ; }); }, }; prefixerRight . prefixStringArray ([ 'a' , 'b' , 'c' ])[( '==> a' , '==> b' , '==> c' )];","title":"Functions"},{"location":"javascript/javascript-fundamentals/functions/#functions","text":"JavaScript has two categories of functions An ordinary function can play several roles: Real function Method Constructor function A specialized function can only play one of those roles \u2013 for example: An arrow function can only be a real function. A method can only be a method. A class can only be a constructor function.","title":"Functions"},{"location":"javascript/javascript-fundamentals/functions/#ordinary-functions","text":"","title":"Ordinary Functions"},{"location":"javascript/javascript-fundamentals/functions/#parts-of-ordinary-functions","text":"function add ( x , y ) { return x + y ; } add is the name of the function declaration. add(x, y) is the head of the function declaration. x and y are the parameters. The curly braces ({and}) and everything between them are the body of the function declaration. The return statement explicitly returns value from the function.","title":"Parts of Ordinary Functions"},{"location":"javascript/javascript-fundamentals/functions/#different-ways-to-define-the-same-an-ordinary-function","text":"Three ways of doing (roughly) the same thing: creating an ordinary function. // Function declaration (a statement) function ordinary1 ( a , b , c ) { // \u00b7\u00b7\u00b7 } // const plus anonymous function expression const ordinary2 = function ( a , b , c ) { // \u00b7\u00b7\u00b7 }; // const plus named function expression const ordinary3 = function myName ( a , b , c ) { // `myName` is only accessible in here };","title":"Different ways to define the same: an ordinary function"},{"location":"javascript/javascript-fundamentals/functions/#roles-of-an-ordinary-function","text":"function add ( x , y ) { return x + y ; } This function declaration creates an ordinary function whose name is add . As an ordinary function, add() can play three roles:","title":"Roles of an ordinary function"},{"location":"javascript/javascript-fundamentals/functions/#1-real-function-invoked-via-a-function-call","text":"assert . equal ( add ( 2 , 1 ), 3 );","title":"1. Real function: invoked via a function call:"},{"location":"javascript/javascript-fundamentals/functions/#2-method-stored-in-property-invoked-via-a-method-call","text":"const obj = { addAsMethod : add }; assert . equal ( obj . addAsMethod ( 2 , 4 ), 6 ); // (A) obj is called the receiver of the method call. It can be accessed via this inside the method.","title":"2. Method: stored in property, invoked via a method call:"},{"location":"javascript/javascript-fundamentals/functions/#3-constructor-functionclass-invoked-via-new","text":"const inst = new add (); assert . equal ( inst instanceof add , true );","title":"3. Constructor function/class: invoked via new."},{"location":"javascript/javascript-fundamentals/functions/#specialized-functions","text":"Specialized functions are single-purpose versions of ordinary functions. Each one of them specializes in one single role :","title":"Specialized Functions"},{"location":"javascript/javascript-fundamentals/functions/#roles-of-specialized-function","text":"","title":"Roles of specialized function"},{"location":"javascript/javascript-fundamentals/functions/#the-purpose-of-an-arrow-function-is-to-be-a-real-function","text":"const arrow = () => { return 123 ; }; assert . equal ( arrow (), 123 );","title":"The purpose of an arrow function is to be a real function:"},{"location":"javascript/javascript-fundamentals/functions/#the-purpose-of-a-method-is-to-be-a-method","text":"const obj = { method () { return 'abc' ; }, }; assert . equal ( obj . method (), 'abc' );","title":"The purpose of a method is to be a method:"},{"location":"javascript/javascript-fundamentals/functions/#the-purpose-of-a-class-is-to-be-a-constructor-function","text":"class MyClass { /* \u00b7\u00b7\u00b7 */ } const inst = new MyClass ();","title":"The purpose of a class is to be a constructor function:"},{"location":"javascript/javascript-fundamentals/functions/#use-specialized-over-ordinary-functions","text":"function funcDecl ( x , y ) { return x * y ; } const arrowFunc = ( x , y ) => { return x * y ; };","title":"Use specialized over ordinary functions"},{"location":"javascript/javascript-fundamentals/functions/#arrow-functions","text":"const f = function ( x , y , z ) { return 123 ; }; const g = ( x , y , z ) => { return 123 ; }; const h = ( x , y , z ) => 123 ; const plusTwo = ( x ) => x + 2 ; Arrow Functions are often used as a parameter of callback-functions","title":"Arrow Functions"},{"location":"javascript/javascript-fundamentals/functions/#return-statements","text":"Normally you can just use return in an arrow function to return expressions: const sum = ( a , b ) => { return a + b ; }; If the return value of the arrow function is an expression, you can leave the curly-brackets out. [ 1 , 2 , 3 ]. map (( x ) => x + 1 ); If you want to return a multiline expression you can wrap the expression in parenthesis: const divide = ( dividend , divisor ) => ( dividend / divisor )","title":"Return Statements"},{"location":"javascript/javascript-fundamentals/functions/#what-about-this-this","text":"In ordinary functions 'this' always relates to current function. In specialized functions 'this' always relates to the lexical this which is mostly preferred. const prefixer = { prefix : '==> ' , prefixStringArray ( stringArray ) { return stringArray . map ( function ( x ) { return this . prefix + x ; }); }, }; prefixer . prefixStringArray ([ 'a' , 'b' , 'c' ])[ ( 'undefineda' , 'undefinedb' , 'undefinedc' ) ]; const prefixerRight = { prefix : '==> ' , prefixStringArray ( stringArray ) { return stringArray . map (( x ) => { return this . prefix + x ; }); }, }; prefixerRight . prefixStringArray ([ 'a' , 'b' , 'c' ])[( '==> a' , '==> b' , '==> c' )];","title":"What about this 'this'?"},{"location":"javascript/javascript-fundamentals/history/","text":"History JavaScript was created in May 1995 in 10 days, by Brendan Eich. Eich worked at Netscape and implemented JavaScript for their web browser, Netscape Navigator. The idea was that major interactive parts of the client-side web were to be implemented in Java. JavaScript was supposed to be a glue language for those parts and to also make HTML slightly more interactive. Given its role of assisting Java, JavaScript had to look like Java. That ruled out existing solutions such as Perl, Python, TCL, and others. Initially, JavaScript\u2019s name changed several times: * Its code name was Mocha. * In the Netscape Navigator 2.0 betas (September 1995), it was called LiveScript. * In Netscape Navigator 2.0 beta 3 (December 1995), it got its final name, JavaScript. ECMAScript Standard (European Computer Manufacturers Association) The language described by these standards is called ECMAScript, not JavaScript. A differ- ent name was chosen because Sun (now Oracle) had a trademark for the latter name. The \u201cECMA\u201d in \u201cECMAScript\u201d comes from the organization that hosts the primary standard. The term JavaScript refers to the language and its implementations. The term ECMAScript refers to the language standard and language versions. Current ECMAScript Version: 11th Edition (ECMAScript 2020)","title":"History"},{"location":"javascript/javascript-fundamentals/history/#history","text":"JavaScript was created in May 1995 in 10 days, by Brendan Eich. Eich worked at Netscape and implemented JavaScript for their web browser, Netscape Navigator. The idea was that major interactive parts of the client-side web were to be implemented in Java. JavaScript was supposed to be a glue language for those parts and to also make HTML slightly more interactive. Given its role of assisting Java, JavaScript had to look like Java. That ruled out existing solutions such as Perl, Python, TCL, and others. Initially, JavaScript\u2019s name changed several times: * Its code name was Mocha. * In the Netscape Navigator 2.0 betas (September 1995), it was called LiveScript. * In Netscape Navigator 2.0 beta 3 (December 1995), it got its final name, JavaScript. ECMAScript Standard (European Computer Manufacturers Association) The language described by these standards is called ECMAScript, not JavaScript. A differ- ent name was chosen because Sun (now Oracle) had a trademark for the latter name. The \u201cECMA\u201d in \u201cECMAScript\u201d comes from the organization that hosts the primary standard. The term JavaScript refers to the language and its implementations. The term ECMAScript refers to the language standard and language versions. Current ECMAScript Version: 11th Edition (ECMAScript 2020)","title":"History"},{"location":"javascript/javascript-fundamentals/json/","text":"JSON JavaScript has a native support for JSON parsing and \"stringifying\". Parsing Let's assume we have following JSON in a string: Example: const data = `{\"a\": 1, \"2\": \"b\"}` ; const parsedData = JSON . parse ( data ); console . log ( parsedData ); // Output: Object { 2: \"b\", a: 1 } We can simply parse JSON strings into a JavaScript object, array, string, or number. Stringify If we have already an object, we can \"stringify\" that object into a JSON string. Example: const data = [ 'hello' , 'world' , 1 , 2 , 3 ]; const jsonData = JSON . stringify ( data ); console . log ( jsonData ); // Output: [\"hello\",\"world\",1,2,3]","title":"JSON"},{"location":"javascript/javascript-fundamentals/json/#json","text":"JavaScript has a native support for JSON parsing and \"stringifying\".","title":"JSON"},{"location":"javascript/javascript-fundamentals/json/#parsing","text":"Let's assume we have following JSON in a string: Example: const data = `{\"a\": 1, \"2\": \"b\"}` ; const parsedData = JSON . parse ( data ); console . log ( parsedData ); // Output: Object { 2: \"b\", a: 1 } We can simply parse JSON strings into a JavaScript object, array, string, or number.","title":"Parsing"},{"location":"javascript/javascript-fundamentals/json/#stringify","text":"If we have already an object, we can \"stringify\" that object into a JSON string. Example: const data = [ 'hello' , 'world' , 1 , 2 , 3 ]; const jsonData = JSON . stringify ( data ); console . log ( jsonData ); // Output: [\"hello\",\"world\",1,2,3]","title":"Stringify"},{"location":"javascript/javascript-fundamentals/loops/","text":"Loops while-loops const arr = [ \"a\" , \"b\" , \"c\" ]; while ( arr . length > 0 ) { const elem = arr . shift (); // remove first element console . log ( elem ); } Endless Loop while ( true ) { if ( Math . random () === 0 ) break ; } for-loops for ( let i = 0 ; i < 3 ; i ++ ) { console . log ( i ); } Loop over an array const arr = [ \"a\" , \"b\" , \"c\" ]; for ( let i = 0 ; i < arr . length ; i ++ ) { console . log ( arr [ i ]); } for-of-loops Use this rather than for-loops because here you define the element as const const iterable = [ \"hello\" , \"world\" ]; for ( const elem of iterable ) { console . log ( elem ); } for-in-loops (avoid!) const obj = { a : 1 , b : 2 }; for ( const key in obj ) { console . log ( key ); } Loop over lists instead const obj = { a : 1 , b : 2 }; for ( const key of Object . keys ( obj )) { console . log ( key ); }","title":"Loops"},{"location":"javascript/javascript-fundamentals/loops/#loops","text":"","title":"Loops"},{"location":"javascript/javascript-fundamentals/loops/#while-loops","text":"const arr = [ \"a\" , \"b\" , \"c\" ]; while ( arr . length > 0 ) { const elem = arr . shift (); // remove first element console . log ( elem ); }","title":"while-loops"},{"location":"javascript/javascript-fundamentals/loops/#endless-loop","text":"while ( true ) { if ( Math . random () === 0 ) break ; }","title":"Endless Loop"},{"location":"javascript/javascript-fundamentals/loops/#for-loops","text":"for ( let i = 0 ; i < 3 ; i ++ ) { console . log ( i ); }","title":"for-loops"},{"location":"javascript/javascript-fundamentals/loops/#loop-over-an-array","text":"const arr = [ \"a\" , \"b\" , \"c\" ]; for ( let i = 0 ; i < arr . length ; i ++ ) { console . log ( arr [ i ]); }","title":"Loop over an array"},{"location":"javascript/javascript-fundamentals/loops/#for-of-loops","text":"Use this rather than for-loops because here you define the element as const const iterable = [ \"hello\" , \"world\" ]; for ( const elem of iterable ) { console . log ( elem ); }","title":"for-of-loops"},{"location":"javascript/javascript-fundamentals/loops/#for-in-loops-avoid","text":"const obj = { a : 1 , b : 2 }; for ( const key in obj ) { console . log ( key ); }","title":"for-in-loops (avoid!)"},{"location":"javascript/javascript-fundamentals/loops/#loop-over-lists-instead","text":"const obj = { a : 1 , b : 2 }; for ( const key of Object . keys ( obj )) { console . log ( key ); }","title":"Loop over lists instead"},{"location":"javascript/javascript-fundamentals/primitive-values/","text":"Primitive Values undefined vs. null undefined means \"not initialized\" (e.g. a variable) or \"not existing\" (e.g. a property of an object) null means \"the intentional absence of any object value\" (a quote from the language specification) let myVar ; assert . equal ( myVar , undefined ); function func ( x ) { return x ; } assert . equal ( func (), undefined ); const obj = {}; assert . equal ( obj . unknownProp , undefined ); function func () {} assert . equal ( func (), undefined ); Booleans const a = true ; const b = false ; const c = Boolean ( \"\" ); const d = Boolean ( 123 ); assert . equal ( c , false ); assert . equal ( d , true ); See Truthy vs. Falsy values for further information Numbers All numbers are doubles with 64-bit floating point assert . equal ( 98 , 98.0 ); Strings const str1 = \"abc\" ; const str2 = \"abc\" ; assert . equal ( str1 [ 0 ], str2 [ 0 ]); All possible functions: MDN Docs Template Strings const firstName = \"Test\" ; const lastName = \"LastTest\" ; const str = ` ${ firstName } ${ lastName } ` ; const str2 = firstName + \" \" + lastName ;","title":"Primitive Values"},{"location":"javascript/javascript-fundamentals/primitive-values/#primitive-values","text":"","title":"Primitive Values"},{"location":"javascript/javascript-fundamentals/primitive-values/#undefined-vs-null","text":"undefined means \"not initialized\" (e.g. a variable) or \"not existing\" (e.g. a property of an object) null means \"the intentional absence of any object value\" (a quote from the language specification) let myVar ; assert . equal ( myVar , undefined ); function func ( x ) { return x ; } assert . equal ( func (), undefined ); const obj = {}; assert . equal ( obj . unknownProp , undefined ); function func () {} assert . equal ( func (), undefined );","title":"undefined vs. null"},{"location":"javascript/javascript-fundamentals/primitive-values/#booleans","text":"const a = true ; const b = false ; const c = Boolean ( \"\" ); const d = Boolean ( 123 ); assert . equal ( c , false ); assert . equal ( d , true ); See Truthy vs. Falsy values for further information","title":"Booleans"},{"location":"javascript/javascript-fundamentals/primitive-values/#numbers","text":"All numbers are doubles with 64-bit floating point assert . equal ( 98 , 98.0 );","title":"Numbers"},{"location":"javascript/javascript-fundamentals/primitive-values/#strings","text":"const str1 = \"abc\" ; const str2 = \"abc\" ; assert . equal ( str1 [ 0 ], str2 [ 0 ]); All possible functions: MDN Docs","title":"Strings"},{"location":"javascript/javascript-fundamentals/primitive-values/#template-strings","text":"const firstName = \"Test\" ; const lastName = \"LastTest\" ; const str = ` ${ firstName } ${ lastName } ` ; const str2 = firstName + \" \" + lastName ;","title":"Template Strings"},{"location":"javascript/javascript-fundamentals/references/","text":"References For this lecture I used the following book as reference: JavaScript for impatient programmers MDN web docs : cover various web technologies such as CSS, HTML, JavaScript, and more. An excellent reference. Node.js Docs : documenting the Node.js API. Deep JavaScript : Goes deep into JavaScript techniques and methods","title":"References"},{"location":"javascript/javascript-fundamentals/references/#references","text":"For this lecture I used the following book as reference: JavaScript for impatient programmers MDN web docs : cover various web technologies such as CSS, HTML, JavaScript, and more. An excellent reference. Node.js Docs : documenting the Node.js API. Deep JavaScript : Goes deep into JavaScript techniques and methods","title":"References"},{"location":"javascript/javascript-fundamentals/statements-vs-expressions/","text":"Statements vs. Expression Statements Statements perform instructions step by step. let myStr ; if ( myBool ) { myStr = 'Yes' ; } else { myStr = 'No' ; } Expressions Expressions always produce a value. let myStr = myBool ? 'Yes' : 'No' ; Operators Most operators work with primitive values. Equality Loose Equality (avoid!) '123' == 123 ; // true false == 0 ; // true Strict Equality false === 0 ; // false '123' === 123 ; // false Ordering 5 >= 2 ; // true 'bar' < 'foo' ; //true Nullish Coalescing Checks if the first value is 'nullish' and uses the second value if so a ?? b ; // is the same as a !== undefined && a !== null ? a : b ; OR Operator Checks if the first value is 'falsy' and uses the second value if so undefined || 'default' ; // \"default\" null || 'default' ; // \"default\" false || 'default' ; // \"default\" 0 || 'default' ; // \"default\" 0n || 'default' ; // \"default\" '' || 'default' ; // \"default\" true || 'default' ; // true 'some text' || 'default' ; // \"some text\" AND Operator Checks if the first value is 'truthy' and uses the second value if so [ 1 , 2 , 3 ] && 'default' // 'default' { a : 2 } && 'default' // 'default' true && 'default' // 'default' 123 && 'default' // 'default' 4n && 'default' // 'default' 'asdf' && 'default' // 'default' false && 'default' // false What is allowed where? The body of a function must be a sequence of statements: function max ( x , y ) { if ( x > y ) { return x ; } else { return y ; } } The arguments of a function call or a method call must be expressions: console . log ( 'ab' + 'cd' , Number ( '123' )); Useful links https://joshwcomeau.com/operator-lookup/","title":"Statements vs. Expression"},{"location":"javascript/javascript-fundamentals/statements-vs-expressions/#statements-vs-expression","text":"","title":"Statements vs. Expression"},{"location":"javascript/javascript-fundamentals/statements-vs-expressions/#statements","text":"Statements perform instructions step by step. let myStr ; if ( myBool ) { myStr = 'Yes' ; } else { myStr = 'No' ; }","title":"Statements"},{"location":"javascript/javascript-fundamentals/statements-vs-expressions/#expressions","text":"Expressions always produce a value. let myStr = myBool ? 'Yes' : 'No' ;","title":"Expressions"},{"location":"javascript/javascript-fundamentals/statements-vs-expressions/#operators","text":"Most operators work with primitive values.","title":"Operators"},{"location":"javascript/javascript-fundamentals/statements-vs-expressions/#equality","text":"","title":"Equality"},{"location":"javascript/javascript-fundamentals/statements-vs-expressions/#loose-equality-avoid","text":"'123' == 123 ; // true false == 0 ; // true","title":"Loose Equality (avoid!)"},{"location":"javascript/javascript-fundamentals/statements-vs-expressions/#strict-equality","text":"false === 0 ; // false '123' === 123 ; // false","title":"Strict Equality"},{"location":"javascript/javascript-fundamentals/statements-vs-expressions/#ordering","text":"5 >= 2 ; // true 'bar' < 'foo' ; //true","title":"Ordering"},{"location":"javascript/javascript-fundamentals/statements-vs-expressions/#nullish-coalescing","text":"Checks if the first value is 'nullish' and uses the second value if so a ?? b ; // is the same as a !== undefined && a !== null ? a : b ;","title":"Nullish Coalescing"},{"location":"javascript/javascript-fundamentals/statements-vs-expressions/#or-operator","text":"Checks if the first value is 'falsy' and uses the second value if so undefined || 'default' ; // \"default\" null || 'default' ; // \"default\" false || 'default' ; // \"default\" 0 || 'default' ; // \"default\" 0n || 'default' ; // \"default\" '' || 'default' ; // \"default\" true || 'default' ; // true 'some text' || 'default' ; // \"some text\"","title":"OR Operator"},{"location":"javascript/javascript-fundamentals/statements-vs-expressions/#and-operator","text":"Checks if the first value is 'truthy' and uses the second value if so [ 1 , 2 , 3 ] && 'default' // 'default' { a : 2 } && 'default' // 'default' true && 'default' // 'default' 123 && 'default' // 'default' 4n && 'default' // 'default' 'asdf' && 'default' // 'default' false && 'default' // false","title":"AND Operator"},{"location":"javascript/javascript-fundamentals/statements-vs-expressions/#what-is-allowed-where","text":"The body of a function must be a sequence of statements: function max ( x , y ) { if ( x > y ) { return x ; } else { return y ; } } The arguments of a function call or a method call must be expressions: console . log ( 'ab' + 'cd' , Number ( '123' ));","title":"What is allowed where?"},{"location":"javascript/javascript-fundamentals/statements-vs-expressions/#useful-links","text":"https://joshwcomeau.com/operator-lookup/","title":"Useful links"},{"location":"javascript/javascript-fundamentals/tc39/","text":"TC39 (Technical Committee 39) TC39 is the committee that evolves JavaScript. Its members are, strictly speaking, compa- nies: Adobe, Apple, Facebook, Google, Microsoft, Mozilla, Opera, Twitter, and others. That is, companies that are usually fierce competitors are working together for the good of the language. Every two months, TC39 has meetings that member-appointed delegates and invited experts attend. The minutes of those meetings are public in a GitHub repository. TC39 Process TC39 Release Process","title":"TC39 (Technical Committee 39)"},{"location":"javascript/javascript-fundamentals/tc39/#tc39-technical-committee-39","text":"TC39 is the committee that evolves JavaScript. Its members are, strictly speaking, compa- nies: Adobe, Apple, Facebook, Google, Microsoft, Mozilla, Opera, Twitter, and others. That is, companies that are usually fierce competitors are working together for the good of the language. Every two months, TC39 has meetings that member-appointed delegates and invited experts attend. The minutes of those meetings are public in a GitHub repository.","title":"TC39 (Technical Committee 39)"},{"location":"javascript/javascript-fundamentals/tc39/#tc39-process","text":"TC39 Release Process","title":"TC39 Process"},{"location":"javascript/javascript-fundamentals/values/","text":"Values Separaton of values in JavaScript undefined with the only element undefined null with the only element null boolean with the elements false and true number the type of all numbers (e.g., -123, 3.141) bigint the type of all big integers (e.g., -123n) string the type of all strings (e.g., 'abc') symbol the type of all symbols (e.g., Symbol('My Symbol')) object the type of all objects (different from Object, the type of all instances of class Object and its subclasses) Primitive Values vs. Objects Primitive values They are atomic building blocks of data in JavaScript. They are passed by value: when primitive values are assigned to variables or passed to functions, their contents are copied. They are compared by value: when comparing two primitive values, their contents are compared. Objects They are compound pieces of data They are passed by identity: when objects are assigned to variables or passed to functions, their identities (think pointers) are copied. They are compared by identity (my term): when comparing two objects, their identities are compared","title":"Values"},{"location":"javascript/javascript-fundamentals/values/#values","text":"Separaton of values in JavaScript undefined with the only element undefined null with the only element null boolean with the elements false and true number the type of all numbers (e.g., -123, 3.141) bigint the type of all big integers (e.g., -123n) string the type of all strings (e.g., 'abc') symbol the type of all symbols (e.g., Symbol('My Symbol')) object the type of all objects (different from Object, the type of all instances of class Object and its subclasses)","title":"Values"},{"location":"javascript/javascript-fundamentals/values/#primitive-values-vs-objects","text":"","title":"Primitive Values vs. Objects"},{"location":"javascript/javascript-fundamentals/values/#primitive-values","text":"They are atomic building blocks of data in JavaScript. They are passed by value: when primitive values are assigned to variables or passed to functions, their contents are copied. They are compared by value: when comparing two primitive values, their contents are compared.","title":"Primitive values"},{"location":"javascript/javascript-fundamentals/values/#objects","text":"They are compound pieces of data They are passed by identity: when objects are assigned to variables or passed to functions, their identities (think pointers) are copied. They are compared by identity (my term): when comparing two objects, their identities are compared","title":"Objects"},{"location":"javascript/javascript-fundamentals/variables/","text":"Variables Const > Let Use always const unless you have to reset the variable, then use let const a = 2 ; a = 3 ; Uncaught TypeError : Assignment to constant variable . let a = 4 ; a = 6 ; And what about var? var was the variable before const and let were introduced. The reason why const and let were introduced is that they are block scoped. var is only function scoped but this is not enough as following example should show: function processArray ( array ) { for ( var i = 0 ; i < array . length ; i ++ ) { console . log ( \"Element \" , array [ i ]); } console . log ( \"I can use variable i outside the loop \" , i ); }","title":"Variables"},{"location":"javascript/javascript-fundamentals/variables/#variables","text":"","title":"Variables"},{"location":"javascript/javascript-fundamentals/variables/#const-let","text":"Use always const unless you have to reset the variable, then use let const a = 2 ; a = 3 ; Uncaught TypeError : Assignment to constant variable . let a = 4 ; a = 6 ;","title":"Const &gt; Let"},{"location":"javascript/javascript-fundamentals/variables/#and-what-about-var","text":"var was the variable before const and let were introduced. The reason why const and let were introduced is that they are block scoped. var is only function scoped but this is not enough as following example should show: function processArray ( array ) { for ( var i = 0 ; i < array . length ; i ++ ) { console . log ( \"Element \" , array [ i ]); } console . log ( \"I can use variable i outside the loop \" , i ); }","title":"And what about var?"},{"location":"javascript/react/","text":"Introduction In the following lecture we will discuss React at it's core. After the discussion, we will look at how to use React to build Web Applications. Please consider, that starting at this point is not a good idea. If you haven't done the lectures JavaScript Fundamentals and Browser API , I would suggest you, that you go back and start from that point. If you will proceed here, you will achieve maybe fast results, but in the long run it will get harder and harder to build a web application without the underlying knowlegde of the basics. So if you've already done the basics, let's right jump into it.","title":"Introduction"},{"location":"javascript/react/#introduction","text":"In the following lecture we will discuss React at it's core. After the discussion, we will look at how to use React to build Web Applications. Please consider, that starting at this point is not a good idea. If you haven't done the lectures JavaScript Fundamentals and Browser API , I would suggest you, that you go back and start from that point. If you will proceed here, you will achieve maybe fast results, but in the long run it will get harder and harder to build a web application without the underlying knowlegde of the basics. So if you've already done the basics, let's right jump into it.","title":"Introduction"},{"location":"javascript/react/children/","text":"Children When opening an html element and closing it <h1><u>Children</u></h1> , one can enter text or additional html elements inside the h1 element as u and Children for example. React solved this by passing a children key into props . Note: The children entry in props is created automatically. For example: const SayLoud = ({ children }) => { return < h1 > { children } < /h1>; }; function Root () { return ( < SayLoud > < u > Hello World < /u> < /SayLoud> ); } And a combined example: const SayLoud = ({ isLoud , children }) => { if ( isLoud ) { return < h1 > { children } < /h1>; } else { return < h2 > { children } < /h2>; } }; const Root = () => { return < SayLoud isLoud = { false } > Hello World < /SayLoud>; };","title":"Children"},{"location":"javascript/react/children/#children","text":"When opening an html element and closing it <h1><u>Children</u></h1> , one can enter text or additional html elements inside the h1 element as u and Children for example. React solved this by passing a children key into props . Note: The children entry in props is created automatically. For example: const SayLoud = ({ children }) => { return < h1 > { children } < /h1>; }; function Root () { return ( < SayLoud > < u > Hello World < /u> < /SayLoud> ); } And a combined example: const SayLoud = ({ isLoud , children }) => { if ( isLoud ) { return < h1 > { children } < /h1>; } else { return < h2 > { children } < /h2>; } }; const Root = () => { return < SayLoud isLoud = { false } > Hello World < /SayLoud>; };","title":"Children"},{"location":"javascript/react/component/","text":"Component Definition What is a component? Maybe you already heard about React and that it works component-based. But from a scientific perspective - what makes a component a component? Components consist of three main principles: Data Function Design Data defines the data of your interface. Function is the functionality, which a component provides. Design adds a look to the component. Example We already worked with distributed component-fragments: HTML, CSS and JS. HTML is our data CSS is our design JS is our function The problem, that exists before react was invented, was that those component-fragments were distributed . We had an index.html , index.js , and index.css . We glued everything in the index.html together but all parts were lossless in their own files which made it very hard to connect everything together in the head. With React we have one file per component and we see on the first sight, what belongs together.","title":"Component"},{"location":"javascript/react/component/#component","text":"","title":"Component"},{"location":"javascript/react/component/#definition","text":"What is a component? Maybe you already heard about React and that it works component-based. But from a scientific perspective - what makes a component a component? Components consist of three main principles: Data Function Design Data defines the data of your interface. Function is the functionality, which a component provides. Design adds a look to the component.","title":"Definition"},{"location":"javascript/react/component/#example","text":"We already worked with distributed component-fragments: HTML, CSS and JS. HTML is our data CSS is our design JS is our function The problem, that exists before react was invented, was that those component-fragments were distributed . We had an index.html , index.js , and index.css . We glued everything in the index.html together but all parts were lossless in their own files which made it very hard to connect everything together in the head. With React we have one file per component and we see on the first sight, what belongs together.","title":"Example"},{"location":"javascript/react/context/","text":"Context When we implement components, we want sometimes to have a shared and common state. Especially when it comes to store and manipulate data from the server in one place, but to have it used in two deep nested components. Let's start by defining a state in a variable: import { useContext } from \"react\" ; const ClickContext = createContext (); createContext creates a Context object which provides a Provider object via ClickContext.Provider . This Provider object is a React component , which passes its value prop to all child components, that subscribes to the Context . < ClickContext . Provider value = { /* some value */ } > If the value of a Provider changes, all subscribed React components will be rerendered. This Provider should wrap the top-level component, which then passes the value to its child components. Let's first build a custom Provider with useState in a file called clickContext.js import { useState } from \"react\" ; export const ClickContext = createContext (); export const ClickContextProvider = ({ children }) => { const [ clicks , setClicks ] = useState ( 0 ); const value = { clicks , setClicks }; return ( < ClickContext . Provider value = { value } > { children } < /ClickContext.Provider> ); }; Note that we create a ClickContext.Provider component and pass in the value as object, also we just render the children of our ClickContextProvider component but wrapped in the ClickContext.Provider to pass the value to the child components. Now we create some nested components to demonstrate the \"magic hidden\" passing of value to the child components. Our structure will look like this: - ClickContextProvider | +--+ App | +--+ ClickContainer | +--+ Click import { useContext } from \"react\" ; import { ClickContext , ClickContextProvider } from \"./clickContext\" ; const Click = () => { const { clicks , setClicks } = useContext ( ClickContext ); const onClick = () => setClicks ( clicks + 1 ); return ( < div > < button type = \"button\" onClick = { onClick } > Clicks { clicks } < /button> < /div> ); }; const ClickContainer = () => { return ( < div > < p > ClickContainer < /p> < Click /> < /div> ); }; const App = () => { return ( < ClickContextProvider > < div className = \"App\" > < ClickContainer /> < /div> < /ClickContextProvider> ); }; export default { Click , ClickContainer , App }; We import ClickContext and ClickContextProvider from our created file clickContext.js . Then we create three components: Click , ClickContainer , and App . We use the ClickContextProvider to wrap the top-level component and pass the value to all of its children in the App component. The ClickContainer is just an empty container which does not passes any props or receives any props. It's there for demonstration purpose. The Click component now \"grabs\" the context with useContext(ClickContext) . Please consider that it has to be exactly the imported ClickContext , otherwise it won't work. With useContext we receive the data which has been passed to the value ClickContext.Provider in the ClickContextProvider componen. So we receive an object with clicks and setClicks as keys and use it.","title":"Context"},{"location":"javascript/react/context/#context","text":"When we implement components, we want sometimes to have a shared and common state. Especially when it comes to store and manipulate data from the server in one place, but to have it used in two deep nested components. Let's start by defining a state in a variable: import { useContext } from \"react\" ; const ClickContext = createContext (); createContext creates a Context object which provides a Provider object via ClickContext.Provider . This Provider object is a React component , which passes its value prop to all child components, that subscribes to the Context . < ClickContext . Provider value = { /* some value */ } > If the value of a Provider changes, all subscribed React components will be rerendered. This Provider should wrap the top-level component, which then passes the value to its child components. Let's first build a custom Provider with useState in a file called clickContext.js import { useState } from \"react\" ; export const ClickContext = createContext (); export const ClickContextProvider = ({ children }) => { const [ clicks , setClicks ] = useState ( 0 ); const value = { clicks , setClicks }; return ( < ClickContext . Provider value = { value } > { children } < /ClickContext.Provider> ); }; Note that we create a ClickContext.Provider component and pass in the value as object, also we just render the children of our ClickContextProvider component but wrapped in the ClickContext.Provider to pass the value to the child components. Now we create some nested components to demonstrate the \"magic hidden\" passing of value to the child components. Our structure will look like this: - ClickContextProvider | +--+ App | +--+ ClickContainer | +--+ Click import { useContext } from \"react\" ; import { ClickContext , ClickContextProvider } from \"./clickContext\" ; const Click = () => { const { clicks , setClicks } = useContext ( ClickContext ); const onClick = () => setClicks ( clicks + 1 ); return ( < div > < button type = \"button\" onClick = { onClick } > Clicks { clicks } < /button> < /div> ); }; const ClickContainer = () => { return ( < div > < p > ClickContainer < /p> < Click /> < /div> ); }; const App = () => { return ( < ClickContextProvider > < div className = \"App\" > < ClickContainer /> < /div> < /ClickContextProvider> ); }; export default { Click , ClickContainer , App }; We import ClickContext and ClickContextProvider from our created file clickContext.js . Then we create three components: Click , ClickContainer , and App . We use the ClickContextProvider to wrap the top-level component and pass the value to all of its children in the App component. The ClickContainer is just an empty container which does not passes any props or receives any props. It's there for demonstration purpose. The Click component now \"grabs\" the context with useContext(ClickContext) . Please consider that it has to be exactly the imported ClickContext , otherwise it won't work. With useContext we receive the data which has been passed to the value ClickContext.Provider in the ClickContextProvider componen. So we receive an object with clicks and setClicks as keys and use it.","title":"Context"},{"location":"javascript/react/events/","text":"Events When we build rich web applications, we have to manage user interaction. In JavaScript, we manage user interactions with events. Normally, we would add an event listener to an html element and propose a callback to it when the event happens. Here an example: < html > < body > < h1 id = \"hello\" > Test </ h1 > < script > document . getElementById ( \"hello\" ) . addEventListener ( \"click\" , () => console . log ( \"you clicked Test!\" )); </ script > </ body > </ html > In React it's far simpler to attach an event listener to an element. Here is a full list of Supported React Events . And here is an example, how to use them: const HelloClick = () => { const onClick = ( event ) => { console . log ( \"You clicked the button with: \" , event ); }; return ( < button type = \"button\" onClick = { onClick } > Click me < /button> ); };","title":"Events"},{"location":"javascript/react/events/#events","text":"When we build rich web applications, we have to manage user interaction. In JavaScript, we manage user interactions with events. Normally, we would add an event listener to an html element and propose a callback to it when the event happens. Here an example: < html > < body > < h1 id = \"hello\" > Test </ h1 > < script > document . getElementById ( \"hello\" ) . addEventListener ( \"click\" , () => console . log ( \"you clicked Test!\" )); </ script > </ body > </ html > In React it's far simpler to attach an event listener to an element. Here is a full list of Supported React Events . And here is an example, how to use them: const HelloClick = () => { const onClick = ( event ) => { console . log ( \"You clicked the button with: \" , event ); }; return ( < button type = \"button\" onClick = { onClick } > Click me < /button> ); };","title":"Events"},{"location":"javascript/react/hooks/","text":"Hooks Hooks are a concept in React, which is pretty important. You will recognize Hooks by functions starting with use . Following Hooks are available: Basic Hooks useState useEffect useContext Additional Hooks useReducer useCallback useMemo useRef useImperativeHandle useLayoutEffect useDebugValue We will look at the basic hooks in this lecture, but let's start with an introduction about state in React first. State If we use a variable inside of a component and it changes, React won't automatically update the DOM. If you execute this code, you will see, that the variable increases but the DOM stays as it is. const UpdateYourself = () => { let myVariable = 1 ; setInterval (() => { myVariable += 1 ; console . log ( myVariable ); }, 500 ); return < p > { myVariable } < /p>; }; To let React update the DOM properly on changes and rerender only changed elements you have to use State\u2026 use State\u2026 useState(). Let's look at an example: import React , { useState } from 'react' ; const UpdateYourself = () => { const [ myVariable , setMyVariable ] = useState ( 1 ); setInterval (() => { setMyVariable ( myVariable + 1 ); }, 1000 ); return < p > { myVariable } < /p>; }; In the 1st line we import useState . In 4th line we call useState with the start value 1 . useState returns a list [state-variable, set-function] . The state-variable contains the value and the set-function to sets a new value. Note: setting the state-variable like a common variable won't work , because it's a state variable (and for shure, also a const). Difference object - primitive value If we have following component: import React , { useState } from 'react' ; const Component = () => { const [ primitive , setPrimitive ] = useState ( 1 ); const [ complex , setComplex ] = useState ({ firstName : 'Michael' }); const onClick = () => { setPrimitive ( primitive + 1 ); setComplex ({ ... complex , firstName : 'Test' }); }; return ( < button type = 'click' onClick = { onClick } > { primitive } - { complex . firstName } < /button> ); }; setPrimitive can be called easily with a \"new\" value, because the value of the variable primitive is a primitive value . setComplex cannot be called by changing firstName in the variable complex like this: This is wrong \u274c complex.firstName = 'Test''; setComplex(complex); It is bad, because this would not rerender the state. Here is why: If you compare two primitive values with the strict equality operator, surely two different values are different from each other: const a = 2 ; const b = a + 1 ; a === b ; // returns false But if you compare the same object, even by changing it, it will be still the same object: const a = { firstName : 'Test' }; const b = a ; b . firstName = 'Michael' ; a === b ; // returns true Therefore React does not recognize, that your object has changed and it won't rerender. Lifecycle React Hook Flow The react lifecycle When you build React components, sometimes it's needed to retrieve some values from a server on the mount state of a component and unload data when a component unmounts. Also sometimes some operations should recalculate values when a state variable changes. For that useEffect was invented. So imagine useEffect will be called every time something changes. When the component mounts , updates , and unmounts , thus on every render cycle. Let's start with an example: const App = () => { const [ myVar , setMyVar ] = useState ( 1 ); useEffect (() => { console . log ( 'update on every change' ); }); return ( < div > < p > MyVar : { myVar } < /p> < button type = 'button' onClick = {() => setMyVar ( myVar + 1 )} > Increment MyVar < /button> < /div> ); }; On every rerender cycle, the passed function into useEffect will be called. In the example above useEffect will be called on every button click. Dependencies useEffect has a second parameter which should be a list of state-variables, which can change over time. If we pass in the variables, useEffect is only called, when the passed variables inside the list change. Example: const App = () => { const [ myVar , setMyVar ] = useState ( 1 ); const [ anotherVar , setAnotherVar ] = useState ( 1 ); useEffect (() => { console . log ( 'update on myvar' ); }, [ myVar ]); useEffect (() => { console . log ( 'update on anothervar' ); }, [ anotherVar ]); return ( < div > < p > MyVar : { myVar } < /p> < p > AnotherVar : { anotherVar } < /p> < button type = 'button' onClick = {() => setMyVar ( myVar + 1 )} > Increment MyVar < /button> < button type = 'button' onClick = {() => setAnotherVar ( anotherVar + 1 )} > Increment AnotherVar < /button> < /div> ); }; So if we click on the \"Increment MyVar\" button only \"update on myvar\" will be printed to the console. If we click \"Increment AnotherVar\" button only \"update on anothervar\" will be printed. Call it only once (only on mount) But what if you want to call useEffect once - only on mount time of your component? For this behaviour just pass an empty list as second argument. This will trigger useEffect once and stop it from watching any state-variables. Let's call this an \"untracked\" useEffect. Here is an example: const App = () => { const [ myVar , setMyVar ] = useState ( 1 ); useEffect (() => { console . log ( 'called on mount' ); }, []); return ( < div > < p > MyVar : { myVar } < /p> < button type = 'button' onClick = {() => setMyVar ( myVar + 1 )} > Increment MyVar < /button> < /div> ); }; But what about the unmount time of a component? If you want to execute code on unmount time of a component just return a function in an untracked useEffect: const MyButton = ({ unmount }) => { useEffect (() => { return () => { console . log ( 'unmount mybutton' ); }; }, []); return ( < button type = 'button' onClick = { unmount } > Unmount < /button> ); }; const App = () => { const [ showMyButton , setShowMyButton ] = useState ( true ); const unmount = () => setShowMyButton ( false ); let myButtonContainer = null ; if ( showMyButton ) { myButtonContainer = < MyButton unmount = { unmount } /> ; } return { myButtonContainer }; }; Reducer Let's say you have to handle complex logic inside your component. For example you want to have your logic based on an event or on a previous state. Than reducer are your solution! In a nutshell one can say: \"If your state has a workflow , use reducers\" React provides us a hook for reducers. It's called useReducer . It takes a function the \"reducer\" as first argument and an initialState as second argument. InitialState is easy to comprehend, let's face reducer. Reducer takes a state and an action. The state parameter is always the current state when the reducer is dispatched. Action is the action which you will provide when you dispatch. useReducer returns, like useState, two variables in a list: [state, dispatch] . The state of your reducer and a dispatch method. Instead of setting a state like in useState , we now call the dispatch method and provide an action (which can be a string, a number, list or object). Then the reducer function gets called. Inside the reducer function the action gets evaluated. Then a new state is returned. And this is crucial: It has to be a completely new object, not a modified old one. Why? -> https://daveceddia.com/why-not-modify-react-state-directly/ const initialState = { count : 0 }; const reducer = ( state , action ) => { switch ( action . type ) { case 'increment' : return { count : state . count + 1 }; case 'decrement' : return { count : state . count - 1 }; default : throw new Error (); } }; const Counter = () => { const [ state , dispatch ] = useReducer ( reducer , initialState ); return ( <> Count : { state . count } < button onClick = {() => dispatch ({ type : 'decrement' })} >-< /button> < button onClick = {() => dispatch ({ type : 'increment' })} >+< /button> < /> ); }; Custom Hooks Custom Hooks are a really special topic. It's loved by them who use it and hated by them who don't understand it. Let's become the ones who use it :) Let's image, we want to write a function, which attaches an event listener to the DOM's scroll event and saves the current position of the body to a variable. We would write code like this: hooks/useBodyScrollPosition.js import { useState , useEffect } from 'react' ; const useBodyScrollPosition = () => { const [ scrollPosition , setScrollPosition ] = useState ( window . scrollY ); useEffect (() => { const handleScroll = () => setScrollPosition ( window . scrollY ); document . addEventListener ( 'scroll' , handleScroll ); return () => document . removeEventListener ( 'scroll' , handleScroll ); }, []); return scrollPosition ; }; components/One.js import React from \"react\"; import useBodyScrollPosition from \"./useBodyScrollPosition\"; const One = () => { const scrollPosition = useBodyScrollPosition(); return <div>{scrollPosition}</div>; }; export default One; components/Two.js import useBodyScrollPosition from './useBodyScrollPosition' ; const Two = () => { const scrollPosition = useBodyScrollPosition (); return < div > { scrollPosition } < /div>; }; export default Two ;","title":"Hooks"},{"location":"javascript/react/hooks/#hooks","text":"Hooks are a concept in React, which is pretty important. You will recognize Hooks by functions starting with use . Following Hooks are available: Basic Hooks useState useEffect useContext Additional Hooks useReducer useCallback useMemo useRef useImperativeHandle useLayoutEffect useDebugValue We will look at the basic hooks in this lecture, but let's start with an introduction about state in React first.","title":"Hooks"},{"location":"javascript/react/hooks/#state","text":"If we use a variable inside of a component and it changes, React won't automatically update the DOM. If you execute this code, you will see, that the variable increases but the DOM stays as it is. const UpdateYourself = () => { let myVariable = 1 ; setInterval (() => { myVariable += 1 ; console . log ( myVariable ); }, 500 ); return < p > { myVariable } < /p>; }; To let React update the DOM properly on changes and rerender only changed elements you have to use State\u2026 use State\u2026 useState(). Let's look at an example: import React , { useState } from 'react' ; const UpdateYourself = () => { const [ myVariable , setMyVariable ] = useState ( 1 ); setInterval (() => { setMyVariable ( myVariable + 1 ); }, 1000 ); return < p > { myVariable } < /p>; }; In the 1st line we import useState . In 4th line we call useState with the start value 1 . useState returns a list [state-variable, set-function] . The state-variable contains the value and the set-function to sets a new value. Note: setting the state-variable like a common variable won't work , because it's a state variable (and for shure, also a const).","title":"State"},{"location":"javascript/react/hooks/#difference-object-primitive-value","text":"If we have following component: import React , { useState } from 'react' ; const Component = () => { const [ primitive , setPrimitive ] = useState ( 1 ); const [ complex , setComplex ] = useState ({ firstName : 'Michael' }); const onClick = () => { setPrimitive ( primitive + 1 ); setComplex ({ ... complex , firstName : 'Test' }); }; return ( < button type = 'click' onClick = { onClick } > { primitive } - { complex . firstName } < /button> ); }; setPrimitive can be called easily with a \"new\" value, because the value of the variable primitive is a primitive value . setComplex cannot be called by changing firstName in the variable complex like this: This is wrong \u274c complex.firstName = 'Test''; setComplex(complex); It is bad, because this would not rerender the state. Here is why: If you compare two primitive values with the strict equality operator, surely two different values are different from each other: const a = 2 ; const b = a + 1 ; a === b ; // returns false But if you compare the same object, even by changing it, it will be still the same object: const a = { firstName : 'Test' }; const b = a ; b . firstName = 'Michael' ; a === b ; // returns true Therefore React does not recognize, that your object has changed and it won't rerender.","title":"Difference object - primitive value"},{"location":"javascript/react/hooks/#lifecycle","text":"React Hook Flow The react lifecycle When you build React components, sometimes it's needed to retrieve some values from a server on the mount state of a component and unload data when a component unmounts. Also sometimes some operations should recalculate values when a state variable changes. For that useEffect was invented. So imagine useEffect will be called every time something changes. When the component mounts , updates , and unmounts , thus on every render cycle. Let's start with an example: const App = () => { const [ myVar , setMyVar ] = useState ( 1 ); useEffect (() => { console . log ( 'update on every change' ); }); return ( < div > < p > MyVar : { myVar } < /p> < button type = 'button' onClick = {() => setMyVar ( myVar + 1 )} > Increment MyVar < /button> < /div> ); }; On every rerender cycle, the passed function into useEffect will be called. In the example above useEffect will be called on every button click.","title":"Lifecycle"},{"location":"javascript/react/hooks/#dependencies","text":"useEffect has a second parameter which should be a list of state-variables, which can change over time. If we pass in the variables, useEffect is only called, when the passed variables inside the list change. Example: const App = () => { const [ myVar , setMyVar ] = useState ( 1 ); const [ anotherVar , setAnotherVar ] = useState ( 1 ); useEffect (() => { console . log ( 'update on myvar' ); }, [ myVar ]); useEffect (() => { console . log ( 'update on anothervar' ); }, [ anotherVar ]); return ( < div > < p > MyVar : { myVar } < /p> < p > AnotherVar : { anotherVar } < /p> < button type = 'button' onClick = {() => setMyVar ( myVar + 1 )} > Increment MyVar < /button> < button type = 'button' onClick = {() => setAnotherVar ( anotherVar + 1 )} > Increment AnotherVar < /button> < /div> ); }; So if we click on the \"Increment MyVar\" button only \"update on myvar\" will be printed to the console. If we click \"Increment AnotherVar\" button only \"update on anothervar\" will be printed.","title":"Dependencies"},{"location":"javascript/react/hooks/#call-it-only-once-only-on-mount","text":"But what if you want to call useEffect once - only on mount time of your component? For this behaviour just pass an empty list as second argument. This will trigger useEffect once and stop it from watching any state-variables. Let's call this an \"untracked\" useEffect. Here is an example: const App = () => { const [ myVar , setMyVar ] = useState ( 1 ); useEffect (() => { console . log ( 'called on mount' ); }, []); return ( < div > < p > MyVar : { myVar } < /p> < button type = 'button' onClick = {() => setMyVar ( myVar + 1 )} > Increment MyVar < /button> < /div> ); }; But what about the unmount time of a component? If you want to execute code on unmount time of a component just return a function in an untracked useEffect: const MyButton = ({ unmount }) => { useEffect (() => { return () => { console . log ( 'unmount mybutton' ); }; }, []); return ( < button type = 'button' onClick = { unmount } > Unmount < /button> ); }; const App = () => { const [ showMyButton , setShowMyButton ] = useState ( true ); const unmount = () => setShowMyButton ( false ); let myButtonContainer = null ; if ( showMyButton ) { myButtonContainer = < MyButton unmount = { unmount } /> ; } return { myButtonContainer }; };","title":"Call it only once (only on mount)"},{"location":"javascript/react/hooks/#reducer","text":"Let's say you have to handle complex logic inside your component. For example you want to have your logic based on an event or on a previous state. Than reducer are your solution! In a nutshell one can say: \"If your state has a workflow , use reducers\" React provides us a hook for reducers. It's called useReducer . It takes a function the \"reducer\" as first argument and an initialState as second argument. InitialState is easy to comprehend, let's face reducer. Reducer takes a state and an action. The state parameter is always the current state when the reducer is dispatched. Action is the action which you will provide when you dispatch. useReducer returns, like useState, two variables in a list: [state, dispatch] . The state of your reducer and a dispatch method. Instead of setting a state like in useState , we now call the dispatch method and provide an action (which can be a string, a number, list or object). Then the reducer function gets called. Inside the reducer function the action gets evaluated. Then a new state is returned. And this is crucial: It has to be a completely new object, not a modified old one. Why? -> https://daveceddia.com/why-not-modify-react-state-directly/ const initialState = { count : 0 }; const reducer = ( state , action ) => { switch ( action . type ) { case 'increment' : return { count : state . count + 1 }; case 'decrement' : return { count : state . count - 1 }; default : throw new Error (); } }; const Counter = () => { const [ state , dispatch ] = useReducer ( reducer , initialState ); return ( <> Count : { state . count } < button onClick = {() => dispatch ({ type : 'decrement' })} >-< /button> < button onClick = {() => dispatch ({ type : 'increment' })} >+< /button> < /> ); };","title":"Reducer"},{"location":"javascript/react/hooks/#custom-hooks","text":"Custom Hooks are a really special topic. It's loved by them who use it and hated by them who don't understand it. Let's become the ones who use it :) Let's image, we want to write a function, which attaches an event listener to the DOM's scroll event and saves the current position of the body to a variable. We would write code like this: hooks/useBodyScrollPosition.js import { useState , useEffect } from 'react' ; const useBodyScrollPosition = () => { const [ scrollPosition , setScrollPosition ] = useState ( window . scrollY ); useEffect (() => { const handleScroll = () => setScrollPosition ( window . scrollY ); document . addEventListener ( 'scroll' , handleScroll ); return () => document . removeEventListener ( 'scroll' , handleScroll ); }, []); return scrollPosition ; }; components/One.js import React from \"react\"; import useBodyScrollPosition from \"./useBodyScrollPosition\"; const One = () => { const scrollPosition = useBodyScrollPosition(); return <div>{scrollPosition}</div>; }; export default One; components/Two.js import useBodyScrollPosition from './useBodyScrollPosition' ; const Two = () => { const scrollPosition = useBodyScrollPosition (); return < div > { scrollPosition } < /div>; }; export default Two ;","title":"Custom Hooks"},{"location":"javascript/react/jsx/","text":"JSX JSX is the solution to avoid separation of technologies, but rather support separation of concerns Example This is an easy JSX example, where we create a simple React component: const HelloWorld = () => { return < h1 > Hello World < /h1>; }; Transpiling JSX into JavaScript with Babel will look like this: \"use strict\" ; var HelloWorld = function HelloWorld () { return /*#__PURE__*/ React . createElement ( \"h1\" , null , \"Hello World\" ); }; Scopes When writing JSX inside of a component, one cannot just code JavaScript again: const HelloWorld = () => { const helloWorld = \"Hello World\" ; return < h1 > helloWorld < /h1>; / / \u2190 this will not work ! }; Instead of the example above we have to use curly braces to enter into a javascript context again. Note: Curly braces evaluate only a javascript expression [Link]! const HelloWorld = () => { const helloWorld = \"Hello World\" ; return < h1 > { helloWorld } < /h1>; }; In conclusion, JSX follows two concepts: - JS Scope | +-+ HTML Scope | +-+ JS expression Scope If you are in the JS Scope you can program JavaScript without restrictions. If you switch to the HTML scope with an HTML element, you can only proceed with HTML: < div > [ here is the HTML Scope ] </ div > Switching from HTML scope to JS expression scope with curly braces {} allow only to use JS expressions, these are only JS statements which return a value like: <p>{1+2}</p> <p> { [1, 2, 3].map( (val) => val + 1 ).reduce( (acc, val) => acc + val, 0 ) } </p> <p>`Result is ${1+2}`</p> When using JSX in multi lines then wrap it in round brackets: const HelloWorld = () => { return ( < h1 > < u > Hello World underlined < /u> < /h1> ); }; You can also store JSX in a variable: const HelloWorld = () => { const underlinedHelloWorld = < u > Hello World underlined < /u>; return underlinedHelloWorld ; }; Or store it in a variable and reuse it inside JSX: const HelloWorld = () => { const i = 2 ; let text ; if ( i % 2 === 0 ) { text = < p > i is divisible by two < /p>; } else { text = < p > i is not divisible by two < /p>; } return < div > { text } < /div>; };","title":"JSX"},{"location":"javascript/react/jsx/#jsx","text":"JSX is the solution to avoid separation of technologies, but rather support separation of concerns","title":"JSX"},{"location":"javascript/react/jsx/#example","text":"This is an easy JSX example, where we create a simple React component: const HelloWorld = () => { return < h1 > Hello World < /h1>; }; Transpiling JSX into JavaScript with Babel will look like this: \"use strict\" ; var HelloWorld = function HelloWorld () { return /*#__PURE__*/ React . createElement ( \"h1\" , null , \"Hello World\" ); };","title":"Example"},{"location":"javascript/react/jsx/#scopes","text":"When writing JSX inside of a component, one cannot just code JavaScript again: const HelloWorld = () => { const helloWorld = \"Hello World\" ; return < h1 > helloWorld < /h1>; / / \u2190 this will not work ! }; Instead of the example above we have to use curly braces to enter into a javascript context again. Note: Curly braces evaluate only a javascript expression [Link]! const HelloWorld = () => { const helloWorld = \"Hello World\" ; return < h1 > { helloWorld } < /h1>; }; In conclusion, JSX follows two concepts: - JS Scope | +-+ HTML Scope | +-+ JS expression Scope If you are in the JS Scope you can program JavaScript without restrictions. If you switch to the HTML scope with an HTML element, you can only proceed with HTML: < div > [ here is the HTML Scope ] </ div > Switching from HTML scope to JS expression scope with curly braces {} allow only to use JS expressions, these are only JS statements which return a value like: <p>{1+2}</p> <p> { [1, 2, 3].map( (val) => val + 1 ).reduce( (acc, val) => acc + val, 0 ) } </p> <p>`Result is ${1+2}`</p> When using JSX in multi lines then wrap it in round brackets: const HelloWorld = () => { return ( < h1 > < u > Hello World underlined < /u> < /h1> ); }; You can also store JSX in a variable: const HelloWorld = () => { const underlinedHelloWorld = < u > Hello World underlined < /u>; return underlinedHelloWorld ; }; Or store it in a variable and reuse it inside JSX: const HelloWorld = () => { const i = 2 ; let text ; if ( i % 2 === 0 ) { text = < p > i is divisible by two < /p>; } else { text = < p > i is not divisible by two < /p>; } return < div > { text } < /div>; };","title":"Scopes"},{"location":"javascript/react/props/","text":"Props React provides a way to pass attributes to a component. It's called props . When we pass HTML-attributes to a React component, they will be forwarded to the parameters of the React component function. Example const SayLoud = ( props ) => { return ( < h1 > { props . text } { props . anotherText } < /h1> ); }; function Root () { return < SayLoud text = \"Hello\" anotherText = \"World\" /> ; // don't forget the closing style \"/>\" } Destructure props We can destructure the props variable easily: const SayLoud = ({ text }) => { return < h1 > { text } < /h1>; }; function Root () { const helloWorld = \"Hello World\" ; return < SayLoud text = { helloWorld } /> ; }","title":"Props"},{"location":"javascript/react/props/#props","text":"React provides a way to pass attributes to a component. It's called props . When we pass HTML-attributes to a React component, they will be forwarded to the parameters of the React component function.","title":"Props"},{"location":"javascript/react/props/#example","text":"const SayLoud = ( props ) => { return ( < h1 > { props . text } { props . anotherText } < /h1> ); }; function Root () { return < SayLoud text = \"Hello\" anotherText = \"World\" /> ; // don't forget the closing style \"/>\" }","title":"Example"},{"location":"javascript/react/props/#destructure-props","text":"We can destructure the props variable easily: const SayLoud = ({ text }) => { return < h1 > { text } < /h1>; }; function Root () { const helloWorld = \"Hello World\" ; return < SayLoud text = { helloWorld } /> ; }","title":"Destructure props"},{"location":"javascript/react/reactdom-render/","text":"ReactDOM.render To render a React component into the DOM, react-dom exports a render function. The function will render your React components instead of the provided HTML element. import { useState } from \"react\" ; import ReactDOM from \"react-dom\" ; const HelloWorld = () => { return < h1 > Hello World < /h1>; }; ReactDOM . render ( < HelloWorld /> , document . getElementById ( \"root\" )); Note: We use the HelloWorld constant as an HTML-Element. The example above would render like following: from this: < html > < body > < div id = \"root\" ></ div > </ body > </ html > to this: < html > < body > < h1 > Hello World </ h1 > </ body > </ html >","title":"ReactDOM.render"},{"location":"javascript/react/reactdom-render/#reactdomrender","text":"To render a React component into the DOM, react-dom exports a render function. The function will render your React components instead of the provided HTML element. import { useState } from \"react\" ; import ReactDOM from \"react-dom\" ; const HelloWorld = () => { return < h1 > Hello World < /h1>; }; ReactDOM . render ( < HelloWorld /> , document . getElementById ( \"root\" )); Note: We use the HelloWorld constant as an HTML-Element. The example above would render like following: from this: < html > < body > < div id = \"root\" ></ div > </ body > </ html > to this: < html > < body > < h1 > Hello World </ h1 > </ body > </ html >","title":"ReactDOM.render"},{"location":"javascript/react/render-engine/","text":"Render Engine Image we want to build a render engine in JavaScript. So for example we want to build a todo list with plain JavaScript. We would maybe start with this: index.html < html > < head > < script type = \"text/javascript\" src = \"./index.js\" ></ script > </ head > < body > < div id = \"main\" ></ div > </ body > </ html > index.js document . addEventListener ( \"DOMContentLoaded\" , () => { const main = document . getElementById ( \"main\" ); const input = document . createElement ( \"input\" ); input . type = \"text\" ; main . appendChild ( input ); const button = document . createElement ( \"button\" ); button . type = \"button\" ; button . innerText = \"Click!\" ; main . appendChild ( button ); const list = document . createElement ( \"ul\" ); list . id = \"list\" ; main . appendChild ( list ); button . addEventListener ( \"click\" , ( event ) => { const inputValue = input . value ; if ( inputValue === \"\" ) return ; const listItem = document . createElement ( \"li\" ); listItem . innerText = inputValue ; const list = document . getElementById ( \"list\" ); list . appendChild ( listItem ); }); }); Now let's proceed and abstract the creation of the elements, so that we build the first steps of a rendering engine. index.js const createElement = ( name , attributes = {}, children = []) => { const element = document . createElement ( name ); for ( const attribute of Object . keys ( attributes )) { element . setAttribute ( attribute , attributes [ attribute ]); } for ( const child of children ) { if ( typeof child === \"string\" ) { const textNode = document . createTextNode ( child ); element . appendChild ( textNode ); } else { element . appendChild ( child ); } } return element ; }; document . addEventListener ( \"DOMContentLoaded\" , () => { const main = document . getElementById ( \"main\" ); const input = createElement ( \"input\" , { type : \"text\" }); const button = createElement ( \"button\" , { type : \"button\" }, [ \"Add\" ]); const list = createElement ( \"ul\" ); main . appendChild ( input ); main . appendChild ( button ); main . appendChild ( list ); button . addEventListener ( \"click\" , ( event ) => { const inputValue = input . value ; if ( inputValue === \"\" ) return ; const listItem = createElement ( \"li\" , {}, [ inputValue ]); list . appendChild ( listItem ); }); }); With createElement we build a small rendering engine, which is, in an abstract way, exactly how react works.","title":"Render Engine"},{"location":"javascript/react/render-engine/#render-engine","text":"Image we want to build a render engine in JavaScript. So for example we want to build a todo list with plain JavaScript. We would maybe start with this: index.html < html > < head > < script type = \"text/javascript\" src = \"./index.js\" ></ script > </ head > < body > < div id = \"main\" ></ div > </ body > </ html > index.js document . addEventListener ( \"DOMContentLoaded\" , () => { const main = document . getElementById ( \"main\" ); const input = document . createElement ( \"input\" ); input . type = \"text\" ; main . appendChild ( input ); const button = document . createElement ( \"button\" ); button . type = \"button\" ; button . innerText = \"Click!\" ; main . appendChild ( button ); const list = document . createElement ( \"ul\" ); list . id = \"list\" ; main . appendChild ( list ); button . addEventListener ( \"click\" , ( event ) => { const inputValue = input . value ; if ( inputValue === \"\" ) return ; const listItem = document . createElement ( \"li\" ); listItem . innerText = inputValue ; const list = document . getElementById ( \"list\" ); list . appendChild ( listItem ); }); }); Now let's proceed and abstract the creation of the elements, so that we build the first steps of a rendering engine. index.js const createElement = ( name , attributes = {}, children = []) => { const element = document . createElement ( name ); for ( const attribute of Object . keys ( attributes )) { element . setAttribute ( attribute , attributes [ attribute ]); } for ( const child of children ) { if ( typeof child === \"string\" ) { const textNode = document . createTextNode ( child ); element . appendChild ( textNode ); } else { element . appendChild ( child ); } } return element ; }; document . addEventListener ( \"DOMContentLoaded\" , () => { const main = document . getElementById ( \"main\" ); const input = createElement ( \"input\" , { type : \"text\" }); const button = createElement ( \"button\" , { type : \"button\" }, [ \"Add\" ]); const list = createElement ( \"ul\" ); main . appendChild ( input ); main . appendChild ( button ); main . appendChild ( list ); button . addEventListener ( \"click\" , ( event ) => { const inputValue = input . value ; if ( inputValue === \"\" ) return ; const listItem = createElement ( \"li\" , {}, [ inputValue ]); list . appendChild ( listItem ); }); }); With createElement we build a small rendering engine, which is, in an abstract way, exactly how react works.","title":"Render Engine"},{"location":"javascript/web-workers-in-react/introduction/","text":"Introduction This lecture contains a tutorial, which describes Web Workers in React.","title":"Introduction"},{"location":"javascript/web-workers-in-react/introduction/#introduction","text":"This lecture contains a tutorial, which describes Web Workers in React.","title":"Introduction"},{"location":"javascript/web-workers-in-react/tutorial/","text":"Tutorial Settings up Web Workers in React is pretty simple. All we need to do is just to include a Webpack module and import it, so we can use it afterwards. Let's start! Setup First we install worker-loader : yarn add worker-loader Usage The worker Then we need to write the worker first, lets start with an easy example by now: // ./src/workers/default.js import hello from '../helper-functions/bla'; onmessage = (event) => { hello(); console.log('Message received from main script'); const workerResult = 'Result: ' + event; console.log('Posting message back to main script'); postMessage(workerResult); }; The worker consumer Now we just need to import the worker as the file would export a Worker instance. // ./src/App.js import { useEffect, useState } from 'react'; /* eslint-disable import/no-webpack-loader-syntax */ import DefaultWorker from 'worker-loader!./workers/default.js'; const App = () => { const [worker, setWorker] = useState(); useEffect(() => { const tempWorker = new DefaultWorker(); tempWorker.onmessage = (event) => { console.log(event.data); }; setWorker(tempWorker); return () => { tempWorker.terminate(); }; }, []); const onClick = () => { worker.postMessage('Hello World!'); }; return ( <div className='App'> <button type='button' onClick={onClick}> Send and receive message </button> </div> ); }; export default App;","title":"Tutorial"},{"location":"javascript/web-workers-in-react/tutorial/#tutorial","text":"Settings up Web Workers in React is pretty simple. All we need to do is just to include a Webpack module and import it, so we can use it afterwards. Let's start!","title":"Tutorial"},{"location":"javascript/web-workers-in-react/tutorial/#setup","text":"First we install worker-loader : yarn add worker-loader","title":"Setup"},{"location":"javascript/web-workers-in-react/tutorial/#usage","text":"","title":"Usage"},{"location":"javascript/web-workers-in-react/tutorial/#the-worker","text":"Then we need to write the worker first, lets start with an easy example by now: // ./src/workers/default.js import hello from '../helper-functions/bla'; onmessage = (event) => { hello(); console.log('Message received from main script'); const workerResult = 'Result: ' + event; console.log('Posting message back to main script'); postMessage(workerResult); };","title":"The worker"},{"location":"javascript/web-workers-in-react/tutorial/#the-worker-consumer","text":"Now we just need to import the worker as the file would export a Worker instance. // ./src/App.js import { useEffect, useState } from 'react'; /* eslint-disable import/no-webpack-loader-syntax */ import DefaultWorker from 'worker-loader!./workers/default.js'; const App = () => { const [worker, setWorker] = useState(); useEffect(() => { const tempWorker = new DefaultWorker(); tempWorker.onmessage = (event) => { console.log(event.data); }; setWorker(tempWorker); return () => { tempWorker.terminate(); }; }, []); const onClick = () => { worker.postMessage('Hello World!'); }; return ( <div className='App'> <button type='button' onClick={onClick}> Send and receive message </button> </div> ); }; export default App;","title":"The worker consumer"}]}